<style>

:root {
    --note-bottom: rgba(255, 255, 0, 1);
    --note-border: rgba(70, 70, 0, 1);
    --note-border-light: rgb(191, 191, 2);
}

.alwaysOnTop{
    z-index: 11000 !important;
}

.noteContainer {
    position: relative !important;
    float: right !important;
    /* border: 1px red dotted;   */
    height: 1px !important; 
    margin-bottom: -1px !important;
    width: auto !important;
    pointer-events: none;
    /* background-color: rgba(255,0,0,0.4) !important; */
    z-index: 9996 !important;
    overflow: visible;

    opacity: 1;

    /*testing new absolute note container*/
    position: absolute !important;
    top: 0 !important;
    right: 2px !important;
    height: 100% !important;

}

.indexcards .level1::after > .noteContainer { 
    /* see outline.css*/
}

/* .markersAreDisplayed .noteContainer{ */
.scene:has(.review) .noteContainer{
    right: 10px !important
}

.scene:has(.marker) .noteContainer{
    right: 20px !important
}

.marker {
    /* background-color: transparent; */
    background: grey;
    position: absolute;
    right: -2px;
    height: 0px;
    height: 12px;
    min-width: 20px;
    width: auto; /* for purpose of marker name */
    max-width: 80%;

    pointer-events: all !important;

    padding-right: 4px;

    z-index: 998;

    /* opacity: 0.8; */

    color: white;
    font-weight: bold;
    font-size: 10px !important;
    line-height: 15px !important;
    overflow: hidden;

    border: 1px rgba(0,0,0,0.6) solid;

    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%, 6px 50%);

    transition: max-width 0.2s;

}

.marker::after{

    content: "";
    position: absolute;
    top: -3.44px;
    left: -2px;

    border-left: 8px rgba(0,0,0,0.6) solid;
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
    border-right: 8px solid transparent;

    height: 1px;
    width: 100%;
    display: block;

}

.marker .markertext{

    position: relative;
    display: inline-block;

    top: -2px;
    left: 10px;

    width: calc(100% - 7px);
    height: 16px;
    margin-right: 10px;
    
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;

    z-index: 9999;

    pointer-events: none;

    opacity: 1;

}

#flexiContainer.indexcards .marker,
#flexiContainer.nonProportionalMode .marker {
    position: absolute;

    top: 1px !important;
    right: 2px; 
    
    height: 10px;
    width: 15px !important;
    max-width: none !important;
    min-width: 0px !important;
    padding: none;

    transform: rotate(-90deg);

    pointer-events: all !important;
}

#flexiContainer.indexcards .marker::after,
#flexiContainer.nonProportionalMode .marker::after {

    left: -2px;
    top: -3.44px !important;

    border-top-width: 7px;
    border-bottom-width: 7px;

}

#flexiContainer.indexcards .section>.marker,
#flexiContainer.nonProportionalMode .section>.marker {
    /* top: -2px !important; */
    z-index: 9999 !important;
}

#flexiContainer.indexcards :nth-child(2 of .marker),
#flexiContainer.nonProportionalMode :nth-child(2 of .marker){
    right: 14px;
}
#flexiContainer.indexcards :nth-child(3 of .marker),
#flexiContainer.nonProportionalMode :nth-child(3 of .marker){
    right: 26px !important;
}
#flexiContainer.indexcards :nth-child(4 of .marker),
#flexiContainer.nonProportionalMode :nth-child(4 of .marker){
    right: 38px !important;
}
#flexiContainer.indexcards :nth-child(5 of .marker),
#flexiContainer.nonProportionalMode :nth-child(5 of .marker){
    right: 50px !important;
}

/* #flexiContainer.indexcards .marker::after,
#flexiContainer.nonProportionalMode .marker::after {

width: 15px;
height: 13px;
left: -7.5px;
top: -6.5px;

}

#flexiContainer.indexcards .marker::before,
#flexiContainer.nonProportionalMode .marker::before {
    position: absolute;
    top: -6px;
    left: -7px;
    width: 14px;
    height: 11px;
    content: " ";

    border-top: 0.5px solid white;
    border-right: 1px solid #333;
    border-bottom: 0.5px solid black; 
    opacity: 0.4;
} */

.marker:hover {
    /* transform: translateX(-3px) scaleX(1.3);
    transition: 0.05s;  */
    /* filter: grayscale(1) invert(1) contrast(2) */
    background-image: linear-gradient(rgba(0,0,0,0.6) 0%,rgba(0,0,0,0.6) 100%);
    opacity: 1;
    color: white !important;
}

#flexiContainer .faux .marker .markertext,
#flexiContainer.unShowMarkerText .marker .markertext,
#flexiContainer.indexcards .marker .markertext,
#flexiContainer.nonProportionalMode .marker .markertext {

    /* display:none; */
    width: 0px;
    opacity: 0;
    text-overflow: clip;
    transition-delay: 0.2s

}

#flexiContainer.unShowMarkerText .marker {

    max-width: 20px
}


#flexiContainer.indexcards .marker:hover,
#flexiContainer.nonProportionalMode .marker:hover {
    transform: translateY(2px) scaleY(1.3) scaleX(0.8) rotate(-90deg) !important;
    transition: 0.1s;
}


.beat{
    position: absolute;
    background-color: purple;
    padding: 0.5px 2px;
    height: 14px; 
    font-size: 10px;
    line-height: 11px;
    color: white;
    border: 1px rgba(255,255,255,1) solid;
    font-weight: bold;
    border-radius: 4px;
    opacity: 1;
    box-shadow: 1px 1px 6px rgba(0,0,0,0.7);

    /* transition: all 0.2s; */
    pointer-events: all !important;
}

.beat:hover{
    color: black;
    background: white !important;

}

.hiddenBeat{
    display: none;
}

.largerBeat{

    height: 20px;
    font-size: 14px;
    line-height: 14px !important;
    margin-top: -2px;
    padding: 1px 4px !important;
    border-width: 2px;

    /* transition: all 0.3s !important; */

}

.allpaths, .svgForBeats {
    stroke-width: 5px;
    stroke-dasharray: 4 2;
    stroke: white !important;

    filter: drop-shadow(1px 1px 3px rgba(0,0,0,0.6))
}

.pathOf1{
    stroke: purple;
}
.pathOf2{
    stroke: midnightblue;

}
.pathOf3{
    stroke: forestgreen;
}
.pathOf4{
    stroke: firebrick;
}
.pathOf5{
    stroke: deeppink;
}
.pathOf6{
    stroke: black;
}

.hiddenPath{
    display: none;
}

.hideSlugIfSmall > .noteContainer {
    height: 15px !important;
}

.developing-a-new-note {

    opacity: 0.8 !important;

    position: relative !important;
    float: left !important;
    padding: 0 !important;
    margin: 0 0px 0px 2px !important;

    height: 15px !important;
    width: 15px !important;
    border-left: 10px var(--note-bottom) solid; 
    border-top: 15px var(--note-bottom) solid; 
    border-right: 15px transparent solid;

    z-index: 999 !important;
    white-space: normal;
    
    pointer-events: all;

    overflow: hidden;

}

.note {

    opacity: 0.8 !important;

    position: relative !important;
    float: left !important;
    padding: 0 !important;
    margin: 0 0px 0px 2px !important;
    background-color: var(--note-bottom);
    
    /* background:  */
    /* linear-gradient(to bottom right, transparent 16px, var(--note-border) 16px, var(--note-border) 17px, transparent 17px), */
    /* conic-gradient(from 0deg at 13px 9px, var(--note-border), var(--note-border) 135deg, transparent 135deg),
    conic-gradient(from 270deg at 9px 13px, transparent, transparent 225deg, var(--note-border) 225deg),
    linear-gradient(to bottom right, var(--note-bottom), var(--note-bottom) 16px, transparent 16px) */
    /* ; */

    border: 1px solid rgba(0,0,0,0.75);

    /* border-left: 1px solid var(--note-border) !important; 
    border-top: 1px solid var(--note-border) !important;  */
    height: 15px !important;
    width: 15px !important;
    color: rgba(0,0,0,0);

    z-index: 999 !important;
    white-space: normal;
    
    pointer-events: all;

    overflow: hidden;

    clip-path: polygon(0 0, 100% 0, 100% calc(100% - 4.1px), calc(100% - 4.1px) 100%, 0 100%);
    /* transform: rotate(-3deg);  */
    overflow: hidden;

    /* border-radius: 0 0 6.5px 0;
    box-shadow: 1.5px 1.5px 2.5px rgba(0,0,0,0.25); */

}

.note::before{
    position: absolute;
    border-radius: 0;
    content: " ";
    width: 4px;
    height: 4px;
    border-top: 1px solid  rgba(0,0,0,0.0); /*var(--note-border);*/
    border-left: 1px solid  rgba(0,0,0,0.0); /*var(--note-border);*/
    background: linear-gradient(to bottom right, transparent 0%, transparent 1.5px, rgba(0,0,0,0.7) 1.5px, rgba(0,0,0,0.7) 99%, transparent 100%);
    left: 9px;
    top: 9px;
    /* z-index: 11111 */

}

#expandedNote .showSectionPageNumber{
    font-size: 8px !important;
    line-height: 8px !important;
    margin-top: 2px !important;
    padding-right: 10px !important;
}

/* .note:first-of-type {
    margin-left: 60px !important;
} */

.selectedNote {
    
	/* background-image: -webkit-linear-gradient(top, var(--note-border), var(--note-border)) !important;  */
    background-image: 

    linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.7) 100%);
    /* linear-gradient(to bottom right, transparent 16px, var(--note-border) 16px, var(--note-border) 17px, transparent 17px), */
    /* conic-gradient(from 0deg at 13px 9px, black, black 135deg, transparent 135deg),
    conic-gradient(from 270deg at 9px 13px, transparent, transparent 225deg, black 225deg),
    linear-gradient(to bottom right, var(--note-border), var(--note-border) 16px, transparent 16px)
    ; */
    border-color: black !important; /* var(--note-bottom) !important; */
}

/* .note:before {
  content: "";
  position: absolute;
  bottom: 0px !important;
  right: 0px !important;
  width: 3px !important;
  height: 3px !important;
  border-width: 1px 0 0 1px;
  border-style: solid;
  border-color: var(--note-border);
  background-image: linear-gradient(to top left,var(--note-border) , var(--note-border) 2.5px,rgba(0,0,0,0) 2.5px, rgba(0,0,0,0) 100%); 
} */

/* .note::after, .noteContainer::after, .sceneHeading::before, .sceneHeading>p::before, .sceneHeading>.showSceneNum::before{
    clear: both;
    display: block;

} */

.selectedNote:before {
  border-color: black !important; /* var(--note-border) !important; */
  background: linear-gradient(to bottom right, transparent, transparent 1.5px, black 1.5px, black 2.5px, transparent 2.5px);

  /* background-image: linear-gradient(to top left,black , black 2.5px,rgba(0,0,0,0) 2.5px, rgba(0,0,0,0) 100%) !important;  */
}

#expandedNote{

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font-weight: normal !important;
    text-align: left !important;
    line-height: 12px !important;

    opacity: 1 !important;

    position: absolute;

    /* height: auto; */
    min-height: 50px;
    
    background-color: rgb(255,255,128);
    color: rgba(0,0,0,0.7);
    border:1px solid rgba(0,0,0,0.7);
    border-radius: 5px !important;
    
    white-space: normal;
    padding: 0px 8px 8px 8px !important;

    /* background-image: repeating-linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 16px, var(--note-border-light) 16px, var(--note-border-light) 17px) !important; */
    background-image: repeating-linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 16px, rgba(0,0,0,0.2) 16px, rgba(0,0,0,0.2) 17px) !important;

    box-shadow: 2px 2px 10px rgba(0,0,0,0.6);
    overflow: hidden;

    z-index: 9997 !important;
}

#expandedNote.omittedNote {

    background-image: 	
        repeating-linear-gradient(
            180deg, 
            rgba(0,0,0,0) 0%, 
            rgba(0,0,0,0) 16px, 
            var(--note-border-light) 16px, 
            var(--note-border-light) 17px),
        repeating-linear-gradient(
			-45deg,
			rgba(0,0,0,0.1) 0px,
			rgba(0,0,0,0.1) 3px,
			rgba(255,255,255,0.2) 3px,
			rgba(255,255,255,0.2) 6px)
            
    !important; 
}

#expandedNote text{
    font-size: 14px !important;
    line-height: 17px !important;
    margin-top: -1px !important; 
    padding-top: 17px;
    padding-bottom: 6px;
    font-family: 'Courier Prime', 'Courier New', Courier, monospace;
    white-space: normal;
    text-decoration: underline dotted var(--note-border);
    display: block;
}

#expandedNote b{
    font-size: 12px !important;
    padding: 5px 9px 0px 9px;
    margin: 0px -9px 2px -9px; 
    line-height: 12px !important;
    /* background-color: hsl(60, 50%, 50%); */
    background-color: rgba(0,0,0,0.2);
    color:  rgba(0,0,0,0.75);
    display: block;
    text-align: left;

    font-weight: 700;

    overflow: hidden;
    text-overflow: ellipsis;
}


.trashNote {
    height: 12px !important;
    width: 12px !important;
    line-height: 12px !important;
    float: right !important;
    /* border: 1px red solid !important;  */
    overflow: visible !important;
    margin-top: -3px !important;
    pointer-events: all;

}

#trashbutton{
    /* fill: var(--note-border); */
    fill:  rgba(0,0,0,0.75);
    pointer-events: none;
    opacity: 0.6 !important;

}
#trashNote:hover > #trashbutton{
    fill: rgb(192,0,0) !important;
    /* stroke: black !important;
    stroke-width: 5px !important;  */
    opacity: 1 !important;
    
    overflow: visible !important;
    transition: all 0s !important;
}

/* #trashNote:hover,
.trashNote:hover,
#trahsNote.trashNote:hover{

    height: 16px !important;
    width: 16px !important;
    border: 2px solid red !important;
    background-color: red !important;
    border-radius: 50% !important;
    transition: all 0s !important;

    transform: translate(2px, -2px);

} */



</style>

<script>

var trashIcon = `
<svg id="trashbutton" width="110%" height="110%" viewBox="0 0 166 208" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-326.426,-1615.59)">
        <path d="M485.852,1661.14C485.605,1661.17 485.355,1661.18 485.101,1661.18L335.155,1661.18L348.262,1815.91C348.581,1819.68 351.739,1822.59 355.527,1822.59L465.477,1822.59C469.266,1822.59 472.423,1819.68 472.743,1815.91L485.852,1661.14ZM450.143,1704.86L442.106,1795.83C441.803,1799.26 444.346,1802.3 447.782,1802.6C451.218,1802.9 454.254,1800.36 454.558,1796.92L462.595,1705.96C462.898,1702.52 460.355,1699.49 456.919,1699.18C453.483,1698.88 450.447,1701.42 450.143,1704.86ZM358.017,1705.96L366.054,1796.92C366.358,1800.36 369.394,1802.9 372.83,1802.6C376.266,1802.3 378.809,1799.26 378.506,1795.83L370.469,1704.86C370.165,1701.42 367.129,1698.88 363.693,1699.18C360.257,1699.49 357.714,1702.52 358.017,1705.96ZM389.597,1705.59L392.276,1796.56C392.378,1800.01 395.26,1802.72 398.708,1802.62C402.156,1802.52 404.873,1799.64 404.771,1796.19L402.092,1705.22C401.991,1701.78 399.109,1699.06 395.661,1699.16C392.213,1699.26 389.496,1702.14 389.597,1705.59ZM418.52,1705.22L415.841,1796.19C415.74,1799.64 418.456,1802.52 421.904,1802.62C425.352,1802.72 428.234,1800.01 428.336,1796.56L431.015,1705.59C431.116,1702.14 428.399,1699.26 424.951,1699.16C421.503,1699.06 418.622,1701.78 418.52,1705.22ZM384.347,1628.53L339.471,1628.53C336.877,1628.53 334.477,1629.91 333.171,1632.15L327.417,1642.03C326.103,1644.29 326.095,1647.07 327.396,1649.33C328.696,1651.6 331.107,1652.99 333.718,1652.99L485.101,1652.99C487.711,1652.99 490.122,1651.6 491.423,1649.33C492.724,1647.07 492.715,1644.29 491.401,1642.03L485.648,1632.15C484.341,1629.91 481.942,1628.53 479.347,1628.53L436.657,1628.53C435.606,1625.84 433.63,1623.32 430.704,1621.22C426.134,1617.93 418.817,1615.59 410.502,1615.59C402.188,1615.59 394.871,1617.93 390.3,1621.22C387.375,1623.32 385.399,1625.84 384.347,1628.53Z"/>
    </g>
</svg>
`

var hiddenIcon = `
    <svg class="eyeWithCrossIcon" width="100%" height="100%" viewBox="0 0 191 163" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
       <g transform="matrix(1,0,0,1,-833.494,-1274.88)">
            <path d="M958.327,1311.65L993.025,1277.01C995.873,1274.17 1000.49,1274.17 1003.34,1277.02C1006.18,1279.87 1006.18,1284.49 1003.33,1287.33L855.049,1435.38C852.201,1438.23 847.58,1438.22 844.737,1435.37C841.894,1432.53 841.897,1427.91 844.745,1425.06L872.284,1397.57C856.288,1388.88 843.263,1376.61 834.803,1362.1C833.977,1360.66 833.978,1358.88 834.806,1357.44C851.863,1328.17 887.485,1308.03 928.625,1308.03C938.942,1308.03 948.911,1309.29 958.327,1311.65ZM983.688,1321.29C1000.27,1330.01 1013.76,1342.54 1022.45,1357.44C1023.27,1358.88 1023.27,1360.66 1022.45,1362.1C1005.39,1391.37 969.765,1411.51 928.625,1411.51C917.74,1411.51 907.241,1410.1 897.364,1407.48L910.869,1394C916.185,1396.77 922.224,1398.33 928.625,1398.33C949.907,1398.33 967.184,1381.05 967.184,1359.77C967.184,1353.39 965.632,1347.37 962.882,1342.07L983.688,1321.29ZM954.311,1350.62C955.33,1353.48 955.885,1356.56 955.885,1359.77C955.885,1374.82 943.67,1387.03 928.625,1387.03C925.404,1387.03 922.313,1386.47 919.441,1385.44L954.311,1350.62ZM945.071,1324.89L936.331,1333.62C933.887,1332.9 931.301,1332.51 928.625,1332.51C913.58,1332.51 901.365,1344.73 901.365,1359.77C901.365,1362.43 901.747,1365 902.46,1367.44L893.719,1376.16C891.376,1371.19 890.066,1365.63 890.066,1359.77C890.066,1338.49 907.344,1321.21 928.625,1321.21C934.506,1321.21 940.082,1322.53 945.071,1324.89Z"/>
        </g>
    </svg>
    `
var showIcon = `
    <svg class= "eyeIcon" width="100%" height="100%" viewBox="0 0 191 104" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-833.494,-1154.68)">
            <g transform="matrix(1,0,0,1,0,-153.352)">
                <path d="M834.884,1362.24C834.004,1360.71 834.004,1358.83 834.884,1357.3C851.975,1328.11 887.549,1308.03 928.625,1308.03C969.627,1308.03 1005.15,1328.04 1022.27,1357.14C1023.21,1358.77 1023.21,1360.77 1022.27,1362.4C1005.15,1391.5 969.627,1411.51 928.625,1411.51C887.549,1411.51 851.975,1391.43 834.884,1362.24ZM928.625,1321.21C949.907,1321.21 967.184,1338.49 967.184,1359.77C967.184,1381.05 949.907,1398.33 928.625,1398.33C907.344,1398.33 890.066,1381.05 890.066,1359.77C890.066,1338.49 907.344,1321.21 928.625,1321.21ZM928.625,1332.51C943.67,1332.51 955.885,1344.73 955.885,1359.77C955.885,1374.82 943.67,1387.03 928.625,1387.03C913.58,1387.03 901.365,1374.82 901.365,1359.77C901.365,1344.73 913.58,1332.51 928.625,1332.51Z"/>
            </g>
        </g>
</svg>
    `

let notesDivStart
let notesDivEnd = "</div>"

function collectNotes(wherefrom){
    mylog(" from " + JSON.stringify(collectNotes.caller.name))
    Beat.call("Beat.custom.collectNotes()")
}

function collectReviews(){

    Beat.call("Beat.custom.collectReviews()")
}

function collectReviewsAndThenCreateDoc(){

    Beat.call("Beat.custom.collectReviews(true)")
}

function createDocFromReviews(reviewsData){

    let newDocumentContents = ">Below is a summary of all REVIEW items in the script<\n\n"
        newDocumentContents += ">**" + (documentName?.toUpperCase() || "UNTITLED") +"**<\n"
    let review = 0

    for (element of outline){

        mylog("in da loop!:" + element.line.string)

        if(review >= reviewsData.length) break

        if (outline.indexOf(element) == reviewsData[review].outlineElementNumber){

            let nearestHeading = element
            let nearestHeadingNumber = outline.indexOf(nearestHeading)
                while(nearestHeading.typeAsString != "Heading" && nearestHeading.typeAsString != "Section" && nearestHeadingNumber > 0){nearestHeading = outline[nearestHeadingNumber - 1]}


            newDocumentContents += `\n**-----------------------------------------------------------**\n`
            newDocumentContents += `\n${nearestHeading.line.string} ${(nearestHeading.sceneNumber ? ("#" + nearestHeading.sceneNumber + "#") : "")}\n\n`
        }

        while (outline[reviewsData[review].outlineElementNumber] == element){

            mylog("in da while" + reviewsData[review].string)

            newDocumentContents += "!_*REVIEW #" + review + "*_\n"
            newDocumentContents += "!*(re: " + entireScreenplay.substr(reviewsData[review].range[0], reviewsData[review].range[1]).trim().replaceAll("\n\n", "\n").replaceAll("\n", "*\n*") + ")*\n\n"
            newDocumentContents += `${reviewsData[review].string.trim()}\n`
            
            review++

            if(review >= reviewsData.length) break

            if(reviewsData[review].outlineElementNumber == reviewsData[review - 1].outlineElementNumber){
                newDocumentContents += `\n>------------------------------<\n\n`
            }

        }

        mylog("DONE°°°")
    }


    Beat.call("Beat.newDocument(`" + newDocumentContents + "`)")

}

function displayReviews(reviewsData){

    if(!outline){return} //or else error on plugin startup

    globalReviewsData = reviewsData
    if($id("notepanel")){
        updateNotepanel()
        if(!reviewsAreDisplayed)return
    }

    let existingReviews = $$(".review")
    for (existingReview of existingReviews){
        existingReview.remove()
    }

    // alertThis(JSON.stringify(globalReviewsData))

    for (review of reviewsData){

        text = review.string
        position = review.range[0]
        element = review.outlineElementNumber
        
        let revdiv = document.createElement("div")
            revdiv.id = "review" + reviewsData.indexOf(review)
            revdiv.classList = "review"
            revdiv.style.position = "absolute"
            revdiv.dataset.line = position
            revdiv.dataset.length = review.range[1]
            revdiv.innerHTML = "✓"

            mylog(revdiv.id)
            
        let parentElement = $id(element).closest(".scene, .section")
            if (outline[parentElement.id].typeAsString == "Heading"){
                distance = 100 * (position - outline[parentElement.id].sceneStart) / (outline[parentElement.id].sceneEnd - outline[parentElement.id].sceneStart)
                revdiv.style.top = `calc(${distance}% - 14px)` //the 14px is to align note with speech bubble pointer!
            }else{
                revdiv.style.top = "0%"
            }

        parentElement.appendChild(revdiv)
    }

    mylog("and were done")

}

function highlightReviewInPanel(element){

    if(!element){
        elementsToUnselect = $$(".notepanelReview.isSelected")
        for (el of elementsToUnselect){
            el.classList.remove("isSelected")
        }
        return
    }

    if(!flexiContainer.classList.contains("notepanelIsExpanded"))return

    let elementInPanel = "notepanelR" + element.id.substr(1)
    
    $id(elementInPanel)?.classList.add("isSelected")

}

function displayNotes(notesData, markerData, beatData){
    mylog()

    if(!outline){return} //or else error on plugin startup

    if(notesData){globalNotesData = notesData}
    if(markerData){globalMarkerData = markerData}
    if(beatData){globalBeatData = beatData}

    notesData = globalNotesData
    
    if(markersAreDisplayed){displayMarkers()}
    if(beatsAreDisplayed){displayBeats()}
    if($id("notepanel")?.classList.contains("expanded") && notesData.length > 0){updateNotepanel()}

    if(!notesAreDisplayed)return

    let existingNotes = document.querySelectorAll(".note, .noteContainer")
    if(existingNotes){
        for (existingNote of existingNotes){
            existingNote.remove()
        }
    }

    //Deleted parsing markers because already served in markerData
    // markers = [] //resetting markers every time we re-calculate notes, since markers are just notes

    for (i=0; i<notesData.length; i++){

    //     let tmpString = notesData[i].string.toLowerCase()
    //     if(tmpString.startsWith("[[marker")){
    //         let thisMarker = {}
    //             thisMarker.outlineElementNumber = notesData[i].outlineElementNumber
    //             thisMarker.position = notesData[i].position
    //             // thisMarker.color = notesData[i].string.replace(/(\[|\]|marker\s*)/g, "")
    //             thisMarker.color = tmpString.replace("[[marker ", "").replace("]]", "")
    //             markers.push(thisMarker)
    //         continue
    //     }

        if(!notesAreDisplayed){continue} //because markers are piggybacking on the notes function

        if(!outline[notesData[i].outlineElementNumber]){
            mylog("i is now " + i + "but number of outline elements is: " + outline.length)
            //THIS IS A BUGGY SITUATION THAT SHOULD NOT OCCUR, yet does at times.
            //previously also displayed this:
            //Beat.call("Beat.alert('trying to reference a scene that does not exist!', '"+notesData[i].outlineElementNumber+"')"); break
        }
        mylog("now putting in place note #" + i + "; ")// + outline[notesData[i].outlineElementNumber].string)

        let element = $id(notesData[i].outlineElementNumber) || $(".faux")
        if(!element)return
        
        let thisNote = notesData[i].string.replace(/(\[\[)/, "").replace(/(\]\]$)/, "")
        let notesDivStart = ""
        let notesDivEnd = ""
        let currentContainer = 'noteContainer' + notesData[i].outlineElementNumber
        let parentSize = element.getBoundingClientRect()
        mylog("ok")
            if (element.classList.contains("section")){
                parentSize = element.querySelector(".section-heading")?.getBoundingClientRect()
            }
            if (element.querySelector(".orphanText")){
                parentSize = element.querySelector(".orphanText")?.getBoundingClientRect()
            }

            mylog("ok")

        let howFarBackWasPreviousNonMarker = 1
        while(i > 0 && notesData[i - howFarBackWasPreviousNonMarker].string?.toLowerCase().startsWith("[[marker")){howFarBackWasPreviousNonMarker ++}

        if (i == 0 || i > 0 && notesData[i - howFarBackWasPreviousNonMarker].outlineElementNumber != notesData[i].outlineElementNumber) {
        //if (i == notesData.length - 1 || i < notesData.length - 1 && notesData[i+1].outlineElementNumber != notesData[i].outlineElementNumber) {

            element.innerHTML += "<div id='" + currentContainer + "' class='noteContainer clickThru'>" + "</div>"



            $id(currentContainer).style.top = ((-14 * currentZoomLevel) + "px")// was "0px"

            if ([...element.classList].includes("hideSlugIfSmall") && areScenesProportional == 1) {
                $id(currentContainer).style.top = ((-14 * currentZoomLevel) + "px")
            }
            if (areScenesProportional != 1) {
                $id(currentContainer).style.top = ((-14 * currentZoomLevel) + "px")
                $id(currentContainer).style.float = "none"
            }
            if (element.id.includes("outline") && !element.querySelector(".orphanText")) {
                $id(currentContainer).style.top = ((-1 * parentSize.height + 1) + "px")
                $id(currentContainer).style.marginRight = "4px"
            }

            if (element.id.includes("outline") && element.querySelector(".orphanText")) {
                parentSize = element.querySelector(".orphanText").getBoundingClientRect()
                $id(currentContainer).style.top = ((-1 * parentSize.height + 1) + "px")
                $id(currentContainer).style.maxHeight = (parentSize.height + 14 * currentZoomLevel) + "px"
                // document.getElementById(currentContainer).style.border = "4px lime dotted"
                // alertThis("found one")
            }

        }

        
        let percentageBasedPosition = 0
        if(!element.classList.contains("faux")){
            percentageBasedPosition = Math.max(((notesData[i].position - outline[notesData[i].outlineElementNumber]?.sceneStart) / outline[notesData[i].outlineElementNumber]?.sceneLength) * (parentSize.height - (15 * currentZoomLevel) - 0),0) // the minus 0 used to be -12, now taking full height into use.
        }
mylog("bad yet?")
        if (element.id.includes("outline") && element.querySelector(".orphanText")) {
            let skip = 1
            while(outline[notesData[i].outlineElementNumber + skip]?.typeAsString == "Synopse"){
                skip ++
            }
            percentageBasedPosition = (notesData[i].position - outline[notesData[i].outlineElementNumber]?.sceneStart)/(outline[notesData[i].outlineElementNumber + skip]?.sceneStart - outline[notesData[i].outlineElementNumber]?.sceneStart) * (parentSize.height - (15 * currentZoomLevel) - 0)
        }

        mylog("hanging in?")

        notesDivStart += "<div class='note collapsed' " 
        notesDivStart += "data-line='" + notesData[i].position + "' " 
        notesDivStart += "data-noteNumber='" + i + "' "
        notesDivStart += "id='noteNumber" + i + "' "
        notesDivStart += "onmouseenter='expandNote()' " 
        notesDivStart += "onmouseleave='collapseNote()'"
        if (areScenesProportional == 1 && !(element.id.includes("outline") && !element.querySelector(".orphanText")))  {
            notesDivStart += "style='top: " + percentageBasedPosition + "px' " 
        }
        notesDivStart += ">"

        notesDivEnd += "</div>"

        $id(currentContainer).innerHTML += notesDivStart + thisNote + notesDivEnd
        if (thisNote.startsWith("!")){$("[data-noteNumber = '" + i + "']").style.backgroundColor = "red"}
        if (thisNote.startsWith("!!")){$("[data-noteNumber = '" + i + "']").style.backgroundColor = "magenta"}
        if (thisNote.startsWith("!!!")){$("[data-noteNumber = '" + i + "']").style.backgroundColor = "#8000FF"}
        if (thisNote.startsWith("?")){$("[data-noteNumber = '" + i + "']").style.backgroundColor = "lime"}

        mylog("end of Note Loop")
    }

  mylog("end of collect and displayNotes()")
}

function createDocFromNotes(){

if(!globalNotesData)collectNotes()

let newDocumentContents = ">Below is a summary of all NOTES in the script<\n\n"
    newDocumentContents += ">**" + (documentName?.toUpperCase() || "UNTITLED") +"**<\n"
let note = 0

for (element of outline){

    mylog("in da loop!:" + element.line.string)

    if(note >= globalNotesData.length) break

    if (outline.indexOf(element) == globalNotesData[note].outlineElementNumber){

        let nearestHeading = element
        let nearestHeadingNumber = outline.indexOf(nearestHeading)
            while(nearestHeading.typeAsString != "Heading" && nearestHeading.typeAsString != "Section" && nearestHeadingNumber > 0){nearestHeading = outline[nearestHeadingNumber - 1]}

        newDocumentContents += `\n**-----------------------------------------------------------**\n`
        newDocumentContents += `\n${nearestHeading.line.string} ${(nearestHeading.sceneNumber ? ("#" + nearestHeading.sceneNumber + "#") : "")}\n\n`
    }

    while (outline[globalNotesData[note].outlineElementNumber] == element){

        mylog("in da while" + globalNotesData[note].string)

        // newDocumentContents += "*re: " + entireScreenplay.substr(globalNotesData[note].range[0], globalNotesData[note].range[1]).trim().replaceAll("\n", "*\n*") + "*\n\n"
        newDocumentContents += `${globalNotesData[note].string.replace("[[", "").replace("]]", "").replace("<br/>", "\n").replace(/^!+|^\?+/, "").trim()}\n`
        
        note++

        if(note >= globalNotesData.length) break

        if(globalNotesData[note].outlineElementNumber == globalNotesData[note - 1].outlineElementNumber){
            newDocumentContents += `\n>------------------------------<\n\n`
        }

    }

    mylog("DONE°°°")
}


Beat.call("Beat.newDocument(`" + newDocumentContents + "`)")

}

function displayMarkers(){

    if (globalMarkerData.length < 1){return}

    let currentMarkers = $$(".marker")
        for (currentMarker of currentMarkers){currentMarker.remove()}

    mylog()


    for (let im = 0; im < globalMarkerData.length; im++){

        let element = $id(globalMarkerData[im].outlineElementNumber) || $(".faux")
        if(!element)return

        theMarkerToAddAsCode = "<div id = 'marker" + im + 
                    //"' data-content = '" + globalMarkerData[im].story + //this is to make :after border equally wide as parent
                    "' class = 'marker' data-line = '" + globalMarkerData[im].position + 
                    "'><div class='markertext'>" + (globalMarkerData[im].story || "") + "</div></div>" 
                    // "'><div class='markertext'>" + (globalMarkerData[im].position || "") + "</div></div>" 
        element.innerHTML += theMarkerToAddAsCode
        

        // theMarkerToAdd = document.createElement("div")
        // theMarkerToAdd.id = "marker" + i
        // theMarkerToAdd.classList.add("marker")
        // theMarkerToAdd.dataset.line = markers[i].position

        //theMarkerToAdd.onmouseover = function(){element.parentNode.classList.add("noHover")}
        //theMarkerToAdd.onmouseout = function(){element.parentNode.classList.remove("noHover")}

        theMarkerToAdd = $id("marker" +  im)

        if (globalMarkerData[im].color && globalMarkerData[im].color != ""){
            // theMarkerToAdd.style.borderRightColor = globalMarkerData[im].color
            // theMarkerToAdd.style.borderTopColor = globalMarkerData[im].color
            // theMarkerToAdd.style.borderBottomColor = globalMarkerData[im].color
            theMarkerToAdd.style.backgroundColor = globalMarkerData[im].color
        }

        let markerColor = window.getComputedStyle(theMarkerToAdd).backgroundColor //will be rgb
        theMarkerToAdd.style.color = blackOrWhite(markerColor) || "red"
        
        // let markerVerticalPosition = -2
        let markerVerticalPosition = 1 // default position only affects Section, that has no orphan.

        mylog("ASfasfasdf")

        if((outline[globalMarkerData[im].outlineElementNumber]?.typeAsString != "Section"
            ||
            outline[globalMarkerData[im].outlineElementNumber]?.numberOfPages > 0)
             && areScenesProportional == 1){
            markerVerticalPosition = globalMarkerData[im].position - outline[globalMarkerData[im].outlineElementNumber]?.line.position
            let percentageIntoScene = markerVerticalPosition / outline[globalMarkerData[im].outlineElementNumber]?.sceneLength

            if(outline[globalMarkerData[im].outlineElementNumber]?.typeAsString == "Section"){
                element = element.querySelector(".orphanText")
            }

            markerVerticalPosition = percentageIntoScene * (Number(element.getBoundingClientRect().height) - 12) //-14 is to fit entire marker inside
            
        }
        
        theMarkerToAdd.style.top = markerVerticalPosition + "px"
        
        //element.appendChild(theMarkerToAdd)
        
    }
    
    mylog("done in display marker territory")// at " + displayEnd + "(took " + (displayEnd-displayStart) + " ms)")
}

function displayBeats(){
   
    if (globalBeatData.length < 1){return}

    let currentBeats = $$(".beat")
        for (currentBeat of currentBeats){currentBeat.remove()}
    let currentPaths = $$(".svgForBeats")
        for (currentPath of currentPaths){currentPath.remove()}
    let widthOfColumns = $(".section").getBoundingClientRect().width || $(".sceneheading").getBoundingClientRect().width

    mylog()

    //first lets make one SVG "canvas" the size of the flexiContainer
        let canvasSize = $id("flexiContainer").getBoundingClientRect()
        $id("flexiContainer").innerHTML += "<svg id='theCanvas' class='svgForBeats'></svg>"
        $id("theCanvas").style.position = "absolute"
        $id("theCanvas").style.left = canvasSize.left + "px"
        $id("theCanvas").style.top = canvasSize.top + "px"
        $id("theCanvas").style.width = canvasSize.width + "px"
        $id("theCanvas").style.height = canvasSize.height + "px"
        //$id("theCanvas").style.background = "rgba(255,255,255,0.1)"

        mylog("there is now an SVG canvas")

    for (let im = 0; im < globalBeatData.length; im++){

        //set element to parent where we will put the beat
        let element = $id(globalBeatData[im].outlineElementNumber) || $(".faux")
        if(!element)return

        theBeatToAddAsCode = "<div id = 'beat" + im + "' class='beat' data-storyline='" + globalBeatData[im].storyline + "' data-line='" + globalBeatData[im].position + "'>" + globalBeatData[im].story + "</div>" 
        element.innerHTML += theBeatToAddAsCode

        theBeatToAdd = $id("beat" +  im)

        theBeatToAdd.style.background = storyColors[globalBeatData[im].storyline - 1]
        theBeatToAdd.style.left = (5 + (globalBeatData[im].storyline - 1) * 15) + "%"
        //theBeatToAdd.style.opacity = "0"
    
        let beatVerticalPosition = -2

        if((outline[globalBeatData[im].outlineElementNumber]?.typeAsString != "Section" 
            ||
            outline[globalBeatData[im].outlineElementNumber]?.numberOfPages > 0)
            && areScenesProportional == 1){
            beatVerticalPosition = globalBeatData[im].position - outline[globalBeatData[im].outlineElementNumber]?.line.position
            let percentageIntoScene = beatVerticalPosition / outline[globalBeatData[im].outlineElementNumber]?.sceneLength

            if(outline[globalBeatData[im].outlineElementNumber]?.typeAsString == "Section"){
                element = element.querySelector(".orphanText")
            }

            beatVerticalPosition = percentageIntoScene * (Number(element.getBoundingClientRect().height) - 12) //-14 is to fit entire beat inside
        
        }
    
        theBeatToAdd.style.top = beatVerticalPosition + "px"

        mylog("done adding beat #" + im)
    
        //add the connecting lines


        //first let's find the previous beat of this storyline (if present)
        let prev
        for(prev = im - 1; prev > -1; prev --){
            if (globalBeatData[prev].storyline == globalBeatData[im].storyline){
                break
            }
        }
        // now if such previous beat is indeed present, then draw the line
        if (prev > -1){

            mylog(prev + " " + im)
  
            let start = $id("beat" + prev).getBoundingClientRect()
            let end = $id("beat" + im).getBoundingClientRect()

            let theWidth = start.right - start.left 
            let theHeight = start.bottom - start.top
            let midX = start.left + (end.left - start.left)/2 + theWidth/2
            let midY = start.top + (end.top - start.top)/2 + theHeight/2
            
            let xCorrector = widthOfColumns/2
            //if (start.left == end.left){xCorrector = 0}
            let yCorrector = 50 //widthOfColumns 
            //if (start.left != end.left){yCorrector = widthOfColumns}
            
            // yCorrector = 200

            
            let currentStoryline = globalBeatData[im].storyline
            let thePathID = "path" + im
            let thePathToAdd = `<path class="allpaths hiddenPath pathOf` + currentStoryline + `" id='` + thePathID + `' D='
            M ` + (start.left + theWidth/2) + ` ` + 
                  (start.top + theHeight/2) + `
            C ` + (start.left + theWidth/2 + xCorrector) + ` ` + 
                  (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (end.left + theWidth/2 - xCorrector) + ` ` + (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2) + ` ` + (end.top + theHeight/2) + 
            ` ' fill = "none"/>`

            $id("theCanvas").innerHTML += thePathToAdd
   
        }

        //now actually make a duplicate of the last beat, and put it on top!
            let copyOf = theBeatToAdd.cloneNode(true)
            let rect = theBeatToAdd.getBoundingClientRect()
            copyOf.style.position = "absolute"
            copyOf.style.left = rect.left + "px"
            copyOf.style.top = rect.top + "px"
            copyOf.style.opacity = "1"
            copyOf.id = copyOf.id + "(copy)"
            copyOf.borderColor = storyColors[globalBeatData[im].storyline - 1] + " !important"
            copyOf.classList.add("copy", "hiddenBeat")
            $("#flexiContainer").appendChild(copyOf)
        
    }

mylog("exiting")
}

function beatIsHovered(element){

    mylog()

    //first make sure the canvas is the same size as the flexiContainer!
    let flexiSize = $id("flexiContainer").getBoundingClientRect()
        $id("theCanvas").style.width = flexiSize.width
        $id("theCanvas").style.left = flexiSize.left

    let theHoveredStoryline = element.getAttribute("data-storyline")
    //element.id.replace("beat", "").replace("(copy)", "")
    aBeatIsHovered = true

    let allpaths = $$(".allpaths")
    let thePathsToShow = $$(".pathOf" + theHoveredStoryline)
    let beatsOnTop = $$(".beat.copy")

    for (let path of allpaths){
        path.classList.add("hiddenPath")
    }
    for (let path of thePathsToShow){
        path.classList.remove("hiddenPath")
    }
    for (let beat of beatsOnTop){
        if(beat.getAttribute("data-storyline") == theHoveredStoryline){ 
            beat.classList.remove("hiddenBeat")
            beat.classList.add("largerBeat")
        }else{
            beat.classList.add("hiddenBeat")
            beat.classList.remove("largerBeat")
        }
    }
}

function unhoverAllBeats() {

    aBeatIsHovered = false

    let allpaths = $$(".allpaths")
    for (let path of allpaths){
        path.classList.add("hiddenPath")
    }

    let beatsOnTop = $$(".beat.copy")
    for (let beat of beatsOnTop){   
        beat.classList.add("hiddenBeat")
        beat.classList.remove("largerBeat") 
    }
}

function expandNote(tabWasPressed){

    if(!globalNotesData || globalNotesData.length == 0){return}
    if($("#editBox"))return
    exitEdit()
    
    if (selectedNote > -1 && tabWasPressed){ //SELECTED THROUGH TAB
        theNote = $("[data-noteNumber='" + selectedNote + "']")
        
        if(isThisOffScreen(theNote)){
            scrollNicelyIntoView(theNote) 
        }
    }

    if ([...event.target.classList].includes("note") && ($id('trashNote'))) { //allow hover others when in tab-cycling
        return
    }

    if ([...event.target.classList].includes("note") && (!tabWasPressed)) { //SELECTED BY HOVERING
        collapseNote()
        theNote = event.target
        selectedNote = theNote.getAttribute("data-noteNumber")

        // To prevent blinkage (and remove hover effect from parents when hovering note)
        let bubbleProhibitor = theNote
        while (bubbleProhibitor.parentNode && bubbleProhibitor.parentNode.id != "flexiContainer"){
            bubbleProhibitor = bubbleProhibitor.parentNode
            bubbleProhibitor.classList.add("noHover")
            mylog("ADDED noHover to " + bubbleProhibitor.id)
        }
    }

    mylog("immedeiately after added NoHover...")

    //add .isSelected to notePanel, to show hovered note in panel if open
    if($("#notepanel")){
        selectedNote = theNote.getAttribute("data-noteNumber")
        $id("notepanelNote" + selectedNote)?.classList.add("isSelected")
        $id("notepanelNote" + selectedNote)?.firstChild.classList.add("isSelected")
    }

    mylog("before note to unselect")


    let noteToUnselect = $('.selectedNote')
    if (noteToUnselect) {
        noteToUnselect.classList.remove('selectedNote')
    }
    theNote.classList.add('selectedNote')

    let theNoteString = theNote.innerHTML
    let expandedClassList = "expandedNote" //only to be able to blink in its color
    let position = theNote.getBoundingClientRect()
    let sizeOfFlexi = $id("flexiContainer").getBoundingClientRect()
    
    if (position.top == 0 && position.left == 0) { 
        position = theNote.closest(".section").getBoundingClientRect()
        expandedClassList += "omittedNote "}
    let y = parseInt(JSON.stringify(position.top - sizeOfFlexi.top))
    let x = parseInt(JSON.stringify(position.left - sizeOfFlexi.left))
    // let y = position.top
    // let x = position.left
    let yOrigo = document.getElementById('flexiContainer').scrollTop

    // let theFirstOutlineItemWidth = $id("0").getBoundingClientRect()
    let theFirstOutlineItemWidth = $(".section:not(.faux), .scene")?.getBoundingClientRect()

    let expandedWidth = Math.min(theFirstOutlineItemWidth.width, window.innerWidth/2)
    
    let sceneText = "in scene " + outline[theNote.closest(".scene")?.id]?.sceneNumber
    if (!theNote.closest(".scene")){
        let a = theNote.closest(".section")?.querySelector(".section-heading")?.innerHTML
        sceneText = a? ('in section ' + theNote.closest(".section")?.querySelector(".section-heading")?.innerHTML) : "before first section"
    }

    let trashDiv = ""
    if (tabWasPressed) {trashDiv = "<div id='trashNote' class='trashNote'>" + trashIcon + "</div>"}

    $id('flexiContainer').innerHTML += 
        "<div id='expandedNote' class='" + expandedClassList + "'>" +
        "<b class='clickThru padRight'>" +
        trashDiv +
        "Note " + sceneText + " </b>" +
        "<text class='clickThru' id='expandedNoteText'>" + theNoteString + "</text></div>"

    let theExpandedNote = document.getElementById('expandedNote')
    let currentIndex = theNote.getAttribute("data-line")
    mylog(currentIndex)
    theExpandedNote.setAttribute("data-line", currentIndex)
    theExpandedNote.style.width = expandedWidth + "px"        

    let sizeOfExpandedNote = theExpandedNote.getBoundingClientRect()

    let xPos = Math.min((x + 7.5 - expandedWidth/2), (sizeOfFlexi.width - expandedWidth - 40))
    let yPos = yOrigo + y + 25
    xPos = Math.max(xPos, 20)
    yPos = Math.max(yPos, 20)
    if (xPos + sizeOfExpandedNote.width > sizeOfFlexi.width - 40) {xPos = sizeOfFlexi.width - sizeOfExpandedNote.height - 40}
    if (yPos + sizeOfExpandedNote.height > document.getElementById('flexiContainer').scrollHeight - 40) {yPos = yOrigo + y - 10 - sizeOfExpandedNote.height}

    theExpandedNote.style.top = yPos + "px"
    theExpandedNote.style.left = xPos + "px"

    //added to fix color if ! or ? in text:
        if (theNoteString.startsWith("!"))  {theExpandedNote.style.backgroundColor = "#FF8888"}//"red"}
        if (theNoteString.startsWith("!!")) {theExpandedNote.style.backgroundColor = "#FF88FF"}//"magenta"}
        if (theNoteString.startsWith("!!!")){theExpandedNote.style.backgroundColor = "#9088FF"}//"#8000FF"}
        if (theNoteString.startsWith("?"))  {theExpandedNote.style.backgroundColor = "#88FF88"}//"lime"}

}

function collapseNote(){

    mylog(event.type)

        //remove .isSelected from notePanel, to show hovred note in panel if open
        if($("#notepanel")){
            $id("notepanelNote" + selectedNote)?.classList.remove("isSelected")
            $id("notepanelNote" + selectedNote)?.firstChild.classList.remove("isSelected")
        }

    if (event.type == "mouseleave" && (document.getElementById('trashNote'))) { //allow hover others when in tab-cycling
        return
    }

    if (document.getElementById('expandedNote')){
    document.getElementById('expandedNote').remove()

    let makeRehoverable = document.querySelectorAll('.noHover')
    for (i = makeRehoverable.length -1; i > -1; i-- ){
        makeRehoverable[i].classList.remove('noHover')
    }

    let noteToUnselect = document.querySelector('.selectedNote')
    if (noteToUnselect) {noteToUnselect.classList.remove('selectedNote')}
    }
}

function expandReview(theClickedThing){

    reviewNumber = theClickedThing?.id.replace("review", "")

    collapseReviews()
    
    if(!theClickedThing)return
    mylog("hej, nummer" + reviewNumber)

    expandedReview = $id("review"+reviewNumber)
    mylog(expandedReview)
    expandedReview.classList.add("expandedReview")
    // setTimeout(() => {
        expandedReview.innerHTML = "<div class='reviewHeadline'>REVIEW #" + reviewNumber + "</div>"
        expandedReview.innerHTML += globalReviewsData[reviewNumber].string
    // }, 0.05);

    $id("notepanelReview" + reviewNumber)?.classList.add("isSelected")

}

function collapseReviews(){

    let expandedReviews = $$(".expandedReview")
    for (expandedReview of expandedReviews){
        expandedReview.classList.remove("expandedReview")
        expandedReview.innerHTML = "✓"
    }
    
    $(".notepanelReview.isSelected")?.classList.remove("isSelected")

}

function cycleNotes(shift){

    mylog("cycleNotes")
      
    if(!notesAreDisplayed && !reviewsAreDisplayed){
        toggleDisplayNotes()
        return
    }

    

    // if(!globalNotesData)collectNotes()
    // if(!globalReviewsData)collectReviews()

    let cyclables = []
    if (notesAreDisplayed && globalNotesData) cyclables = cyclables.concat(globalNotesData)
    if (reviewsAreDisplayed && globalReviewsData) cyclables = cyclables.concat(globalReviewsData)

    if (cyclables.length == 0)return

    if (notesAreDisplayed && reviewsAreDisplayed){
                cyclables.sort((a,b) => (a.position > b.position) ? 1 : ((b.position > a.position) ? -1 : 0))
    }

    //convoluted way to set "cycle" to currently open note or review
    let cycle = -1
        if($(".expandedNote")){
            cycle = cyclables.indexOf(globalNotesData[selectedNote])
        }
        if($(".expandedReview")){
            cycle = cyclables.indexOf(globalReviewsData[$(".expandedReview").id.replace("review", "")])
        }

    // alertThis(JSON.stringify(cyclables))

    
    // //IF a hovered note is open, tab solidifies that note (=trashnote on) instead of opening next
    // if (document.getElementById('expandedNote') && !document.getElementById('trashNote')){
    //     selectedNote = shift ? (selectedNote + 1) : (selectedNote - 1)
    // }
    
    
    if ($id('expandedNote')){
        collapseNote()
    }
    if ($('.expandedReview')){
        collapseReviews()
    }
    
    if (!shift){
        //selectedNote ++
        cycle ++
    } else {
        //selectedNote --
        cycle --
    }
    
    // if (selectedNote > document.querySelectorAll(".note").length-1) {selectedNote = 0}
    // if (selectedNote < 0) {selectedNote = document.querySelectorAll(".note").length-1}
    if (cycle > cyclables.length-1) {cycle = 0}
    if (cycle < 0) {cycle = cyclables.length-1}

    mylog(cycle + ", " + cyclables.length)
        
    if(cyclables[cycle].string.startsWith("[[")) {
        selectedNote = globalNotesData.indexOf(cyclables[cycle])
        expandNote(true)
    }else{
        expandReview($id("review" + globalReviewsData.indexOf(cyclables[cycle])))
    }

    let cycledElement = $("#expandedNote, .expandedReview")
    if(isThisOffScreen(cycledElement)){

        scrollNicelyIntoView(cycledElement)

    }
    
}

function AlternateWayToCalculateCurve(){

    let currentStoryline = globalBeatData[im].storyline
            let thePathID = "path" + im
            let thePathToAdd = `<path class="allpaths hiddenPath pathOf` + currentStoryline + `" id='` + thePathID + `' D='
            M ` + (start.left + theWidth/2) + ` ` + 
                  (start.top + theHeight/2) + `
            C ` + (start.left + theWidth/2 + xCorrector) + ` ` + 
                  (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (midX) + ` ` + (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (midX) + ` ` + (midY) + `  
            C ` + (midX) + ` `+ (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2 - xCorrector) + ` ` + (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2) + ` ` + (end.top + theHeight/2) + 
            ` ' fill = "none"/>`

            $id("theCanvas").innerHTML += thePathToAdd

}

function collectRevisionIndices(){

    if (!documentSetting.showRevisions)return

mylog("======")
mylog("======")
mylog("======")
mylog("======")
mylog("======")
mylog("======")

    Beat.call(`Beat.custom.collectRevisionsInPlugin()`)

}

function paintRevisions(changedAsJSON, reviewAsJSON){

    // //if (alreadyRunningPainting)return
    // alreadyRunningPainting = true

    let changedObject = JSON.parse(changedAsJSON)
    let reviewObject = JSON.parse(reviewAsJSON)

    let currentDivs = $$(".revision")
    if(currentDivs.length > 0){
        currentDivs.forEach(element => {
            element.remove()
        });
    }

    for (line of reviewObject.Addition){
        
        mylog(line)
    
        let changeStart = line[0]
        let changeLength = line[1]
        let changeColor = line[2]

        let outlineNumber

        for (let i = 0; i < outline.length - 1; i++) {
            // mylog(outline[i].sceneStart)
            outlineNumber = -1000
            if (outline[i]?.sceneStart > changeStart) {
                    outlineNumber = i - 1
                    while(outline[outlineNumber]?.typeAsString == "Synopse"){outlineNumber --}
                    // mylog("found: " + outlineNumber)
                break}
        }

        if(outlineNumber < -999){
            mylog("no outline")
            outlineNumber = outline.length - 1}

        let revisionDiv = document.createElement("div")
            revisionDiv.id = "revisionAtIndex" + changeStart

        let changeStartPercent = 100 * (changeStart - outline[outlineNumber]?.sceneStart) / (outline[outlineNumber]?.range.length)
        let changeEndPercent = 100 * changeLength / (outline[outlineNumber]?.range.length)

        // now no more reading values, so lets rename outlineNumber
        if(outline[outlineNumber]?.typeAsString == "Section"){
                outlineNumber = "orphanInside" + outlineNumber
            }
            
            revisionDiv.style.position = "absolute"
            revisionDiv.style.top = changeStartPercent + "%"
            revisionDiv.style.height = changeEndPercent + "%"

            // revisionDiv.style.backgroundColor = changeColor
            revisionDiv.classList.add("revision")
            revisionDiv.classList.add(changeColor)
            // revisionDiv.style.width = "120%"
            // revisionDiv.style.left = "-10%"
            revisionDiv.dataset.line = changeStart
            revisionDiv.dataset.length = changeLength

            if($id(outlineNumber))$id(outlineNumber).appendChild(revisionDiv)
    
    }

    // alreadyRunningPainting = false

}


</script>

<style>
    
    .revision{
        
        /* opacity: 40%; */
        
        border-width: .5px;
        border-style: solid;
        border-radius: 2px;

        width: calc(100% + 20px);
        left: -10px;

        opacity: 0.5

    }
    
    .revision.blue{
        background-color: rgba(51, 129, 239, 0.66);
        border-color: rgba(51, 129, 239, 1);
    }
    .revision.orange{
        background-color: rgba(250, 161, 15, 0.66);
        border-color: rgba(250, 161, 15, 1)
    }
    .revision.purple{
        background-color: rgba(181, 33, 218, 0.66);
        border-color: rgba(181, 33, 218, 1)
    }
    .revision.green{
        background-color: rgba(32, 223, 121,0.66);
        border-color: rgba(32, 223, 121, 1)
    }

    .revision:hover{
        opacity: 1;
    }

    thisIsTurnedOff.revision::before{
        content: "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *";

        position: absolute;
        top: 1px !important;
        right: 2px !important;
        width: calc(0.04px * var(--heightFactor)) !important;
        height: calc(100% - 1px) !important;
        
        overflow: hidden !important;
        font-size: calc(0.08px * var(--heightFactor));
        line-height: calc(0.08px * var(--heightFactor));

        /* outline: 1px solid lime */
    }

    .review{

        height: 12px;
        width: 18px;
        background-color: #ffe575;
        border: 1px solid hsl(49, 37%, 16%);
        border-radius: 4px;
        color: #7f723a;

        right: -12px; 

        text-align: center;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: 8px;
        font-weight: bold;
        line-height: 10px;

        z-index: 999;

        pointer-events: all;
    }

    .review.expandedReview{

        /* overflow: hidden; */
        white-space: pre-wrap !important;
        word-wrap: break-word;

        right: 8px;

        height: auto !important;
        width: auto !important;
        max-width: 80% !important;
        min-width: 50% !important;
        padding: 18px 12px 40px 12px; /*was 8 for top*/

        font-size: 11px;
        line-height: 14px;
        font-weight: normal;
        text-align: left;
        color: black;

        border-radius: 10px;
        border-color: #7f723a;

        /* transition: 0.05s; */

        z-index: 9999;

        box-shadow: 3px 3px 12px rgba(0,0,0,0.4);

        translate: 0 -6px;

    }

    .review > .reviewHeadline{

        position: absolute;
        top: 0;
        left: -1px;
        padding: 0px 12px 0px 12px;
        background-color: #7f723a;
        color: #ffe575;

        border-radius: 10px 10px 0 0 ;

        font-weight: bold;
        font-size: 8px;
        width: calc(100% + 2px);

    }

    .review::after{

        position: absolute;
        bottom: -3px;
        left: 3px;

        content: " ";
        
        border: 4px solid transparent;
        border-top: 0px solid transparent;
        border-left: 4px solid #ffe575;

    }

    .review.expandedReview::after{

        width: 0px;
        height: 0px;

        border-right: 0px;
        border-top: 4px transparent solid;
        border-bottom: 4px transparent solid;
        border-left: 8px solid #ffe575;

        /* border-color: lime !important; */

        top: 16px; /*was 10*/
        left: unset;
        right: -6.44px !important;

    }

    .review::before{

        position: absolute;
        bottom: -5.44px;
        left: 2px;

        content: " ";

        border: 5.44px solid transparent;
        border-top: 0px solid transparent;
        border-left: 5.44px solid hsl(49, 37%, 16%);

    }

    .review.expandedReview::before{

        width: 0px;
        height: 0px;

        border-right: 0px;
        border-top: 5px transparent solid;
        border-bottom: 5px transparent solid;
        border-left: 8px solid #7f723a;

        /* border-color: lime !important; */

        top: 15px; /*was 9*/
        left: unset;
        right: -8px !important;

    }

    .review.selectedNote,
    .review:hover {

        background: hsl(49, 37%, 16%) !important;
        border-color: black;

    }

    .review:hover::before,
    .review.selectedNote::before {
        border-color: transparent !important;
        border-left-color: black !important;
        background: transparent !important;
    }

    .review:hover::after,
    .review.selectedNote::after {
        border-color: transparent !important;
        border-left-color: hsl(49, 37%, 16%) !important;
        background: transparent !important;
    }

</style>
