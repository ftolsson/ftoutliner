/*

Plugin name: FTOutliner
Description: A Flexible Time Outliner for navigating, structuring and editing your screenplay.
Copyright: Fredrik T Olsson 2021-2022
Version: 1.53
Compatibility: 1.977
Type: Tool
Image: screenshot.jpg

<Description>
<style>
a {	
	color: #7ca1e6 !important;
	font-weight: bold !important;
}
</style>
<p>A <b>Flexible Time Outliner</b> for navigating, structuring and editing your screenplay.</p>
<ul>
	<li>Scenes arranged per #act and displayed proportionally to their length in the script</li>
	<li>Notes and markers displayed right in their corresponding place in the outline</li>
	<li>Color, hide or delete scenes via right click context menu</li>
	<li>Drag-and-drop to rearrange scenes or entire sequences</li>
	<li>Track characters by highlighting scenes, or isolate scenes of certain color</li>
	<li>Print your outline (or export to PDF)
	<li>Fully editable index card view
	<li>Slide-over Note Panel with all notes in one list
	<li>Boneyard (for storing scenes outside of the script structure)
	<li>and lots more...
</ul>
<p>For more info, questions or support visit <a href="https://github.com/ftolsson/ftoutliner/wiki" target="_default">the FTOutliner wiki</a></p>
</Description>

*/ 

// Beat.openConsole()

if (!Beat.compatibleWith(1.977)){

	Beat.alert("You need to update Beat to run FTOutliner",
		"This version of FTOutliner uses new features introduced in Beat 1.977 and will not run with older versions.\n\nPlease visit Apple's AppStore to update.")
	return
}

var backgroundAlreadyRunning = false
var queueOneMoreFullUpdate = false

var reset = Beat.assetAsString("reset.css")
var css = Beat.assetAsString("outline.css")
var globals = Beat.assetAsString("globals.html")
var template = Beat.assetAsString("outline.html")
var dnd = Beat.assetAsString("drag-and-drop.html")
var dialogs = Beat.assetAsString("dialogs.html")
var charactertracking = Beat.assetAsString("charactertracking.html")
var displaynotes = Beat.assetAsString("displaynotes.html")
var contextmenu = Beat.assetAsString("contextmenu.html")
var editcontent = Beat.assetAsString("editcontent.html")
var addelements = Beat.assetAsString("addelements.html")
var printCSS = Beat.assetAsString("printOutlineCSS.css")
var indexcards = Beat.assetAsString("indexCards.html")
var indexcards_css = Beat.assetAsString("indexCards.css")
var notepanel = Beat.assetAsString("notepanel.html")
var menu = Beat.assetAsString("menu.html")
var printing = Beat.assetAsString("printing.html")
var thePanelWidth, thePanelHeight, thePanelX, thePanelY
// var storingDefaultsHTML = makeStoringDefaultsDiv()
var allDefaultsHTML = makeStoringDefaultsDiv()
var location, length
var html

var fullUpdateInProgress = false
var smallUpdateInProgress = false

var	html = //storingDefaultsHTML +
	reset +
	css +
	globals +
	allDefaultsHTML +
	// dialogs +
	charactertracking +
	displaynotes +
	contextmenu + 
	indexcards +
	indexcards_css +
	notepanel +
	menu +
	dialogs + //changed
	printing +
	editcontent +
	addelements +
	dnd +
	template

var charactersArray, scenesWithCharactersArray
var hackyAbsoluteHeightOfLine = 0 // 0.07195301353931427/2 // VERY HACKY: THIS IS TO ADD ONE EXTRA LINE AT TIMES

var startTime
var midTime1, midTime2, midTime3
var endTime
var endTimes =  []
var dispatchTimes = []
var paginateStartTime, paginateEndTime, timeSpentPaginatingLines = 0
var runCounter = 0
var runCounterText = 0

var fullTimer = false
var selectionTimer = null

var documentName, documentSubName, documentAuthor

var reallyDelete
var windowTitle = "FTOutliner"

var outlineJustFired

var htmlWindow = Beat.htmlWindow(html, thePanelWidth, thePanelHeight, function(){Beat.end()});
	htmlWindow.setFrame(thePanelX, thePanelY, Math.max(thePanelWidth, 380), thePanelHeight) 

// fetchDocumentTitles()
loopToFetchDocumentTitles()
setWindowTitle()

// =======================
// END OF GLOBAL VARIABLES
// =======================

Beat.custom = {};

Beat.custom.reloadCode = function(){

	Beat.restart()

}

Beat.custom.reloadHTML = function(){

	reset = Beat.assetAsString("reset.css")
	css = Beat.assetAsString("outline.css")
	globals = Beat.assetAsString("globals.html")
	template = Beat.assetAsString("outline.html")
	dnd = Beat.assetAsString("drag-and-drop.html")
	dialogs = Beat.assetAsString("dialogs.html")
	charactertracking = Beat.assetAsString("charactertracking.html")
	displaynotes = Beat.assetAsString("displaynotes.html")
	contextmenu = Beat.assetAsString("contextmenu.html")
	editcontent = Beat.assetAsString("editcontent.html")
	addelements = Beat.assetAsString("addelements.html")
	printCSS = Beat.assetAsString("printOutlineCSS.css")
	indexcards = Beat.assetAsString("indexCards.html")
	indexcards_css = Beat.assetAsString("indexCards.css")
	notepanel = Beat.assetAsString("notepanel.html")
	menu = Beat.assetAsString("menu.html")
	printing = Beat.assetAsString("printing.html")

 	//storingDefaultsHTML = makeStoringDefaultsDiv()
	allDefaultsHTML = makeStoringDefaultsDiv()


	html = //storingDefaultsHTML +
	reset +
	css +
	globals +
	allDefaultsHTML +
	// dialogs +
	charactertracking +
	displaynotes +
	contextmenu + 
	indexcards +
	indexcards_css +
	notepanel +
	menu +
	dialogs + //changed
	printing +
	editcontent +
	addelements +
	dnd +
	template

	htmlWindow.setHTML(html)
	htmlWindow.setFrame(thePanelX, thePanelY, Math.max(thePanelWidth, 380), thePanelHeight) 
}

Beat.onOutlineChange (function() { 
	//Beat.log("FIRED: onOutlineChange")
	
	outlineJustFired = true
	let jsToRun = `startFullUpdate()`	
	htmlWindow.runJS(jsToRun)

			// PLUGIN: onOutlineChange (THIS FUNCTION) will call...
			// HTMLWINDOW: startFullUpdate, which will call...
			// PLUGIN: beat.custom.updateEntireOutline, 
			//         makeJSON, then
			//         paginateThis, which returns to updateEntireOutline, which will call...
			// HTMLWINDOW: updateEverything

})

Beat.custom.updateEntireOutline = function (location, length, previousOutlineLength) {
	//Beat.log("================ Update Entire Outline. Location is: " + location)

	startTime = new Date()

	if (backgroundAlreadyRunning){
		//Beat.log("          stopped because background already running! ")
		return}

	fullUpdateInProgress = true		
	let jsToRun = `
		document.getElementById('outOfSyncDiv').style.display = 'block';
		document.getElementById('outOfSyncDiv').classList.add('animate');
		document.getElementById('flexiContainer').classList.add('wait');
		`
		htmlWindow.runJS(jsToRun)

	//Beat.log("location in EntireOutline is: " + location)

	if(!location){
		location = Beat.selectedRange().location
	}
	
	let outlineElements = [...Beat.outline()]
	const paginator = Beat.paginator()
		midTime1 = new Date()

	// let json = makeJSON() //moved down
		midTime2 = new Date()


	Beat.dispatch(function(){
		Beat.log("          Now entering dispatch")

		backgroundAlreadyRunning = true

		let pagesForElements = []
		let pageBreakPositions = []
		let pages
		let pageBreaks

		// let location = Beat.selectedRange().location
		// if (location && Beat.currentParser.lineAtPosition(location).typeAsString() != "Synopse"){
			
		// 	Beat.log("          NOT typing in synopse, so paginating")
	
			try{

				for (scene of outlineElements){
					let returnvalue = paginateThis(scene, paginator)
						pagesForElements.push(returnvalue[0])
						pageBreakPositions.push(returnvalue[1] || false)
						//pagesForElements.push(paginateThis(scene, paginator))
				}
				
				pages = JSON.stringify(pagesForElements)
				pageBreaks = JSON.stringify(pageBreakPositions)
				
			} catch(e) {
				Beat.dispatch_sync(function(){	
					htmlWindow.runJS(`mylog("There was an ERROR in the background: updateEntireOutline() ` + e + `", true)`)
				})
			}

		// }
		
		Beat.dispatch_sync(function(){	
			Beat.log("          dispatch_sync, runJS")


			let tmp = makeJSON() 
			let json = tmp.json
			let frontMatter = tmp.frontMatter
			midTime3 = new Date()
			htmlWindow.runJS("updateEverything(" + json + "," + location + "," + length + "," + pages + "," + Beat.getText().length + "," + pageBreaks + "," + frontMatter + ")")
			
			// SPEEDOMETER!
			endTime = new Date()
				Beat.log( "          after paginator: " + (midTime1.getTime() - startTime.getTime()) + " ms")
				Beat.log( "          after json: " + (midTime2.getTime() - startTime.getTime()) + " ms")
				Beat.log( "          Total time: " + (endTime.getTime() - startTime.getTime()) + " ms")

			if(queueOneMoreFullUpdate){
				queueOneMoreFullUpdate = false
				//Beat.log("Firing another round due to queued up outline change!")
				Beat.custom.updateEntireOutline()
			}

			backgroundAlreadyRunning = false
			fullUpdateInProgress = false
			
			// BELOW: small update immediately after FULL seems to mitigate anomaly when writing at end-of-scene
			// Reason: during the second that the full update takes to paginate, the outline MAY become offset to
			// the pagination data. UpdateOneScene collects the outline in milliseconds, thus reasonably syncing it
			// to the paginated data. This is not perfect, but seems to be as good as we can get.
			
			outlineJustFired = false
			Beat.custom.updateOnlyOneScene(location, length)
		})
	})
}

Beat.onTextChange(function (location, length) { 
	// Beat.log("FIRED: onTextChange -- location is " + location)

	if(outlineJustFired){
		// Beat.log("OnTextChange was IMMEDIATELY CANCELED"); 
		return
	}

	if(location){ //check if we are in an outline element and if so disreagard this call
		let outlineDetector = Beat.currentParser.lineAtIndex(location)
		
		if (outlineDetector?.isOutlineElement()){

			//Beat.log("            >>> ENDING onTextChange bc writing in outline")
			return
		}
	}

	if (!fullUpdateInProgress){
		smallUpdateInProgress = true
		htmlWindow.runJS("startSmallUpdate(" + location + "," + length + ", " + "1000" + ", " + JSON.stringify(Beat.currentParser?.sceneAtPosition(location)?.typeAsString()) + ")") 
		//htmlWindow.runJS("startSmallUpdate(" + location + "," + length + ")") 
	}
	
			// PLUGIN: onTextChange (THIS FUNCTION) will call...
			// HTMLWINDOW: startSmallUpdate, which will call...
			// PLUGIN: beat.custom.updateOnlyOneScene, which will call...
			//         makeJSON, then
			//         paginateThis, which returns to updateOnlyOneScene, which will call...
			// HTMLWINDOW: updateOneScene

})

Beat.custom.updateOnlyOneScene = function (location, length) {
	//Beat.log("==================== updateOnlyOneScene, location is" + location)
	htmlWindow.runJS("document.getElementById('outOfSyncDiv').classList.add('animate')");
	htmlWindow.runJS("document.getElementById('outOfSyncDiv').style.display = 'block'");
	htmlWindow.runJS("document.getElementById('flexiContainer').classList.add('wait')");

	if(outlineJustFired){
		//Beat.log("CANCELED UPDATE_ONLY_ONE B/C OutlineJustFired"); 
		return
	}

	if (backgroundAlreadyRunning){
		//Beat.log("          CANCELLED UPDATE ONLY ONE B/C BACKGROUND WAS RUNNING!")
		return
	}

	if (location < Beat.outline()[0]?.sceneStart){ //look for title page changes only if typing before first outline
		
		let a = Beat.currentParser.lineAtPosition(location)
		if (a.isTitlePage){
			fetchDocumentTitles(a.string)
		}
	}

	runCounterText++
	//Beat.log("Only Once Scene is now RUNNING! " + runCounterText)
	
	let outlineElements = Beat.outline()
	let whichSceneAreWeIn = 0
	while (outlineElements[whichSceneAreWeIn + 1] && outlineElements[whichSceneAreWeIn + 1].sceneStart < location){
		whichSceneAreWeIn ++
	}

	while (outlineElements[whichSceneAreWeIn - 1] && outlineElements[whichSceneAreWeIn].typeAsString() == "Synopse"){whichSceneAreWeIn --} //added to fix static scenes if synopse 21'11'17

	let scene = outlineElements[whichSceneAreWeIn]
	const paginator = Beat.paginator()
	let returnvalue = paginateThis(scene, paginator)
		let pages = returnvalue[0]
		let pageBreakPosition = returnvalue[1]

	let tmp = makeJSON() 	
	let json = tmp.json
	let frontMatter = tmp.frontMatter
	
	htmlWindow.runJS("updateOneScene(" + json + "," + whichSceneAreWeIn + "," + pages + "," + location + "," + length + "," + Beat.getText().length + "," + pageBreakPosition + "," + frontMatter + ")")
}

Beat.onSelectionChange(function (location, length) {
	
	if (fullUpdateInProgress || smallUpdateInProgress){
		return
	}

    if (selectionTimer) {
        selectionTimer.invalidate()
        selectionTimer = null
    }

    selectionTimer = Beat.timer(0.2, function() {
		htmlWindow.runJS("youAreHere(" + location + "," + length + ", true)") //last value is "positionChangeOnly"
    })
})



function ____________________HELPERS__________(){}

// function paginateThis(scene, paginator, content) { //PREVIOUSLY HAD CONTENT HERE
function paginateThis(scene, paginator) {

	//Beat.log("PaginateThis") This is the wildest time-suck. How to avoid?

	let fixedPage
	let content
	let pageBreakIndex

	try{

		content = Beat.linesForScene(scene)	

		//pageBreakFinder:

			let subContent = []
			let addExtraLine = 0
			
			for (contentline of content){
				
				if(contentline.typeAsString() == "Page Break") {
					
					paginator.paginateLines(subContent)
					pageBreakIndex = (paginator.numberOfPages + paginator.lastPageHeight - (paginator.lastPageHeight > 0 ? (paginator.numberOfPages < 1 ? 0 : 1) : 0))
					
					//break // NO: without break, we will do this for the LAST pagebreak in a scene if several. Which seems reasonable!
				}

				if(contentline.typeAsString() == "Heading") addExtraLine = 2/58

				subContent.push(contentline)
			}

		paginateStartTime = new Date ()
		paginator.paginateLines(content)

		paginateEndTime = new Date ()
		timeSpentPaginatingLines += (paginateEndTime.getTime() - paginateStartTime.getTime())

		let pagesToReduceWith = 0
		// if (paginator.lastPageHeight > 0){
		// pagesToReduceWith = (paginator.numberOfPages < 1)? 0 : 1
		// }
			if (paginator.lastPageHeight > 0 && paginator.numberOfPages > 0) pagesToReduceWith = 1
		fixedPage = paginator.numberOfPages + paginator.lastPageHeight - pagesToReduceWith

		// if(accumulatedLastPageHeight) fixedPage = fullPageLengthForBrokenScene

		smallUpdateInProgress = false

		// fixedPage += hackyAbsoluteHeightOfLine / 2 //adds a line before each scene. Since removed, and since changed to HALF a line.
		fixedPage += addExtraLine

	} catch(e) {
		Beat.dispatch_sync(function(){	
			htmlWindow.runJS(`mylog("There was an ERROR in the background: paginatethis() ` + e + `", true)`)
		})
	}

	//Beat.log("End of PaginateThis  -- result was " + fixedPage)
	return [fixedPage, pageBreakIndex]
}

function makeJSON(){

	let outlineItems = Beat.outlineAsJSON() 
	let allLines = Beat.lines()
	let frontMatter = 0

	//what in the world did I think this one was doing?
		// for (let i = 0; i < outlineItems.length; i ++){
		// 	outlineItems[i].pageBreak = "---"
		// }

	let line
	for (line of allLines){
		if (line.isTitlePage() || ["Empty", "Synopse"].includes(line.typeAsString())) {
			frontMatter = line.position + line.range.length
		}
		if (!line.isTitlePage() && !["Empty", "Synopse"].includes(line.typeAsString())) {
			break
		}
	}
	outlineItems[0].frontMatter = frontMatter //this is NOT shipping it over -- what to do...

    let json = JSON.stringify(outlineItems)

	// Beat.log(outlineItems)
    return {"json": json, "frontMatter": frontMatter}
}

function titleCaseThis(str) {
	let upper = true;
	let newStr = "";
	for (let i = 0, l = str.length; i < l; i++) {
	  if (str[i] == " " || str[i] == "-") {
		upper = true;
		  newStr += str[i];
		continue;
	  }
	  newStr += upper ? str[i].toUpperCase() : str[i].toLowerCase();
	  upper = false;
	}
	// Beat.log("titleCase of " + str + " is now" + newStr)
	return newStr;
}



function ____________________STORING_STUFF___________________(){}

function makeStoringDefaultsDiv(){

	let userDefault = {}
	let documentSetting = {}

	userDefault.isRealTimeOn = Beat.getUserDefault("realTimeUpdates") || 1
		if(userDefault.isRealTimeOn != 0){userDefault.isRealTimeOn = 1}
	userDefault.warningsAreOn = Beat.getUserDefault("warningsAreOn") || true
		if(userDefault.warningsAreOn != "false"){userDefault.warningsAreOn = true}
	userDefault.colorScheme = `"${Beat.getUserDefault("colorScheme")}"` || `"FTOutliner"`
		if(userDefault.colorScheme != `"Beat"`){userDefault.colorScheme = `"FTOutliner"`}
	userDefault.loggingIsOn = Beat.getUserDefault("loggingIsOn") || false
		if(userDefault.loggingIsOn != "true"){userDefault.loggingIsOn = false}

	userDefault.invertTextOnDark = Beat.getUserDefault("invertTextOnDark")
		if(userDefault.invertTextOnDark != "false"){userDefault.invertTextOnDark = true}

	userDefault.excludeVoiceOvers = Beat.getUserDefault("excludeVoiceOvers") || false
	 	if(userDefault.excludeVoiceOvers != "true"){userDefault.excludeVoiceOvers = false}

	documentSetting.areScenesProportional = Beat.getDocumentSetting("showProportional") || 1
		if(documentSetting.areScenesProportional != "0"){documentSetting.areScenesProportional = "1"}
	documentSetting.whatAreSceneNumbers = `"${Beat.getDocumentSetting("showNumbers")}"` || "none"
		if(documentSetting.whatAreSceneNumbers !== `"none"` && documentSetting.whatAreSceneNumbers !== `"inline"`){documentSetting.whatAreSceneNumbers = `"none"`}
	documentSetting.whatAreSceneLengths = `"${Beat.getDocumentSetting("showLengths")}"` || "none"
		if(documentSetting.whatAreSceneLengths != `"none"` && documentSetting.whatAreSceneLengths != `"inline"`){documentSetting.whatAreSceneLengths = `"none"`}
	documentSetting.whatArePageNumbers = `"${Beat.getDocumentSetting("showPages")}"` || "none"
		if(documentSetting.whatArePageNumbers != `"none"` && documentSetting.whatArePageNumbers != `"inline"`){documentSetting.whatArePageNumbers = `"none"`}
	documentSetting.oneColumnOutline = Beat.getDocumentSetting("oneColumnOutline") || "0"
		if(documentSetting.oneColumnOutline != "1" && documentSetting.oneColumnOutline != "0"){documentSetting.oneColumnOutline = "0"}
	documentSetting.currentZoomLevel = Number(Beat.getDocumentSetting("currentZoomLevel")) || 1
		if(documentSetting.currentZoomLevel < 0 || documentSetting.currentZoomLevel > 2){documentSetting.currentZoomLevel = 1}
	documentSetting.notepanelWidth = parseInt(Beat.getDocumentSetting("notepanelWidth")) || false

	documentSetting.noteButtonGreen = Beat.getDocumentSetting("noteButtonGreen") || true
	documentSetting.noteButtonYellow = Beat.getDocumentSetting("noteButtonYellow") || true
	documentSetting.noteButtonRed = Beat.getDocumentSetting("noteButtonRed") || true
	documentSetting.noteButtonMagenta = Beat.getDocumentSetting("noteButtonMagenta") || true
	documentSetting.noteButtonPurple = Beat.getDocumentSetting("noteButtonPurple") || true
	documentSetting.noteButtonReview = Beat.getDocumentSetting("noteButtonReview") || false

	documentSetting.indexCardMode = Beat.getDocumentSetting("indexCardMode") || false
	documentSetting.indexCardHeight = Number(Beat.getDocumentSetting("indexCardHeight")) || 3
	 	if(documentSetting.indexCardHeight < 0 || documentSetting.indexCardHeight > 20){documentSetting.indexCardHeight = 3}

	documentSetting.cardStateForScenes = "[" + Beat.getDocumentSetting("cardStateForScenes") + "]"|| "[]"
	documentSetting.cardStateForSections = "[" + Beat.getDocumentSetting("cardStateForSections") + "]" || "[]"

	documentSetting.notesAreDisplayed = Beat.getDocumentSetting("notesAreDisplayed") || false
		//if(documentSetting.notesAreDisplayed != true){documentSetting.notesAreDisplayed = false}
	documentSetting.markersAreDisplayed = Beat.getDocumentSetting("markersAreDisplayed") || false
		//if(documentSetting.markersAreDisplayed != true){documentSetting.markersAreDisplayed = false}
	documentSetting.beatsAreDisplayed = Beat.getDocumentSetting("beatsAreDisplayed") || false
	//if(documentSetting.BeatsAreDisplayed != true){documentSetting.BeatsAreDisplayed = false}
	documentSetting.reviewsAreDisplayed = Beat.getDocumentSetting("reviewsAreDisplayed") || false
	documentSetting.greyonly = Beat.getDocumentSetting("greyonly") || false
	documentSetting.notepanel = Beat.getDocumentSetting("notepanel") || false
	documentSetting.showSynopsisInScenes = Beat.getDocumentSetting("showSynopsisInScenes") || false
	documentSetting.showMultipleSceneLines = Beat.getDocumentSetting("showMultipleSceneLines") || false
	documentSetting.showMultipleSectionLines = Beat.getDocumentSetting("showMultipleSectionLines") || false
	documentSetting.allowLowerCaseSections = Beat.getDocumentSetting("allowLowerCaseSections") || false
	documentSetting.showVerticals = Beat.getDocumentSetting("showVerticals") || false
	documentSetting.showPageDividers = Beat.getDocumentSetting("showPageDividers") || false
	documentSetting.showPageDividersAlways = Beat.getDocumentSetting("showPageDividersAlways") || false

	documentSetting.documentName = Beat.getDocumentSetting("documentName") || false
	if(documentSetting.documentName) documentSetting.documentName = JSON.stringify(documentSetting.documentName)
	documentSetting.documentSubName = Beat.getDocumentSetting("documentSubName") || false
	if(documentSetting.documentSubName) documentSetting.documentSubName = JSON.stringify(documentSetting.documentSubName)
	documentSetting.documentAuthor = Beat.getDocumentSetting("documentAuthor") || false
	if(documentSetting.documentAuthor) documentSetting.documentAuthor = JSON.stringify(documentSetting.documentAuthor)
	
	documentSetting.boneyardIsClosed = Beat.getDocumentSetting("boneyardIsClosed") || false

	documentSetting.trackingIncludesSynopsis = Beat.getDocumentSetting("trackingIncludesSynopsis") || true
	documentSetting.showRevisions = Beat.getDocumentSetting("showRevisions") || false

	thePanelWidth = Beat.getDocumentSetting("thePanelWidth");
		if(!thePanelWidth){thePanelWidth = 800}
	thePanelHeight = Beat.getDocumentSetting("thePanelHeight");
		if(!thePanelHeight){thePanelHeight = 800}
	thePanelX = Beat.getDocumentSetting("xposition");
		if(!thePanelX){thePanelX = 0}
	thePanelY = Beat.getDocumentSetting("yposition");
		if(!thePanelY){thePanelY = 0}

	documentSetting.theDocumentsWidth = thePanelWidth
	documentSetting.theDocumentsHeight = thePanelHeight
	documentSetting.theWindowsPositionX = thePanelX
	documentSetting.theWindowsPositionY = thePanelY

	let allDefaults = `<script>
		Beat.call("Beat.log('in HTML: Now exectuing the setting of userDefaults')")

		var userDefault = {
		`

			for([key, value] of Object.entries(userDefault)){
				allDefaults += `
					${key} : ${value},`
			}

		allDefaults += `}
		
		Beat.call("Beat.log('in HTML: Now executing the setting of documentSettings')")

		var documentSetting = {`

			for([key, value] of Object.entries(documentSetting)){
				allDefaults += `
					${key}: ${value},`
			}

		allDefaults += `}
	
		Beat.call("Beat.log('Successfully done')")
		
		documentName = documentSetting.documentName //hack to transfer value to global variable
		documentSubName = documentSetting.documentSubName //hack to transfer value to global variable
		documentAuthor = documentSetting.documentAuthor //hack to transfer value to global variable

		</script>`

		Beat.log(allDefaults)

	return allDefaults
}

Beat.custom.setFrame = function (theWindowsPositionX, theWindowsPositionY, theDocumentsWidth, theDocumentsHeight){
	htmlWindow.setFrame(theWindowsPositionX, theWindowsPositionY, Math.max(theDocumentsWidth, 380), theDocumentsHeight)
}

Beat.custom.saveWindowSize = function() {
	let a = htmlWindow.getFrame()
	
	Beat.setDocumentSetting('xposition', a.x)
	Beat.setDocumentSetting('yposition', a.y)
	Beat.setDocumentSetting('thePanelHeight', a.height)
	Beat.setDocumentSetting('thePanelWidth', a.width)
}

Beat.custom.limitWidth = function() {

	let a = htmlWindow.getFrame()

	htmlWindow.setFrame(a.x, a.y, 380, a.height)
	htmlWindow.runJS("someoneResizedTheWindow()")

}

function ____________________CHARACTER_TRACKING___________________(){}

Beat.custom.addCharacterClasses = function() {

	let allLines = Beat.lines()
	//let allScenes = Beat.scenes()
	let allScenes = Beat.outline()
	charactersArray = []
	let occurrencesForCharacter = []

	for (line of allLines){
		if (line.omitted){continue}
		if (line.typeAsString() == "Character"){
			let name = line.string
			name = name.replace(/^\^/, "")
			name = name.replace(/^@/, "")
			name = name.replace(/\(.*\)/gm, '');
			name = name.replace(/\'/gm, '´');
			name = titleCaseThis(name)
			name = name.trim()
			if (!charactersArray.includes(name)){
				charactersArray.push(name)
				occurrencesForCharacter.push(0)
			}else{
				occurrencesForCharacter[charactersArray.indexOf(name)] ++
			}
		}
	}
	
	let temporarySortingArray = []
	let biggestNumber
	let index
	for (let i = 0; i < occurrencesForCharacter.length; i++){

		biggestNumber = Math.max(...occurrencesForCharacter)
		index = occurrencesForCharacter.indexOf(biggestNumber)
		temporarySortingArray.push(charactersArray[index])
		occurrencesForCharacter[index] = -1
	}

	charactersArray = temporarySortingArray
	scenesWithCharactersArray = []

	// I now have all characters. Time to evaluate scenes.

	const outline = [...Beat.outline()]
	let excludeVoiceOvers = (Beat.getUserDefault("excludeVoiceOvers") == "true")
	let trackingIncludesSynopsis = (Beat.getDocumentSetting("trackingIncludesSynopsis") == "true")

	for (scene of allScenes){
		const lines = Beat.linesForScene(scene)
		const sceneNumber = outline.indexOf(scene)//scene.sceneNumber
		let copyOfCharacters = [...charactersArray]
		let charactersInScene = ""

		//Beat.log("now evaluating characters in a... " + scene.typeAsString() + " with " + lines.length + " lines")

		for (line of lines){

			if (line.omitted){continue}

			if (line.typeAsString() == "Character") {
				let name = line.string

				if(excludeVoiceOvers){
					//Beat.log("I AM CHECKING FOR EXLUSION, because EXCLUDE = " + excludeVoiceOvers)
					let extension = name.match(/\((.*)\)/)
					if(extension){
						if (["VO", "V.O", "V.O.", "PRELAP"].includes(extension[1].toUpperCase())) continue
					}
				} 

				name = name.replace(/^\^/, "")
				name = name.replace(/^@/, "")
				name = name.replace(/\(.*\)/gm, '');
				name = name.replace(/\'/gm, '´');
				name = name.trim()
				name = titleCaseThis(name)

			 	if (copyOfCharacters.includes(name)){
					copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
					let spacelessName = name.replace(/ /g, "_")
					spacelessName = spacelessName.replace(/\'|\"/g, "-")
					charactersInScene += spacelessName + " "
				}
			}

			if (line.typeAsString() == "Action" || (trackingIncludesSynopsis && line.typeAsString() == "Synopse")) {

				for (let i=0; i<copyOfCharacters.length; i++){
					let name = copyOfCharacters[i]

					//new matching
					// Beat.log("now matching: " + name)
					// let regOfName = new RegExp(name.toLowerCase().replace(/´/g, "'"))
					// let matchString = line.string.match(regOfName, "i")
					// Beat.log(matchString)
					// if (matchString && matchString[0].substr(0,1) == matchString[0].substr(0,1).toUpperCase()){
					
					//old matching
					//if (line.string.includes(name.replace(/´/g, "'")) || line.string.includes(name.replace(/´/g, "'").toUpperCase())){
					
					let matchIndex = line.string.toUpperCase().indexOf(name.toUpperCase().replace(/`/g, "'"))
					if (matchIndex > -1 && line.string.substr(matchIndex, 1) == line.string.substr(matchIndex, 1).toUpperCase()){
						// Beat.log("YES (add). The match is: " + matchIndex)
						// Beat.log(line.string.substr(matchIndex, name.length))

						copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
						let spacelessName = name.replace(/ /g, "_")
						spacelessName = spacelessName.replace(/\'|\"/g, "-")
						charactersInScene += spacelessName + " "
					}
				}
			}
		}
		scenesWithCharactersArray[sceneNumber]=charactersInScene	
	}	
	htmlWindow.runJS("makeCharacterMenu(" + JSON.stringify(charactersArray) + "," + JSON.stringify(scenesWithCharactersArray) + "); updateFilter()")
}

Beat.custom.reevaluateCharactersForScene = function(outlineNumber, sendToUpdateTrueOrFalse){

	let excludeVoiceOvers = (Beat.getUserDefault("excludeVoiceOvers") == "true")
	let trackingIncludesSynopsis = (Beat.getDocumentSetting("trackingIncludesSynopsis") == "true")
	const scene = Beat.outline()[outlineNumber]
	// const sceneNumber = Beat.outline()[outlineNumber].sceneNumber

	const lines = Beat.linesForScene(scene)
	let copyOfCharacters = [...charactersArray]
	let charactersInScene = ""

	for (line of lines){

		if (line.omitted){continue}

		if (line.typeAsString() == "Character") {
			let name = line.string

			if(excludeVoiceOvers){
				//Beat.log("I AM CHECKING FOR EXLUSION, because EXCLUDE = " + excludeVoiceOvers)

				let extension = name.match(/\((.*)\)/)
				if(extension){
					if (["OS", "O.S.", "VO", "V.O.", "PRELAP"].includes(extension[1].toUpperCase())) continue
				}
			} 

			name = name.replace(/^\^/, "")
			name = name.replace(/^@/, "")
			name = name.replace(/\(.*\)/gm, '');
			name = name.replace(/\'/gm, '´');
			name = name.trim()
			name = titleCaseThis(name)

			 if (copyOfCharacters.includes(name)){
				copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
				let spacelessName = name.replace(/ /g, "_")
				spacelessName = spacelessName.replace(/\'|\"/g, "-")

				charactersInScene += spacelessName + " "
			}
		}

		if (line.typeAsString() == "Action" || (trackingIncludesSynopsis && line.typeAsString() == "Synopse")) {			for (let i=0; i<copyOfCharacters.length; i++){
				let name = copyOfCharacters[i]

				//new matching
				// Beat.log("now matching: " + name)
				// let regOfName = new RegExp(name.toLowerCase().replace(/´/g, "'"))
				// let matchString = line.string.match(regOfName, "i")		
				// Beat.log(matchString)
				// if (matchString && matchString[0].substr(0,1) == matchString[0].substr(0,1).toUpperCase()){

				//old matching
				//if (line.string.includes(name.replace(/´/g, "'")) || line.string.includes(name.replace(/´/g, "'").toUpperCase())){

				let matchIndex = line.string.toUpperCase().indexOf(name.toUpperCase().replace(/`/g, "'"))
				if (matchIndex > -1 && line.string.substr(matchIndex, 1) == line.string.substr(matchIndex, 1).toUpperCase()){
					//Beat.log("YES (reev). The match is: " + matchIndex)
					// Beat.log(line.string.substr(matchIndex, name.length))

					copyOfCharacters.splice(copyOfCharacters.indexOf(name), 1)
					let spacelessName = name.replace(/ /g, "_")
					spacelessName = spacelessName.replace(/\'|\"/g, "-")

					charactersInScene += spacelessName + " "
				}
			}
		}
	}
	// scenesWithCharactersArray[sceneNumber]=charactersInScene
	scenesWithCharactersArray[outlineNumber]=charactersInScene
	if(sendToUpdateTrueOrFalse){htmlWindow.runJS("updateFilter(" + JSON.stringify(scenesWithCharactersArray) + ")")}
}

Beat.custom.changeElementColor = function (elements, newColor){	

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	const allOutlineElements = Beat.outline()
	for (element of elements){
		if (element.includes("_")){
			let parentNumber = Number(element.toString().replace(/^s/, "").replace(/_.*$/, ""))
			let synopsisNumber = Number(element.toString().replace(/^s.*_/, ""))
			let synopsis = Beat.outline()[parentNumber].synopsis[synopsisNumber]
				Beat.setColorForScene(newColor, synopsis)
		}else{
			Beat.setColorForScene(newColor, allOutlineElements[element])
		}
	}

	Beat.onTextChangeDisabled = false
	Beat.onOutlineChangeDisabled = false
	Beat.onSelectionChangeDisabled = false

	//if(!location){
		location = Beat.selectedRange().location
	//}

	htmlWindow.runJS("startSmallUpdate(" + location + ", false, 0)")
}

function ____________________NOTES__________(){}

Beat.custom.testSendingLineObject = function(){

	console.time("lineobject")

	const allLines = Array.from(Beat.lines())
	console.log(allLines)
	console.log(arrayToJSON(allLines))
	// const linesAsJSON = JSON.stringify(allLines)
	// console.log(linesAsJSON)

	console.timeEnd("lineobject")

}

Beat.custom.collectNotes = function() {
	Beat.log("collecting notes")
	// let inTime = new Date()
	// let allOutlineElements = [...Beat.outline()]
	// let parser = Beat.currentParser 

	//Experimental alternate way to extract notes
	//Only: Not getting inline notes anymore...
		//console.time("filter")
		//const allTheLines = [...Beat.lines()]
		//const result = allTheLines.filter(line => line.note);
		//console.log(result)
		//console.timeEnd("filter")

	Beat.log("entering dispatch")
	Beat.dispatch(function(){
		Beat.log("in dispatch")

		let note = []
		let marker = []
		let beats = []
		let numberOfStorylines = 0
		let previousStoryLine
		let actualNote = []
		let outlineElementNumber = -1
		let lastElementThatWasScene = -1
		let entry = 0
		let markernumber = 0

		let reg = (/\[\[.*\]\]/)
		
			let allLines = Beat.lines()
									
					for (line of allLines){
								
						if (line.typeAsString() == "Synopse" && !Beat.compatibleWith(1.977)){
							outlineElementNumber ++
							continue
						} //only interesting in old synopsis model
						
						if (["Heading", "Section"].includes(line.typeAsString())){
							outlineElementNumber ++
							lastElementThatWasScene = outlineElementNumber
						}

						if (!line.note && !line.string.includes("[[")) continue

						//first check: inline notes
						if(!line.note && line.string.includes("[[")){
							if(!["Heading", "Section", "Synopse"].includes(line.typeAsString())){
								let result = reg.exec(line.string)
								if (result){
									note[entry] = {}
									let inlineNote = result[0]
									let inlineNoteIndex = result.index || 0												
									//note[entry] = new notesData((line.position + inlineNoteIndex), inlineNote)
									note[entry].outlineElementNumber = lastElementThatWasScene
									note[entry].position = (line.position + inlineNoteIndex)
									note[entry].string = inlineNote
									entry ++
								}
							}
						}

						//second check: full-line notes
						if(line.note) {
							
							//third check: full-line but not starting
							if(!line.string.trim().startsWith("[[")) {
									try{note[entry-1].string += "<br/>" + line.string}
									catch {
										continue
									}
								continue
							}
							
							note[entry] = {}
							note[entry].outlineElementNumber = lastElementThatWasScene
							note[entry].position = line.position
							note[entry].string = line.string
							entry ++
						}
					}
				outlineElementNumber ++ //this is redundant, no?

			// Cycle all notes and put them in different arrays depending on type.
			// (This opens for creating new subsets of notes depending on starting term.)
			for (entry of note){
				if (entry.string.trim().startsWith("[[marker")){
					let stringIntoColor = entry.string.trim().toLowerCase().replace(/\[\[marker:*\s*/, "")
					stringIntoColor = stringIntoColor.match(/^#+[0-9]+|[a-z]*/)
					entry.color = stringIntoColor
					if(entry.string.includes(":")){
						stringIntoStory = entry.string?.replace(/^(.*?):/,"")?.replace(/\]\]/, "")?.toUpperCase()
						entry.story = stringIntoStory
					}
					marker.push(entry)
				}else if(entry.string.trim().startsWith("[[beat")){
					let strippedString = entry.string.replace(/\[\[beat\s*/i, "").replace(/\]\]/,"")
					let stringIntoStory = strippedString?.toUpperCase()
					if(strippedString.includes(":")){
						stringIntoStory = strippedString?.match(/^.*:/)[0]?.replace(/:/,"")?.toUpperCase()
					}
						//check if this is an existing storyline
						let thisStoryline = false
						let existingStoryline = false
						for(let prev=0; prev<beats.length; prev++){
							if (stringIntoStory == beats[prev].story){
								thisStoryline = beats[prev].storyline
								existingStoryline = true
								break //breaks out of prev-loop
							}
						}
						if(!existingStoryline){
							numberOfStorylines++
						}
						previousStoryLine = stringIntoStory //now never used, can be scrapped
					let stringIntoContent = strippedString.substring(stringIntoStory.length).replace(/^\s*:\s*/, "")
					entry.storyline = thisStoryline || numberOfStorylines
					entry.story = stringIntoStory || "UNNAMED BEAT"
					entry.content = stringIntoContent
					beats.push(entry)
				}else{
					actualNote.push(entry)
				}
			}

			// Beat.log(JSON.stringify([...actualNote]))
			// Beat.log(JSON.stringify([...marker]))
			// Beat.log(JSON.stringify([...beats]))

			Beat.dispatch_sync(function (){
				let outTime = new Date()
					htmlWindow.runJS("displayNotes(" + JSON.stringify([...actualNote]) + "," + JSON.stringify([...marker]) + "," + JSON.stringify([...beats]) + ")")
			})
	})
}

function ____________________OMITTING_AND_DELETING__________(){}

Beat.custom.omitScene = function(areScenesProportional, scenesToOmit, updatesDisabled) { 

	if (areScenesProportional == 1){
		let plural = (scenesToOmit.length > 1) ? "s" : ""
		Beat.alert("Where did my scene"+plural+" go?", "You are now in Flexible mode, and since omitted scenes literally takes up no space in the finished script, they are invisible in this view.\n\nToggle to non-flexible display (shortcut\xa0F) to see any omitted scenes." )
	}

	const outline = [...Beat.outline()]

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	for (let i=0; i<scenesToOmit.length; i++){

		nextScene = 1
		while (outline[scenesToOmit[i]+nextScene] && outline[scenesToOmit[i]+nextScene].typeAsString() == "Synopse") {
			nextScene ++
		}

		//first: check for any omissions INSIDE the scene we want to omit!
		let omissionInsideScene = false
		if (outline[scenesToOmit[i]]?.omitted == 0){
			let loopToThisPoint = outline[scenesToOmit[i] + nextScene]?.line.position - 1 || Beat.getText().length - 1
			let lineLooper = outline[scenesToOmit[i]].line.position
			let parser = Beat.currentParser
			while (lineLooper < loopToThisPoint){
				lineLooper += parser.lineAtPosition(lineLooper)?.string.length + 1
				if(parser.lineAtPosition(lineLooper)?.string.includes("*/")){
					omissionInsideScene = true
				}
			}	
		}
		if (omissionInsideScene){
			let headline = "Conflicting omission inside\n" 
			headline += (scenesToOmit.length > 1) ? "": "the scene\n" + outline[scenesToOmit[i]].sceneNumber + ". "
			headline += outline[scenesToOmit[i]].line.stripFormatting().toUpperCase() 
			headline += (scenesToOmit.length > 1) ? "\n(currently scene #" + outline[scenesToOmit[i]].sceneNumber + ")":""
			let message = (scenesToOmit.length > 1) ? "One of the scenes": "The scene"  
			message += " you are trying to omit already has an omitted/hidden chunk of text inside it.\n\nDue to how Fountain works, omitting the scene would only work up to the point where that chunk ends.\n\nThis scene is therefore left UN-OMITTED."
			if (scenesToOmit.length > 1){message += "\n\nNOTE: FTOutliner will continue to try with the rest of your selected scenes.\nYou will be notified for every scene where this problem occurs."}
			Beat.alert(headline, message)
			continue
		}

		//Beat.log("for number " + i + " ...which is " + scenesToOmit[i])
		//Beat.log("...outline[scenesToOmit[i]] is " + JSON.stringify(outline[scenesToOmit[i]]))
		//try{
		if (!outline[scenesToOmit[i] + nextScene]){
			Beat.addString("*/\n\n", (Beat.getText().length))
		}else if (!outline[scenesToOmit[i] + nextScene].omitted){
			Beat.addString("*/\n\n", (outline[scenesToOmit[i]].position + outline[scenesToOmit[i]].length))
		}
	
	//}catch{
	//	Beat.alert("this was it", "scenesToOmit[i] == " + scenesToOmit[i] + "\n but outline[scenesToOmit[i]] = " + JSON.stringify(outline[scenesToOmit[i]]))
	//}

		if (outline[scenesToOmit[i] + nextScene] && outline[scenesToOmit[i] + nextScene].omitted){
			let parser = Beat.currentParser
			let startMarkerFound = false
			let position = (outline[scenesToOmit[i] + nextScene].line.position - 1)

			while (position > outline[scenesToOmit[i]]?.position && !startMarkerFound){
				position = parser.lineAtPosition(position).position //puts us at front of line
				
				if (parser.lineAtPosition(position).string.includes("/*")){
					a = parser.lineAtPosition(position).string.replace("/*", "*/\n/*")
					Beat.replaceRange(position, a.length - 3, a)
					startMarkerFound = true
				}
				position--
			}
			if(!startMarkerFound){Beat.alert('Error finding starting point of omitted scene', 'Failed to locate any /* marker BELOW \n\n' + outline[scenesToOmit[i]].sceneNumber + ". " + outline[scenesToOmit[i]].string.toUpperCase() + "\n\nPlease check manually if your script looks as expected, or hit cmd+z for UNDO to return to the state before your latest action.")}

		}

		if (!outline[scenesToOmit[i]-1] || !outline[scenesToOmit[i]-1].omitted){Beat.addString("/*\n\n", outline[scenesToOmit[i]].position)}

		if(outline[scenesToOmit[i]-1] && outline[scenesToOmit[i]-1].omitted){
			let parser = Beat.currentParser
			let endMarkerFound = false
			let position = (outline[scenesToOmit[i]].line.position - 1)
			
			while (position > outline[scenesToOmit[i]-1].position && !endMarkerFound){
				position = parser.lineAtPosition(position).position //puts us at front of line
				
				if (parser.lineAtPosition(position).string.includes("*/")){
					a = parser.lineAtPosition(position).string.replace("*/", "*/\n/*")
					Beat.replaceRange(position, a.length - 3, a)
					startMarkerFound = true
				}
				position--
			}
			if(!startMarkerFound){Beat.alert('Error finding end point of omitted scene', 'Failed to locate any */ marker ABOVE \n\n' + outline[scenesToOmit[i]].sceneNumber + ". " + outline[scenesToOmit[i]].string.toUpperCase() + "\n\nPlease check manually if your script looks as expected, or hit cmd+z for UNDO to return to the state before your latest action.")}
		}

		startCheck = outline[scenesToOmit[i]]?.position || fullLength
		if (outline[scenesToOmit[i] + nextScene]){
			endCheck = outline[scenesToOmit[i] + nextScene].position
			checkForDoubleBlankLines(endCheck)
		}
		checkForDoubleBlankLines(startCheck)
	}

	if(!updatesDisabled){
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startSmallUpdate(001)"
		htmlWindow.runJS(jsToRun) //note: used to be startFullUpdate
	}
}

Beat.custom.unOmitScene = function(scenesToUnOmit, updatesDisabled) {

	const outline = [...Beat.outline()]

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	for (let i = 0; i < scenesToUnOmit.length; i++){

		nextScene = 1
		while (outline[scenesToUnOmit[i]+nextScene] && outline[scenesToUnOmit[i]+nextScene].typeAsString() == "Synopse") {
			nextScene ++
		}

		let omittedScene = scenesToUnOmit[i]
			if(!outline[omittedScene]?.omitted){
				continue}

		let parser = Beat.currentParser
		const position = outline[omittedScene].line.position
		let endMarkerFound = false
		let startMarkerFound = false

		//step ONE: remove the end of the omission if appropriate (or start a new one!)
		//=============================================================================

		let endOfScenePosition = (outline[omittedScene + nextScene]) ? 
			outline[omittedScene + nextScene].line.position - 1 :
			Beat.getText().length	
		endOfScenePosition = parser.lineAtPosition(endOfScenePosition).position // turn last index of line into first index of line instead

		let jumpBack = 0

		//case one: look for closing omission point from next scenes start to this
		while (endOfScenePosition - jumpBack > position && !endMarkerFound){
			
			let line = parser.lineAtPosition(endOfScenePosition - jumpBack).string

			if (line.includes('*/')){

				lineToInsert = line.replace('*/','')
				startOfLine = parser.lineAtPosition(endOfScenePosition - jumpBack).position
				lengthOfLine = parser.lineAtPosition(endOfScenePosition - jumpBack).length
					// if (lineToInsert == '') {
					// lengthOfLine ++}
	
				Beat.replaceRange(startOfLine, lengthOfLine, lineToInsert)
				checkForDoubleBlankLines(startOfLine)
				endMarkerFound = true
			}

			jumpBack = jumpBack + line.length + 1
		}
	
		//case two: no closing point found, but next scene omitted too
		if (!endMarkerFound && outline[omittedScene + nextScene] && outline[omittedScene + nextScene].omitted == 1){
			Beat.addString("/*\n\n", endOfScenePosition + 1)
			checkForDoubleBlankLines(endOfScenePosition + 1)
			endMarkerFound = true
		}

		//step TWO: remove start of omission -- case one: look for starting point up until start of prev scene
		//====================================================================================================

		let line = parser.lineAtPosition(position).string
		jumpBack = 0

		while (!line.includes('/*')){

			jumpBack++
			let lengthOfThatLine = parser.lineAtPosition(position - jumpBack).length
			jumpBack = jumpBack + lengthOfThatLine

			line = parser.lineAtPosition(position - jumpBack).string

			if (position - jumpBack < 0 || position - jumpBack <= outline[omittedScene - 1].line.position || line.includes('*/')){
				break
			}
		}

		if (line.includes('/*')){
			lineToInsert = line.replace('/*','')
			let startOfLine = parser.lineAtPosition(position - jumpBack).position
			let lengthOfLine = parser.lineAtPosition(position - jumpBack).length
				if (lineToInsert == '') {
				lengthOfLine ++}

			Beat.replaceRange(startOfLine, lengthOfLine, lineToInsert)
			checkForDoubleBlankLines(startOfLine)
			startMarkerFound = true

		}else{ 
			
			// case two: No start encountered. Is the previous scene omitted? Then just end omission before this one
			if (outline[omittedScene - 1].omitted == 1){
				Beat.addString("*/\n\n", position)
				checkForDoubleBlankLines(position)
				startMarkerFound = true
			}
		}

		//now a double-check: is no error given but the scene still omitted? Then add end marker before scene. 
		if (startMarkerFound && endMarkerFound && outline[omittedScene]?.omitted == 1){
			Beat.addString("*/\n",outline[omittedScene].line.position)
		}
	
		if (!startMarkerFound || !endMarkerFound){
			let whatsMissing = (!startMarkerFound && !endMarkerFound) ? "neither " : ""
			whatsMissing += "the "
			whatsMissing += (!startMarkerFound) ? "start " : ""
			whatsMissing += (!startMarkerFound && !endMarkerFound) ? "nor the " : ""
			whatsMissing += (!endMarkerFound) ? "end " : ""
			whatsMissing += "point"
			whatsMissing += (!startMarkerFound && !endMarkerFound) ? "s " : " "
			Beat.alert("Failed to un-omit scene" + outline[omittedScene].sceneNumber, "FTOutliner could not find\n" + whatsMissing + "\nwhen trying to un-omit the scene\n" + outline[omittedScene].string.toUpperCase() + ".\n\nPlease check your script manually to remove the corresponding /* and */ entries.\n\nSorry for the inconvenience, this really shouldn't happen.")
		}
		
	} // ENDING THE LOOP

	if(!updatesDisabled){
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate()"
		htmlWindow.runJS(jsToRun)
	}
}

Beat.custom.deleteNote = function(location, length) {

	let tmp = Beat.getText()
	if (tmp.substring(location + length -1, location + length) != "\n" || tmp.substring(location - 1, location) != "\n"){
		Beat.log("Found no CL deleting note")
		if (tmp.substring(location -1, location) != " " || tmp.substring(location + length -1, location + length) != " "){
			Beat.log("Also found no enclosing spaces on both sides")
			length --
		}
	}

	if (tmp.substring(location + length -1, location + length + 1) == "\n\n" 
		&&
		tmp.substring(location -1, location) == "\n"){
			length ++
	}

	Beat.timer(1.75, function(){
		Beat.replaceRange(location, length, '')
	})

}

Beat.custom.deleteSynopsis = function(elementsToDelete, warningsAreOn) {

	const outline = [...Beat.outline()]
	let deleteMessage

	if(elementsToDelete[0].includes("_")){
		let parentNumber = Number(elementsToDelete[0].toString().replace(/^s/, "").replace(/_.*$/, ""))
		let synopsisNumber = Number(elementsToDelete[0].toString().replace(/^s.*_/, ""))
		deleteMessage = Beat.outline()[parentNumber].synopsis[synopsisNumber].string.toUpperCase().replace(/^=/, "").replace(/\[\[.*\]\]/, "")
	}else{
		deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase()
	}
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more synopsis"}

	if(warningsAreOn){

		reallyDelete = Beat.confirm("You are about to delete the synopsis\n" + deleteMessage + "", "No other script text will be deleted\n\nThe action CAN be undone by hitting cmd+z, but beware that once you keep writing the scene may soon become irretrievably lost forever.\n\nAre you entirely sure?")

		if (!reallyDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	for (element of elementsToDelete){
		if (element.includes("_")){
			let parentNumber = Number(element.toString().replace(/^s/, "").replace(/_.*$/, ""))
			let synopsisNumber = Number(element.toString().replace(/^s.*_/, ""))
			let synopsis = Beat.outline()[parentNumber].synopsis[synopsisNumber]

			let where = Math.abs(synopsis.position)
			let howLong = synopsis.string.length
			
			Beat.replaceRange(where, howLong, "")
			checkForDoubleBlankLines(where + 1)
			
		}else{
			
			let where = Math.abs(outline[element].position)
			let howLong = outline[element].line.string.length

			Beat.replaceRange(where, howLong, "")
			checkForDoubleBlankLines(where + 1)
		}
	}
	
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate()"
		htmlWindow.runJS(jsToRun)
}

Beat.custom.deleteScene = function(elementsToDelete, warningsAreOn) {

	Beat.log("deleteScene()")

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase()
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more scenes or sequences"}

	if(warningsAreOn){
	
		reallyDelete = Beat.confirm("You are about to delete \n" + deleteMessage + "\nincluding all contents!", "This action CAN be undone by hitting cmd+z, but beware that once you keep writing the scene may soon become irretrievably lost forever.\n\nAre you entirely sure?")
		
		if (!reallyDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	//first: un-omit all scenes to delete + the one after.
	this.unOmitScene(elementsToDelete, true)

		for (let j=0; j<elementsToDelete.length; j++){

			//here check for synopsis
			let nextScene = 1
			let endPosition = false
			while (outline[elementsToDelete[j] + nextScene + 1] && outline[elementsToDelete[j] + nextScene].typeAsString() == "Synopse") {
				
				Beat.log("evaluating that there is a next scene. It contains this: " + outline[elementsToDelete[j] + nextScene + 1])
				
				nextScene ++
			}

			//unomit next scene to avoid removing /* marker
			let nextSceneIsOmitted = false
			if(outline[elementsToDelete[j] + nextScene]?.length > 0 && outline[elementsToDelete[j] + nextScene]?.omitted == true){
				
				Beat.custom.unOmitScene([elementsToDelete[j] + nextScene], true)			
				nextSceneIsOmitted = true
			}

			// NOTE: i in omit-function kills i here! Changed to j

			endPosition = outline[elementsToDelete[j] + nextScene] ? (outline[elementsToDelete[j] + nextScene].position) : Beat.getText().length //moved out from "check for synopsis" loop because un-omitting may change value of position
			let theLength = Math.max((endPosition - outline[elementsToDelete[j]].position), outline[elementsToDelete[j]].length)
			
			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength, "")
		
			if(nextSceneIsOmitted){
				Beat.custom.omitScene(false, [elementsToDelete[j]], true) // and NOT nextScene, because one scene is now removed!
				nextSceneIsOmitted = false
			}
		}

		let jsToRun = "ifYesToDelete();" +
			"document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate(500)"
		htmlWindow.runJS(jsToRun)

		Beat.timer(500, function(){
			Beat.onTextChangeDisabled = false
			Beat.onOutlineChangeDisabled = false
			Beat.onSelectionChangeDisabled = false
		})
}

Beat.custom.deleteSection = function(elementsToDelete, warningsAreOn) {

	Beat.log("deleteSection()")

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase()
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more sequences"}

	if(warningsAreOn){
	
		reallyDelete = Beat.confirm("You are about to delete the section\n" + deleteMessage + "\nincluding all synopsis inside!", "Scenes (and nested sections) below deleted sections will stay intact.\n\nThis action CAN be undone by hitting cmd+z, but beware that once you keep writing the scene may soon become irretrievably lost forever.\n\nAre you entirely sure?")
		
		if (!reallyDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	// PREVIOSLY CHECKED FOR OMISSIONS (inherited from deleteScene() function)
	// but since we're only removing a LINE now, let's just check that there is no /* or */ present in the line
	// and if there is, add it back

		// //first: un-omit all scenes to delete + the one after.
		// this.unOmitScene(elementsToDelete, true)

		for (let j=0; j<elementsToDelete.length; j++){

			//here check for synopsis
			let nextScene = 1
			let endPosition = false
			// while (outline[elementsToDelete[j] + nextScene + 1] && outline[elementsToDelete[j] + nextScene].typeAsString() == "Synopse") {
			// 	nextScene ++
			// }

			// //unomit next scene to avoid removing /* marker
			// let nextSceneIsOmitted = false
			// if(outline[elementsToDelete[j] + nextScene] && outline[elementsToDelete[j] + nextScene].omitted){
			// 	Beat.custom.unOmitScene([elementsToDelete[j] + nextScene], true)			
			// 	nextSceneIsOmitted = true
			// }

			// NOTE: i in omit-function kills i here! Changed to j

			endPosition = outline[elementsToDelete[j] + nextScene] ? (outline[elementsToDelete[j] + nextScene].position) : Beat.getText().length //moved out from "check for synopsis" loop because un-omitting may change value of position
			let theLength = Math.max((endPosition - outline[elementsToDelete[j]].position), outline[elementsToDelete[j]].length)
			
			//new: check for omission marks in string:
			restoreOmissionMark = ""
			checkString = outline[elementsToDelete[j]].line.string
			if(checkString.includes("*/") && !checkString.includes("/*")) restoreOmissionMark = "*/"
			if(checkString.includes("/*") && !checkString.includes("*/")) restoreOmissionMark = "/*"

			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength - 1, "" + restoreOmissionMark) //the minus 1 here is to leave a CR or next scene may disappear
		
			// if(nextSceneIsOmitted){
			// 	Beat.custom.omitScene(false, [elementsToDelete[j]], true) // and NOT nextScene, because one scene is now removed!
			// 	nextSceneIsOmitted = false
			// }
		}
	
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false

		let jsToRun = "document.getElementById('outOfSyncDiv').classList.add('animate'); " +
			"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
			"document.getElementById('flexiContainer').classList.add('wait'); " +
			"startFullUpdate()"
		htmlWindow.runJS(jsToRun)
}

Beat.custom.checkBlankLines = function(position){

	//used when calling from HTML
	checkForDoubleBlankLines(position)

}

function checkForDoubleBlankLines(position){

	let parser = Beat.currentParser

	for (dbl=0; dbl<15; dbl++){

		let indexOfLineAbove = JSON.parse(JSON.stringify(parser.lineAtPosition(position - 1)?.position || 0))

		let lineAbove = parser.lineAtPosition(indexOfLineAbove)?.typeAsString()
		let line = parser.lineAtPosition(position)?.typeAsString()

		if (line == "Empty" && lineAbove == "Empty" && position < Beat.getText().length){
			Beat.replaceRange(position, 1, "")
		}

		position --
	}
}

Beat.custom.moveScenes = function(firstScene, lastScene, insertBeforeScene, warningsAreOn, startPosition, endPosition, synopsisMove){

	const outline = [...Beat.outline()]

	if(synopsisMove){
		warningsAreOn = false
	}

	if(warningsAreOn){

		let rangeOfScenes = ""
		let numberOfScenesToMove = 0
		for (scenes = firstScene; scenes<lastScene+1; scenes++){
			if(outline[scenes].typeAsString() == "Synopse"){continue}
			rangeOfScenes +=
			((outline[scenes].sceneNumber != undefined) ? 
				"(" + outline[scenes].sceneNumber + ") " : 
				"") +
				outline[scenes].string.toUpperCase() + "\n" +
				((outline[scenes].sceneNumber == undefined) ? 
				"\ncontaining\n\n" : 
				"")
				numberOfScenesToMove++
		}

		let reallyMove = Beat.confirm("Verify Move!",
			"\nYou are about to move " + 
			((outline[firstScene].typeAsString() != "Section") ?
				"the scene" 
				: "the section") +
			(((outline[firstScene].typeAsString() != "Section") && numberOfScenesToMove > 1) ? 
				"s" 
				: "") +
			"\n\n" + 
			(((outline[firstScene].typeAsString() != "Section")) ? 
				rangeOfScenes 
				: (outline[firstScene].string.toUpperCase()) + "\n") + 
			((outline[insertBeforeScene]) ? 
				("\nto immediately before\n\n" + 
				(outline[insertBeforeScene].omitted == 1 ? "the omitted scene called \n" 
				: "") +
			(((outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString() == "Heading") 
				? ("(" + outline[insertBeforeScene].sceneNumber + ") ") : "") +
				outline[insertBeforeScene].string.toUpperCase()))
				: "\nto immediately after the last scene of your script.")
			+ 
			"\n\nDo you want to proceed?\n")
		if (!reallyMove) {
			htmlWindow.runJS(`onDragEnd(false, true)`)
			return
		}
	}

	htmlWindow.runJS(`ifYesToMove()`)

	//catch-all to make end of selection not out-of-range
	endPosition = Math.min(endPosition, Beat.getText().length)


	Beat.onTextChangeDisabled = true
	Beat.onOutlineChangeDisabled = true
	Beat.onSelectionChangeDisabled = true

	var theTextToMove

	//first of all all all: synopsismove. Which is its own thing now.
	if (synopsisMove){

		insertionPosition = synopsisMove
		theTextToMove = Beat.getText().substring(startPosition, endPosition)

		if (insertionPosition < startPosition) {
			deleteTheOldText()
			checkForDoubleBlankLines(startPosition + 1)
			addTheTextAtNewPosition()
			checkForDoubleBlankLines(insertionPosition + theTextToMove.length + 4)
		}
		
		if (insertionPosition > endPosition) {
			addTheTextAtNewPosition()
			checkForDoubleBlankLines(insertionPosition + theTextToMove.length + 4)			
			deleteTheOldText()
			checkForDoubleBlankLines(startPosition + 1)
		}


	}else{ //the rest is for non-synopsis!

		//even before first: check if we are dropping among omitted scenes!
		let sceneBelowDroppedWasOmitted = (outline[insertBeforeScene] && outline[insertBeforeScene].omitted == 1)
		let theSceneAbove = insertBeforeScene - 1
		while (outline[theSceneAbove] && outline[theSceneAbove]?.typeAsString() == "Synopse"){theSceneAbove --}
		let sceneAboveDroppedWasOmitted = (outline[theSceneAbove]?.omitted == 1)

		if (sceneBelowDroppedWasOmitted){
			this.unOmitScene([insertBeforeScene], true)
		}
		if (sceneAboveDroppedWasOmitted){
			this.unOmitScene([theSceneAbove], true)
		}

		//first check so that we don't break omitted scenes!
		//unomitting and reomitting the scene before will make sure it stays intact.
			if(outline[firstScene - 1] && outline[firstScene - 1].omitted){
				Beat.custom.unOmitScene([firstScene - 1])
				Beat.custom.omitScene(0, [firstScene - 1])
			}
		//then, we need to unomit the scene after, but re-omit it once the scenes are moved
			let firstSceneAfterWasOmitted = false
			if(outline[lastScene + 1] && outline[lastScene + 1].omitted){
				firstSceneAfterWasOmitted = true
				Beat.custom.unOmitScene([lastScene+1])
			}
		
		//collect insertion point
		var insertionPosition = outline[insertBeforeScene] ? outline[insertBeforeScene].position : Beat.getText().length

		//copy text from that range
		var theTextToMove = Beat.getText().substring(startPosition, endPosition)

		//NOW, re-omit the scene after the range.
		if (firstSceneAfterWasOmitted){
			Beat.custom.omitScene(0, [lastScene+1], true) 
			//NOTE: even if doing this BEFORE moving, it should work fine because we retrieved endPosition already
		}

		//insert and delete, or delete and insert, depending on wheter move was up or down

		let theNewOutlineNumberForFirstMovedScene
		
		if (insertionPosition < startPosition) {
			deleteTheOldText()
			addTheTextAtNewPosition()

			theNewOutlineNumberForFirstMovedScene = insertBeforeScene
		}

		if (insertionPosition > endPosition) {
			addTheTextAtNewPosition()
			deleteTheOldText()
			
			theNewOutlineNumberForFirstMovedScene = insertBeforeScene - (lastScene - firstScene) - 1
		}

		if (sceneBelowDroppedWasOmitted){
			Beat.custom.omitScene(0, [(theNewOutlineNumberForFirstMovedScene + lastScene - firstScene + 1)] ,true)
		}
		if (sceneAboveDroppedWasOmitted){
			let theSceneAboveInserted = theNewOutlineNumberForFirstMovedScene -1
			while (outline[theSceneAboveInserted].typeAsString() == "Synopse"){theSceneAboveInserted --}
			Beat.custom.omitScene(0, [theSceneAboveInserted], true)
		}
	}

    //finally provoke a full update!

	let jsToRun = "setTimeout(function(){" +
		"document.getElementById('outOfSyncDiv').classList.add('animate'); " +
		"document.getElementById('outOfSyncDiv').style.display = 'block'; " + 
		"document.getElementById('flexiContainer').classList.add('wait'); " +
		(synopsisMove ? "startSmallUpdate(false,false,0)},1)" : "startFullUpdate()},999)") 
		//the 999 delay here is to allow animation to finish

	htmlWindow.runJS(jsToRun)
	
	Beat.timer(1, function() {	//and this delay has the same purpose
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false
	})
	
	//finally (2) here are some scope-only functions for inserting and deleting.

		function addTheTextAtNewPosition(){

			let parser = Beat.currentParser
			let potentialExtraEmptyFirstLine = ""
			let potentialExtraEmptyLastLine = ""
			// if (parser.lineAtPosition(insertionPosition - 1).string != ""){
			if (insertionPosition > 0 && parser.lineAtPosition(insertionPosition - 1).typeAsString != "Empty"){
				potentialExtraEmptyFirstLine = "\n"
			}

			while (theTextToMove.concat(potentialExtraEmptyLastLine).substr(theTextToMove.concat(potentialExtraEmptyLastLine).length - 2, 2) != "\n\n"){
				potentialExtraEmptyLastLine += "\n"
			}

			Beat.addString(potentialExtraEmptyFirstLine + theTextToMove + potentialExtraEmptyLastLine, insertionPosition)

			checkForDoubleBlankLines(insertionPosition)
		}

		function deleteTheOldText(){
			Beat.replaceRange(startPosition, endPosition-startPosition, "")
			
			checkForDoubleBlankLines(startPosition)
		}
}

Beat.custom.reallyQuit = function (noconfirm) {

	let quit = false

	if(!noconfirm){
		quit = Beat.confirm("Do you really want to close FTOutliner?", "All your work is stored in Beat, so no harm done. It's just that it's so easy to hit Escape once too many. That's all.\n\nGo ahead and close?")
	}
	if(quit || noconfirm){
		htmlWindow.close()
	}

}

function ____________________PRINT_AND_EXPORT___________________(){}


Beat.custom.exportThis = function (content, classListOfFlexiContainer) {

	let pathToCSS = `/Users/fredriktolsson/Library/Containers/fi.KAPITAN.Beat/Data/Library/Application Support/Beat/Plugins/FTOutliner.beatPlugin/`

	let	output = `
		<!DOCTYPE html>
		<html>
		<head>
		<link rel="stylesheet" href="`+pathToCSS+`outline.css">
		<link rel="stylesheet" href="`+pathToCSS+`indexCards.html"></link>
		<link rel="stylesheet" href="`+pathToCSS+`charactertracking.html"></link>
		</head>
		<meta charset='UTF-8'>
		<body>`+
		((documentName) ? `<p class="headline">` + documentName.toUpperCase() + `</p>`: ``)
		+
		((documentSubName) ? `<p class="headline2">`+ documentSubName + `</p>`: ``)
		+
		`<div id='flexiContainer' class='` + classListOfFlexiContainer + `'>` + //`' style = "outline: 1px lime solid; height: 80vh !important">` +
		content +
		`</div>
		<p class="footer"><span style="float:right">Created using BEAT and the FTOUTLINER plugin.</span><span style="float:left">Writer: ` + documentAuthor + `</span><br/>
		<span style="opacity: 0.2; float:right">` + new Date() + `</p>
		</body></html>`

	Beat.saveFile("html", function (filePath) {

		Beat.writeToFile(filePath, output)
	 })
	
}


Beat.custom.printThis = function (content, classListOfFlexiContainer) {

	documentName = Beat.getDocumentSetting("documentName") || false
	if(documentName == "false")documentName = false
	documentSubName = Beat.getDocumentSetting("documentSubName") || false
	if(documentSubName == "false")documentSubName = false
	documentAuthor = Beat.getDocumentSetting("documentAuthor") || false
	if(documentAuthor == "false")documentAuthor = false

	loopToFetchDocumentTitles()

	if (!documentName){
		let message1 = "Print outline without title?"
		let message2 = "FTOutliner could not find the title for your screenplay. Hit cancel to open the settings dialog and enter some info, or OK to print anyway."
		let printAnyway = Beat.confirm(message1, message2)

		if(!printAnyway){
			htmlWindow.runJS("newPrintBox()")
			return
		}
	}

	let	output = /*html*/`
		<!DOCTYPE html>
		<html>
		<meta charset='UTF-8'>
		<body>
		${css}  
		${printCSS}  
		${notepanel} 
			<div id="outerEdge">
				<p class="headline"> ${documentName ? documentName.toUpperCase() : ""} </p>
				<p class="headline2"> ${documentSubName ? documentSubName : ""} </p>
					<div id="flexiContainer" class="${classListOfFlexiContainer}">
						${content} 
					</div>
			<div>
			<p class="footer"><span style="float:right">Created using BEAT and the FTOUTLINER plugin.</span><span style="float:left">${documentAuthor? "Writer: " + documentAuthor : ""}</span><br/>
			<span style="opacity: 0.2; float:right">${new Date()}</p>
		</body>
		</html>
		`

		// never turn this on except for bugging purposes!
		// opens the print-html in a new beat document
		// Beat.newDocument(output)

	Beat.printHTML(output, 
		{
			orientation: "portrait", // default is portrait
			paperSize: "a4" // default SHOULD be document setting
		}, 
			function(){htmlWindow.runJS(`togglePrintMode()`)}
	)		
}

function loopToFetchDocumentTitles(){

	let allLines = Beat.lines()
	for (line of allLines){

		if (line.isTitlePage && line.string){
			fetchDocumentTitles(line.string)
		}else{
			break
		}
	}
	return
}

function fetchDocumentTitles (titlePageLine) {

if(!titlePageLine)return

//so what we need to do is:
// if there is a titlepageline, keep going as is -- this function works now
// but if there is no titlepageline value (which means startup) then we need to do a loop over all lines before first outline element (if there is a such) and call the stuff in here for every line
// 3. We also must check for saved values when opening the printdialog, bc what is saved here seems not to show there.

// order of priority: 
// 1st -- check if there are values, because if so they win:

let documentName = Beat.getDocumentSetting("documentName") || false
if (documentName = "false") documentName = false
let documentSubName = Beat.getDocumentSetting("documentSubName") || false
if (documentSubName = "false") documentSubName = false

if (!documentName && titlePageLine && titlePageLine.toLowerCase().startsWith("title:")){
	documentName = titlePageLine.replace(/^title:\s*/i, "").toUpperCase()
}
if (!documentSubName && titlePageLine && titlePageLine.toLowerCase().startsWith("credit:")){
	documentSubName = titlePageLine.replace(/^credit:\s*/i, "")
}

if (documentName) Beat.setDocumentSetting("documentName", documentName)
if (documentSubName) Beat.setDocumentSetting("documentSubName", documentSubName)
//if (!Beat.getDocumentSetting("documentAuthor") || Beat.getDocumentSetting("documentAuthor") == '""') Beat.setDocumentSetting("documentAuthor", xxx)

setWindowTitle()

}

Beat.custom.setTheWindowTitle = function(){
	setWindowTitle()
}

function setWindowTitle() {

	windowTitle = "FTOutliner"

	// if (Beat.getDocumentSetting("documentName") && Beat.getDocumentSetting("documentName") != '""') documentName = (Beat.getDocumentSetting("documentName")) //|| (Beat.getDocumentSetting("documentName"))
	// if (Beat.getDocumentSetting("documentSubName")  && Beat.getDocumentSetting("documentSubName") != '""') documentSubName = (Beat.getDocumentSetting("documentSubName")) //|| (Beat.getDocumentSetting("documentSubName"))
	// if (Beat.getDocumentSetting("documentAuthor")  && Beat.getDocumentSetting("documentAuthor") != '""') documentAuthor = (Beat.getDocumentSetting("documentAuthor")) //|| (Beat.getDocumentSetting("documentAuthor"))
	let documentName = (Beat.getDocumentSetting("documentName")) || false
	let documentSubName = (Beat.getDocumentSetting("documentSubName")) || false
	let documentAuthor = (Beat.getDocumentSetting("documentAuthor")) || false

	//This hopefully solves backwards compatibility and manages names whether stringified or not
	if(documentName == "false") documentName = false
	if(documentSubName == "false") documentSubName = false
	if(documentAuthor == "false") documentAuthor = false
	if(documentName) documentName = documentName.replace(/"*/g, ``)
	if(documentSubName)documentSubName =documentSubName.replace(/"*/g, ``)
	if(documentAuthor)documentAuthor = documentAuthor.replace(/"*/g, ``)

	Beat.log("ABOUT TO PARSE DOCUMENT NAME")
	Beat.log(documentName)
	Beat.log(documentSubName)
	Beat.log(documentAuthor)


	// while(documentName && documentName.startsWith(`"`)) documentName = documentName.substr(1)
	// while(documentName && documentName.substr(documentName.length - 1, 1) == `"`) documentName = documentName.substr(0, documentName.length - 1)
	// while(documentSubName && documentSubName.startsWith(`"`)) documentSubName = documentSubName.substr(1)
	// while(documentSubName && documentSubName.substr(documentSubName.length - 1, 1) == `"`) documentSubName = documentSubName.substr(0, documentSubName.length - 1)
	// while(documentAuthor && documentAuthor.startsWith(`"`)) documentAuthor = documentAuthor.substr(1)
	// while(documentAuthor && documentAuthor.substr(documentAuthor.length - 1, 1) == `"`) documentAuthor = documentAuthor.substr(0, documentAuthor.length - 1)
	
	// if (documentSubName && documentSubName.startsWith('"'))documentSubName = JSON.parse(documentSubName)
	// if (documentAuthor && documentAuthor.startsWith('"'))documentAuthor = JSON.parse(documentAuthor)

	if (documentName){windowTitle += " — " + documentName}
	if (documentName && documentSubName){windowTitle += " (" + documentSubName + ")"}
	if (windowTitle){htmlWindow.title = windowTitle}

}

Beat.custom.blinkTheLine = function(start, end, color, textcolor){

	// Beat.alert(start, end)
	//start = Beat.currentParser.lineAtIndex(start)?.position

	if(Beat.currentParser.lineAtIndex(start) == null){
		Beat.crash()
	}

	if (start != Beat.currentParser.lineAtIndex(start)?.position){end --} //removes extra character added to include CR if not full line

	Beat.timer(0.25, function () {
		Beat.textBackgroundHighlight(color, start, end)
		if(textcolor){Beat.textHighlight("#222222", start, end)}
		Beat.timer(0.25, function () {

			Beat.reformatRange(start,end)

			Beat.timer(0.25, function () {
				Beat.textBackgroundHighlight(color, start, end)
				if(textcolor){Beat.textHighlight("#222222", start, end)}
				Beat.timer(0.25, function () {

					Beat.reformatRange(start,end)

					Beat.timer(0.25, function () {
						Beat.textBackgroundHighlight(color, start, end)
						if(textcolor){Beat.textHighlight("#222222", start, end)}
						Beat.timer(0.25, function () {

							Beat.reformatRange(start,end)

						})
					})
				})
			})
		})
	})
	
}

Beat.custom.sendTextToHTML = function(startIndex, endIndex){
	allText = Beat.getText()
	htmlWindow.runJS("receiveText(`" + allText + "`," + startIndex + "," + endIndex + ")")
}

Beat.custom.sendChangelogToDialog = function(){

	let message = Beat.assetAsString("changelog")

	// Beat.alert(message)

	let jsToRun = `displayAnyBox(${JSON.stringify(message)})`
	
	htmlWindow.runJS(jsToRun)

}

Beat.custom.copyRangeToClipboard = function(ranges){

	let allText = Beat.getText()
	let textToCopy = ""
	ranges = JSON.parse(ranges)
	// Beat.alert(ranges)

	for (range of ranges){

		// Beat.alert(range.start, range.end)

		textToCopy += allText.substring(range.start, range.end) + "\n\n"
	}

	Beat.newDocument(textToCopy)

}

Beat.custom.collectRevisionsInPlugin = function(){
    
        let indexObject = (Beat.getRawDocumentSetting("Changed Indices"))
        let reviewObject = (Beat.getRawDocumentSetting("Revision"))

		let indexAsJSON = JSON.stringify(indexObject)
		let reviewAsJSON = JSON.stringify(reviewObject)
    
        //Beat.log(indexAsJSON)
        //Beat.log(reviewAsJSON)

		htmlWindow.runJS(`
			paintRevisions('${indexAsJSON}', '${reviewAsJSON}')
		`)

}

Beat.custom.collectReviews = function(andThenCreateDoc){

	let reviews = Beat.getRawDocumentSetting("Review Ranges")
	let allText = Beat.getText()

		if (reviews.length == 0) return

		let outline = Beat.outline()
		let reviewNumber = 0

		for (element of outline){

			if (reviews[reviewNumber]?.range[0] >= element.position) continue
			
			while (reviewNumber < (reviews.length - 0) && reviews[reviewNumber]?.range[0] < element.position){
				
				reviews[reviewNumber].outlineElementNumber = outline.indexOf(element) - 1

				if(allText.substr(reviews[reviewNumber].range[0] + reviews[reviewNumber].range[1], 1) == "\n"){
					reviews[reviewNumber].range[1] --
				}

				reviewNumber ++

			}


		}

		if (!reviews[reviews.length - 1].outlineElementNumber){
			x = 1
			while (outline[outline.length - x].typeAsString() != "Heading") x ++
			reviews[reviews.length - 1].outlineElementNumber = outline.length - x
		}

		for (review of reviews){
			review.position = review.range[0]
		}

		reviews = JSON.stringify(reviews)

	if(andThenCreateDoc){
		htmlWindow.runJS(`createDocFromReviews(${reviews})`)
	}else{
		htmlWindow.runJS(`displayReviews(${reviews})`)
	}

}

Beat.custom.outlineToJSON = function(){
	let a = Beat.outlineAsJSON()
	//Beat.newDocument(a)


	let b = JSON.stringify(Beat.lines())
	Beat.openConsole()
Beat.log("...as JSON:")
	Beat.log(a)
Beat.log("...via JSON.stringify")
	Beat.log(b)

}

Beat.custom.linesToJSON = function(){

	let lines = Beat.lines()
	let linesAsJSON = []

	for (line of lines){
		linesAsJSON.push({...line.forSerialization()})
	}

	linesAsJSON = JSON.stringify(linesAsJSON)
	Beat.openConsole()
	Beat.log(linesAsJSON)
	// Beat.newDocument(linesAsJSON)

}

Beat.custom.makeWindowsShareScreen = function(availHeight, availWidth){

	let splitX = availWidth/2
	let splitY = availHeight/2
	
	htmlWindow.setFrame(0, 0, splitX, availHeight)
	Beat.setWindowFrame(splitX + 1, 0, availWidth/2, availHeight)

}

Beat.custom.toggleFull = function(){

	htmlWindow.toggleFullScreen()

}


