<script>

function populateScenesPanelButtons(){

    document.getElementById("scenespanelbuttons").innerHTML = "<div style='display: inline-block; vertical-align: middle;'>Sort by:</div>"

    let dropDownSpan = document.createElement("div")
        dropDownSpan.classList = "dropDownSpan hasSelect"
        dropDownSpan.style.display = "inline-block"
        dropDownSpan.style.position = "relative"
        dropDownSpan.style.verticalAlign = "middle"
        dropDownSpan.style.marginLeft = "3px"
        dropDownSpan.style.marginRight = "4px"
        dropDownSpan.innerHTML = ""
        document.getElementById("scenespanelbuttons").appendChild(dropDownSpan)

    let sortDropDown = document.createElement("select")
        sortDropDown.id = "sortDropDown"
        sortDropDown.classList.add("colorDropdown")
        sortDropDown.style.width = "auto"
        sortDropDown.innerHTML = `
            <option value="scriptOrder">SCRIPT ORDER&nbsp;</option>
            <option value="location">LOCATION&nbsp;</option>
            <option value="prefixTimeOfDay">SCHEDULE GROUP&nbsp;</option>
            <option value="timeOfDayOption">TIME OF DAY&nbsp;</option>
            <option value="prefixOption">PREFIX&nbsp;</option>
        `
        sortDropDown.value = "scriptOrder"
        if (Array.from(sortDropDown.options).some(option => option.value == documentSetting.sortDropDown)) sortDropDown.value = documentSetting.sortDropDown
        // sortDropDown.value = documentSetting.sortDropDown || "scriptOrder"
        sortDropDown.classList.toggle(sortDropDown.value, true) 

        sortDropDown.onchange = () => {
            documentSetting.sortDropDown = sortDropDown.value
            for (option of sortDropDown.options){
                sortDropDown.classList.toggle(option.value, option.value == sortDropDown.value)
            }
            updateScenePanel()
            saveCurrentState()
        }

    dropDownSpan.appendChild(sortDropDown)

    let checkboxSpan = document.createElement("div")
        checkboxSpan.id = "checkboxSpan"
        checkboxSpan.classList = "checkboxSpan"
        document.getElementById("scenespanelbuttons").appendChild(checkboxSpan)

    let mergeSimilarLocations = document.createElement("input")
        mergeSimilarLocations.type = "checkbox"
        mergeSimilarLocations.id = "mergeSimilarLocations"
        mergeSimilarLocations.checked = documentSetting.mergeSimilarLocations || false
        // document.getElementById("scenespanelbuttons").appendChild(mergeSimilarLocations)
        checkboxSpan.appendChild(mergeSimilarLocations)
        mergeSimilarLocations.onchange = () => {
            documentSetting.mergeSimilarLocations = mergeSimilarLocations.checked;
            window.onload = () => {
                [".sceneNum", ".prefix"].forEach(selector => {
                    setMutualSize(Array.from(selector))
                })
            }
            // [".sceneNum", ".duplicateSceneNum", ".prefix", ".timeOfDay", ].forEach(selector => {
            //     setMutualSize($$(selector))
            // })
            saveCurrentState()
        }

    let mergeSimilarLocationsLabel = document.createElement("label")
        mergeSimilarLocationsLabel.setAttribute("for", "mergeSimilarLocations")
        mergeSimilarLocationsLabel.textContent = "Collate twins"
    // document.getElementById("scenespanelbuttons").appendChild(mergeSimilarLocationsLabel)
    checkboxSpan.appendChild(mergeSimilarLocationsLabel)

    let onlyShowTypos = document.createElement("input")
        onlyShowTypos.type = "checkbox"
        onlyShowTypos.id = "onlyShowTypos"
        onlyShowTypos.checked = documentSetting.onlyShowTypos || false
        onlyShowTypos.onchange = () => {
            documentSetting.onlyShowTypos = onlyShowTypos.checked
            saveCurrentState()
        }
    // document.getElementById("scenespanelbuttons").appendChild(onlyShowTypos)
    checkboxSpan.appendChild(onlyShowTypos)

    let onlyShowTyposLabel = document.createElement("label")
        onlyShowTyposLabel.setAttribute("for", "onlyShowTypos")
        onlyShowTyposLabel.textContent = "Only show typos"
    // document.getElementById("scenespanelbuttons").appendChild(onlyShowTyposLabel)
    checkboxSpan.appendChild(onlyShowTyposLabel)

    let scenepanelHelpButton = document.createElement("div")
        scenepanelHelpButton.id = "scenepanelHelpButton"
        scenepanelHelpButton.classList.add("scenepanelHelpButton")
        scenepanelHelpButton.innerHTML = "?"
        scenepanelHelpButton.onclick = () => {
            // Beat.call(() => Beat.custom.displaySecondWindow("Scene Panel Help", "scenepanelhelpwindow.html", 700, 800))
            Beat.call(/*html*/`Beat.custom.displaySecondWindow("Scene Panel Help", "scenepanelhelpwindow.html", 700, 800)`)
        }
    document.getElementById("scenespanelbuttons").appendChild(scenepanelHelpButton)
    
    let scenepanelSettingsButton = document.createElement("div")
        scenepanelSettingsButton.id = "scenepanelSettingsButton"
        scenepanelSettingsButton.classList.add("scenepanelSettingsButton")
        scenepanelSettingsButton.innerHTML = gearIcon
        scenepanelSettingsButton.onclick = () => {
            // displayContextMenu(null, scenepanelSettingsButton)
            let allTod = JSON.stringify(Array.from($$(".timeOfDay")).map(tod => tod.textContent))
            Beat.call(/*html*/`Beat.custom.displaySecondWindow("Scene Panel Settings", "scenepanelsettingswindow.html", 800, 800, true, '${allTod}')`)

        }
    document.getElementById("scenespanelbuttons").appendChild(scenepanelSettingsButton)
    // checkboxSpan.appendChild(scenepanelSettingsButton)

}

function parseSceneHeadings(){

    mylog()

    if(!outline) return
    if(!($("#notepanel.expanded .scenestab.selectedtab"))) return
    
    // if(!userDefault.timeOfDayObject || Object.keys(userDefault.timeOfDayObject)?.length == 0) applySettings()
    if(!userDefault.timeOfDayObject || Object.keys(userDefault.timeOfDayObject)?.length == 0) {
        userDefault.timeOfDayObject = knownTimesOfDayObject
        saveCurrentState()
    }
    if(!$id("sortDropDown")) populateScenesPanelButtons()

    let schedulingColors = {
            INTDAY:     "hsla(210, 100%, 100%, 1.00)",
            EXTDAY:     "hsla(47, 60%, 80%, 1.00)",
            INTNIGHT:   "hsla(210, 60%, 80%, 1.00)",
            EXTNIGHT:   "hsla(150, 60%, 80%, 1.00)",
            RED:        "lightcoral" //"hsla(2, 20%, 50%, 1.00)"
        }

    let scenes = outline.filter(scene => {return scene.typeAsString == "Heading"})
    let parsedScene = []
    let prefix = ""

    for (scene of scenes){

        let string = scene.stringForDisplay.toUpperCase()

        let intextString = /^((INT(\.)*\/EXT)|(EXT(\.)*\/INT)|(INT)|(EXT)|(I(\.)*\/E)|)\.*/

        if (intextString.test(string)) {

            prefix = string.match(intextString)[0] || ""
            string = string.substring(prefix.length).trim()
            if (prefix == "") prefix = "???"

        }
        
        let addOns = string.match(/\(.*\)/g)
        if (addOns !== null){
            for (addOn of addOns){
                // string = string.replace(addOn, "/").trim() //because I now want to split the string where there used to be a parenthesis
                // string = string.replace(addOn, addOn.replace("(", "/").replace(")", "/")).trim() //because I now want to split the string where there used to be a parenthesis
                string = string.replace(addOn, "/" + addOn).trim() //because I want to split the string at a parenthesis, BUT KEEP IT IN.
            }
        }

        let parts = string/*.replaceAll(/\(.*\)/g, "")*/.toUpperCase().split(/[\s/]+-+[\s/]+|\s*\/\s*/).filter(part => part.length > 0);
        let partsIndex = []
            for (part of parts){

                indexAtStart = scene.range.location + scene.string.toUpperCase().indexOf(part)
                indexAtEnd = indexAtStart + part.length

                partsIndex.push({
                    part: part,
                    indexAtStart: indexAtStart,
                    indexAtEnd: indexAtEnd
                })

            }

        //remove addons from the end of the array
            let removedAddons = []
            let removedIndex = []
            while (addOns?.includes(parts.at(-1))){
                removedAddons.push(parts.at(-1))
                removedIndex.push(partsIndex.at(-1))
                parts.pop()
                partsIndex.pop()
            }

        //check for time of day at the end of the array
            let timeOfDay = "UNKNOWN"
            let dayOrNight
                for (key in userDefault.timeOfDayObject){

                    if (userDefault.timeOfDayObject[key].indexOf(parts.at(-1)?.toUpperCase()) > -1){
                        timeOfDay = userDefault.timeOfDayObject[key][userDefault.timeOfDayObject[key]?.indexOf(parts.at(-1)?.toUpperCase())] || "UNKNOWN"
                        dayOrNight = key.toUpperCase()

                        if (key == "same") { dayOrNight = parsedScene.at(-1)?.dayOrNight }

                        parts.pop()
                        partsIndex.pop()
                        break
                    }
                }
                if (documentSetting.sortNoneAsSame && timeOfDay == "UNKNOWN"){ dayOrNight = parsedScene.at(-1)?.dayOrNight }
                // if (userDefault.timeOfDayObject.same.includes(parts.at(-1).toUpperCase()) || (documentSetting.sortNoneAsSame && timeOfDay == "UNKNOWN")){
                //     dayOrNight = parsedScene.at(-1)?.dayOrNight
                // }


            // if (timeOfDay == parts.at(-1)){
            //     parts.pop()
            //     partsIndex.pop()
            // }
        //THIS is where I should reverse concatenation if sorting by parenthesis!
        if (documentSetting.ShowParenthesis && documentSetting.groupByParenthesis) {
            parts = removedAddons.concat(parts)
            partsIndex = removedIndex.concat(partsIndex)
        }
        if (documentSetting.ShowParenthesis && !documentSetting.groupByParenthesis) {
            parts = parts.concat(removedAddons)
            partsIndex = partsIndex.concat(removedIndex)
        }

    //adding the result to the array
        parsedScene.push({

            sceneNumber: scene.sceneNumber || scenes.indexOf(scene) + 1,
            UUID: scene.uuid,
            prefix: prefix,
            sublocations: parts, //parts.slice(["INT", "EXT"].includes(parts[0].substring(3)) ? 1 : 0),
            startIndices: partsIndex.map(part => part.indexAtStart),
            endIndices: partsIndex.map(part => part.indexAtEnd),
            timeOfDay: timeOfDay,
            dayOrNight: dayOrNight,
            other: addOns || "",
            index: scene.range.location,
            color: schedulingColors[prefix?.substring(0 , 3).replace(".", "").toUpperCase().trim() + dayOrNight?.toUpperCase().trim()] || schedulingColors["RED"],
            colorKey: prefix?.substring(0 , 3).replace(".", "").toUpperCase().trim() + " & " + dayOrNight?.toUpperCase().trim(),
            outlineColor: getComputedStyle($(`[data-uuid = '${scene.uuid}']`)).backgroundColor,
            lengthInPages: scene.numberOfPages
        })
    }

    addDividerLine ()
    
    let sortedScenes = parsedScene.sort(sortBy[$id("sortDropDown").value])

    if($id("sortDropDown").value == "location"){
        sortedScenes = sortByFrequency(sortedScenes)
    }

    //first group 
        let evenOrOdd = "odd"
        let groupDiv = document.createElement("div")
            groupDiv.classList.add("scenepanelgroup")
            groupDiv.id = "scenepanelgroup_0"
            $id("scenespanelcontent").appendChild(groupDiv)

    for (scene of sortedScenes){

        // mark double locations etc
        let thisIsADoubleLocation = false
            if($id("sortDropDown").value == "location"){
                // thisIsADoubleLocation = (scene.sublocations.join(",") == sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.join(",")) 
                thisIsADoubleLocation = (scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(",")) == (sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(","))
            }
        
        //1. the line
        let lineDiv = document.createElement("div")
            lineDiv.classList.add("line")
            lineDiv.classList.add(evenOrOdd)
            lineDiv.classList.toggle("hideWhenMergeIsChecked", thisIsADoubleLocation)
            lineDiv.dataset.line = scene.index
            
            //GROUPING
            //1. location
                if($id("sortDropDown").value == "location"){

                    

                    if (scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(",") !== sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(",")) { 
                        lineDiv.classList.remove(evenOrOdd)
                        evenOrOdd = (evenOrOdd === "odd" ? "even" : "odd")
                        lineDiv.classList.add(evenOrOdd)
                    }

                    // let startNewGroup = (documentSetting.groupByParenthesis && scene.other) ?
                    //     scene.other.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.other.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] :
                    //     scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0]
                    let startNewGroup = scene == sortedScenes.at(0) || scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] 
                    
                    // if (scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0]) { 
                    if (startNewGroup) { 
                        lineDiv.classList.add("newgroup")
                        lineDiv.classList.remove(evenOrOdd)
                        evenOrOdd = "odd"
                        lineDiv.classList.add(evenOrOdd)

                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //2. time of day
                if($id("sortDropDown").value == "timeOfDayOption"){
                    if (scene.timeOfDay != sortedScenes[sortedScenes.indexOf(scene) - 1]?.timeOfDay) { 
                        lineDiv.classList.add("newgroup")
                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //3. schedule group
                if($id("sortDropDown").value == "prefixTimeOfDay"){
                    if (scene.color != sortedScenes[sortedScenes.indexOf(scene) - 1]?.color) { 
                        lineDiv.classList.add("newgroup")

                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //4. prefix
                if($id("sortDropDown").value == "prefixOption"){
                    if (scene.prefix != sortedScenes[sortedScenes.indexOf(scene) - 1]?.prefix) { 
                        lineDiv.classList.add("newgroup")

                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //5. script order
                if($id("sortDropDown").value == "scriptOrder"){
                    // if (scene.sceneNumber != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sceneNumber) { 
                    //     lineDiv.classList.add("newgroup")

                    //     groupDiv = document.createElement("div")
                    //     groupDiv.classList.add("scenepanelgroup")
                    //     groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                    //     $id("scenespanelcontent").appendChild(groupDiv)
                    // }
                }

        let leftColumn = document.createElement("div")
            leftColumn.classList.add("leftColumn")
            leftColumn.dataset.line = scene.index

            let flexdiv = document.createElement("div")
                flexdiv.classList.add("flexdiv")
                flexdiv.dataset.line = scene.index
                flexdiv.style.width = "100%"
                flexdiv.style.height = "100%"
                flexdiv.style.display = "flex"

    //fill the line with...
        //0. scene number
        let sceneNumDiv = document.createElement("div")
            sceneNumDiv.innerText = scene.sceneNumber //+ scene.lengthInPages
            sceneNumDiv.classList.add("item")
            sceneNumDiv.classList.add("leftItem")
            sceneNumDiv.classList.add("sceneNum")
            sceneNumDiv.dataset.line = scene.index
            sceneNumDiv.style.background = documentSetting.schedulingColors ? scene.color : scene.outlineColor
            sceneNumDiv.dataset.lengthInPages = scene.lengthInPages
            sceneNumDiv.dataset.colorKey = scene.colorKey
        // leftColumn.appendChild(sceneNumDiv)
        flexdiv.appendChild(sceneNumDiv)


        //1. prefix
        let prefix = document.createElement("div")
            prefix.innerText = scene.prefix.includes("/") ? "I/E" : scene.prefix.replaceAll(".", "")
            prefix.classList.add("item")
            prefix.classList.add("leftItem")
            prefix.classList.add("prefix")
            prefix.dataset.line = scene.index
            prefix.style.background = documentSetting.schedulingColors ? scene.color : scene.outlineColor

        // leftColumn.appendChild(prefix)
        flexdiv.appendChild(prefix)

        //2. time of day
        let timeOfDay = document.createElement("div")
            timeOfDay.innerText = scene.timeOfDay
            timeOfDay.classList.add("item")
            timeOfDay.classList.add("leftItem")
            timeOfDay.classList.add("timeOfDay")
            timeOfDay.dataset.line = scene.index
            timeOfDay.style.background = documentSetting.schedulingColors ? scene.color : scene.outlineColor


        // leftColumn.appendChild(timeOfDay)
        flexdiv.appendChild(timeOfDay)

        leftColumn.appendChild(flexdiv)
        lineDiv.appendChild(leftColumn)

        //2. locations
        sublocations = scene.sublocations
        for (loc of sublocations){

            if (scene.other.includes(loc) && !documentSetting.ShowParenthesis) continue
            if (loc == scene.timeOfDay) continue

            let subloc = document.createElement("div")
                subloc.dataset.uuid = scene.UUID
                subloc.dataset.line = scene.index
                subloc.dataset.startIndex = scene.startIndices[sublocations.indexOf(loc)]
                subloc.dataset.endIndex = scene.endIndices[sublocations.indexOf(loc)]
                subloc.classList.add("item")
                subloc.classList.add("rightItem")
                subloc.classList.add("location")
                subloc.innerText = loc
                
                if (scene.other.includes(loc)) {
                    subloc.classList.add("addon")
                }

                if(documentSetting.excludedLocations?.includes(loc)){
                    subloc.classList.add("excludedLocation")
                }
                if(documentSetting.groupExclusions?.includes(loc)){
                    subloc.classList.add("dontCompare")
                }

            lineDiv.appendChild(subloc)

        }

        Array.from($$(".scenepanelgroup")).at(-1).appendChild(lineDiv)
        if(thisIsADoubleLocation) {
            $(".scenepanelgroup:last-child").lastChild.classList.add("isDouble")
            let copyOfSceneNumDiv = sceneNumDiv.cloneNode(true)
                copyOfSceneNumDiv.classList.add("duplicateSceneNum")
            let lastOriginalLine = Array.from($$(".scenepanelgroup > :not(.isDouble)")).at(-1)
                // lastOriginalLine.querySelector(".flexdiv").appendChild(copyOfSceneNumDiv)
                lastOriginalLine.querySelector(".flexdiv").insertBefore(copyOfSceneNumDiv, lastOriginalLine.querySelector(".flexdiv .prefix"))
        }
    }

    flagLinesWithSingleLocation() 

    $$(".scenepanelgroup").forEach(group => {

        let headlineDiv = document.createElement("div")
            headlineDiv.classList.add("groupHeadline")
        
        // let mainLocation = group.querySelector(".location:not(.dontCompare)")?.textContent || (group.querySelector(".location")?.textContent ? (group.querySelector(".location")?.textContent + "</strong> without sublocations") : "")
        let mainLocation = group.querySelector(".location:not(.dontCompare)")?.textContent || (group.querySelector(".item")?.textContent ? "WITH NO NAME" : "")
        let todHeadline = group.querySelector(".timeOfDay")?.textContent
        let prefixHeadline = group.querySelector(".prefix")?.textContent
        let scheduleHeadline = group.querySelector(".prefix")?.textContent + " " + group.querySelector(".timeOfDay")?.textContent
            if(mainLocation){
                let scenesInGroup = group.querySelectorAll(".sceneNum:not(.isDouble .sceneNum)")
                let numberOfScenes = scenesInGroup.length
                let lengthOfScenes = numberIntoEights(Array.from(scenesInGroup).reduce((acc, val) => acc + Number(val.dataset.lengthInPages), 0))

                switch ($id("sortDropDown").value) {
                    case "location":
                        
                        let typeOfFirstItem = "at main location"
                            if (documentSetting.groupByParenthesis && group.querySelector(".rightItem:not(.dontCompare)")?.classList.contains("addon")) typeOfFirstItem = "with parenthesis"

                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> ${typeOfFirstItem} <strong>${mainLocation}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        
                        if (group.classList.contains("singlegroup")) headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> at <strong>NON-RECURRING LOCATIONS</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;
                
                    case "prefixTimeOfDay":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> during <strong>${group.querySelector(".sceneNum").dataset.colorKey}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;

                    case "scriptOrder":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;

                    case "timeOfDayOption":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> during <strong>${todHeadline}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;

                    case "prefixOption":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> with prefix <strong>${prefixHeadline}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;
                }
            }
            
            // group.parentNode.insertBefore(headlineDiv, group)
            group.insertBefore(headlineDiv, group.firstChild)

    })
    
    compareAllLocations()
    addNumberOfPagesToLines()

    //set color of single groups
        $("#scenespanelcontent").style.setProperty("--singlegroupColor", documentSetting.singleGroupAsRed ? "rgba(220, 100, 100, 0.6)" : "rgba(255, 255, 255, 0.6)")

    //add eventhandlers
    Array.from($$(".location")).forEach(subloc => {

        subloc.onclick = (event) => {
                event.stopPropagation()
                //this empty onclick is to prevent the event from bubbling up to the group
        }
        subloc.ondblclick = (event) => {
                event.stopPropagation()
                event.preventDefault()
                event.stopImmediatePropagation()
                // newNameDialog(Array.from($$(".isSelected")).push(event.target))
                let selectedItems = Array.from($$(".isSelected"))
                    selectedItems.forEach(item => { item.classList.remove("isSelected") })
                newNameDialog(selectedItems.length > 0 ? selectedItems : Array.of(event.target))
            }
        subloc.onmouseover = (event) => {
                if ($("#contextMenu")) return //so as not to un-highlight items when moving to the menu 
                $$(".isSelected").forEach(element => {
                    element.classList.remove("isSelected")
                })
                if (!event.shiftKey) return
                $$(".location").forEach(element => {
                    if(element.textContent == event.target.textContent){
                        element.classList.add("isSelected")
                    }
                })
            }
        subloc.onmouseout = (event) => {
                // if ($("#contextMenu")) return //so as not to un-highlight items when moving to the menu 
                // if (!event.shiftKey) return
                $$(".isSelected").forEach(element => {
                    element.classList.remove("isSelected")
                })
            }

    })
    
    //size all items equally
        selectors = [".sceneNum", ".prefix"]
        selectors.forEach(selector => setMutualSize(selector))

}

function addNumberOfPagesToLines(){ 

    $$(".scenespanelcontent .line").forEach(line => {

    let whatToAddSingle = line.querySelectorAll(".sceneNum:not(.duplicateSceneNum)") 
    let whatToAddMultiple = line.querySelectorAll(".sceneNum")
    let pagesForLineSingle = numberIntoEights(Array.from(whatToAddSingle).reduce((acc, val) => acc + Number(val.dataset.lengthInPages), 0))
    let pagesForLineMultiple = numberIntoEights(Array.from(whatToAddMultiple).reduce((acc, val) => acc + Number(val.dataset.lengthInPages), 0))    
        
    line.innerHTML += `<div class="pagesForLine">
        <span class="multiplePageCount">${pagesForLineMultiple} pgs</span>
        <span class="singlePageCount">${pagesForLineSingle} pgs</span>
        </div>`

    })
}

function flagLinesWithSingleLocation(){

    if($id("sortDropDown").value !== "location") return
    if(!documentSetting.singleAtTop) return

    //add a new group before the first
    let newGroup = document.createElement("div")
        newGroup.classList.add("scenepanelgroup")
        newGroup.id = "scenepanelgroup_0"
        $id("scenespanelcontent").insertBefore(newGroup, $(".scenepanelgroup"))
    
    let allGroups = Array.from($$(".scenepanelgroup"))

    allGroups.forEach(group => {

        let onlyOneLine = group.querySelectorAll(".line").length == 1
        
        group.classList.toggle("singlegroup", onlyOneLine)
        
        if(!onlyOneLine) return

        let linecopy = group.querySelector(".line").cloneNode(true)
            linecopy.classList.toggle("odd", allGroups.indexOf(group) % 2 == 0)
            linecopy.classList.toggle("even", allGroups.indexOf(group) % 2 == 1)
            linecopy.classList.toggle("newgroup", allGroups.indexOf(group) == 0)
            allGroups[0].appendChild(linecopy)
            allGroups[0].classList.add("singlegroup")

            group.remove()
            // group.style.opacity = "0.3"
    })

    allGroups[0].querySelector(".line").classList.add("newgroup")

}

function addDividerLine(){
    $id("scenespanelcontent").style.setProperty("--scenesPanelLeftColumnWidth", (documentSetting.scenesPanelLeftColumnWidth || 120) + "px")
    $id("scenespanelcontent").innerHTML = "<div id='dividerline' draggable='true'></div>"
    
        $id("dividerline").ondragstart = (e) => {
            $id("scenespanelcontent").addEventListener("dragover", onDragOverLocal);
            $id("scenespanelcontent").classList.add("dragging")

            let temporaryDragImage = document.createElement("div")
                temporaryDragImage.id = "temporaryDragImage"
                temporaryDragImage.style.width = "1px"
                temporaryDragImage.style.height = "1px"
                temporaryDragImage.style.position = "absolute"
                temporaryDragImage.style.top = "0"
                temporaryDragImage.style.left = "0"
                temporaryDragImage.style.zIndex = "1000"
                temporaryDragImage.style.background = "transparent"
                document.body.appendChild(temporaryDragImage)

                e.dataTransfer.setDragImage(temporaryDragImage, 0, 0);

        }
        function onDragOverLocal(e) {
            e.preventDefault();
            let newWidth = e.clientX - $id("scenespanelcontent").getBoundingClientRect().left;
            $id("scenespanelcontent").style.setProperty("--scenesPanelLeftColumnWidth", newWidth + "px");
            documentSetting.scenesPanelLeftColumnWidth = newWidth;
        }
        $id("dividerline").ondragend = (e) => {
            $id("temporaryDragImage").remove()
            $id("scenespanelcontent").removeEventListener("dragover", onDragOverLocal);
            $id("scenespanelcontent").classList.remove("dragging")
            saveCurrentState();
        }
    }

function setMutualSize(selector){

            items = Array.from($$(selector))
            if(items.length == 0) return

            let largestWidth = 0
            
            for (item of items){
                if (item.style.display == "none") continue
                item.style.width = "auto"
                item.style.maxWidth = "none"
                largestWidth = Math.max(largestWidth, item.getBoundingClientRect().width)
            }
            if(selector == ".sceneNum" && $(".duplicateSceneNum")) 
                document.querySelector('.duplicateSceneNum').style.setProperty('--sceneNumWidth', `${largestWidth}px`)              

            for (item of items){
                item.style.width = largestWidth + "px"
            }
}

function compareAllLocations() {
    const allLocations = $id("scenespanelcontent").querySelectorAll(".location");
    const comparedPairs = new Set(); // To keep track of already compared pairs

    allLocations.forEach((location1, index1) => {
        const locationString1 = location1.textContent;
        if (locationString1.length < 3) return;

        allLocations.forEach((location2, index2) => {
            if (index1 === index2) return; // Skip comparing the same element with itself
            if (documentSetting.excludedLocations?.includes(location1.textContent)) return // Skip excluded locations

            const locationString2 = location2.textContent
            if (locationString2.length < 3) return

            const articleString = articleArray.join("|")
            const articleRegex = new RegExp(`\\b(${articleString})\\b\\s+`, "gi");


            const strippedString1 = locationString1.replace(articleRegex, '')
            const strippedString2 = locationString2.replace(articleRegex, '')
            let similarExceptArticle = strippedString1 == strippedString2 && locationString1 != locationString2

            const pairKey = [index1, index2].sort().join('|');
            if (comparedPairs.has(pairKey)) return; // Skip already compared pairs

            comparedPairs.add(pairKey);

            const distance = damerauLevenshtein(locationString1, locationString2);
            // const distance = levenshteinDistance(locationString1, locationString2);

            if (distance > 0 && distance < Math.min(((Math.max(locationString2.length, locationString1.length)) * 1/3), 4) || similarExceptArticle){
                    location1.classList.add("similarLocation");
                    location2.classList.add("similarLocation");

                    // Store all similar locations in an array
                    location1.dataset.similarTo = (location1.dataset.similarTo || "").split(',').concat(locationString2).join(',');
                    location2.dataset.similarTo = (location2.dataset.similarTo || "").split(',').concat(locationString1).join(',');

                    location1.dataset.representation = Array.from(allLocations).filter(loc => loc.textContent == locationString1).length
                    location2.dataset.representation = Array.from(allLocations).filter(loc => loc.textContent == locationString2).length
                    location1.classList.toggle("majority", location1.dataset.representation > location2.dataset.representation)
                    location2.classList.toggle("majority", location2.dataset.representation > location1.dataset.representation)
                    location1.classList.toggle("minority", location1.dataset.representation < location2.dataset.representation)
                    location2.classList.toggle("minority", location2.dataset.representation < location1.dataset.representation)

            }
        });
    });
}


function levenshteinDistance(str1 = '', str2 = '') {

    const track = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
        
        for (let i = 0; i <= str1.length; i += 1) {
            track[0][i] = i;
        }
        for (let j = 0; j <= str2.length; j += 1) {
            track[j][0] = j;
        }
        for (let j = 1; j <= str2.length; j += 1) {
            for (let i = 1; i <= str1.length; i += 1) {
                const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
                track[j][i] = Math.min(
                track[j][i - 1] + 1, // deletion
                track[j - 1][i] + 1, // insertion
                track[j - 1][i - 1] + indicator, // substitution
                );
            }
        }

        return track[str2.length][str1.length];

}

function damerauLevenshtein(str1, str2) {
    const len1 = str1.length;
    const len2 = str2.length;
    const matrix = Array.from({ length: len1 + 1 }, () => Array(len2 + 1).fill(0));

    // Initialize the matrix
    for (let i = 0; i <= len1; i++) {
        matrix[i][0] = i;
    }
    for (let j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }

    // Compute distances
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1, // Deletion
            matrix[i][j - 1] + 1, // Insertion
            matrix[i - 1][j - 1] + cost // Substitution
        );

        // Transposition
        if (i > 1 && j > 1 && str1[i - 1] === str2[j - 2] && str1[i - 2] === str2[j - 1]) {
            matrix[i][j] = Math.min(
            matrix[i][j],
            matrix[i - 2][j - 2] + cost
            );
        }
        }
    }

    return matrix[len1][len2];
}

function sortByFrequency(arr, position = 0) {

  // Count the frequency of each value in the specified position of the sublocations arrays
  const freqMap = new Map();
  for (const obj of arr) {
    const sublocs = obj.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc));
    if (sublocs.length > position) {
      const val = sublocs[position].trim();
      if (!documentSetting.groupExclusions?.includes(val)) { // Exclude groupExclusions here
        freqMap.set(val, (freqMap.get(val) || 0) + 1);
      }
    }
  }

  // Sort the objects based on the frequency of the specified position
  arr.sort((a, b) => {
    let sublocsA = a.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc));
    let sublocsB = b.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc));

    if (sublocsA.length <= position || sublocsB.length <= position) {
      return 0; // Objects don't have a value in the specified position, so no need to sort further
    }
    const valA = sublocsA[position].trim();
    const valB = sublocsB[position].trim();
    if (documentSetting.groupExclusions?.includes(valA) || documentSetting.groupExclusions?.includes(valB)) { // Exclude groupExclusions here
      return 0;
    }
    
    const freqA = freqMap.get(valA);
    const freqB = freqMap.get(valB);
    return freqB - freqA; // Sort in descending order of frequency

    while(arr.some(obj => obj.sublocations.length > position + 1)){
      nextPosition = position + 1
      sortByFrequency(arr, nextPosition)
    }
  });

  return arr;
}

const sortBy = {
    "timeOfDayOption": (a,b) => {

        let timeOfDayArray = Object.values(userDefault.timeOfDayObject).reduce((acc, val) => acc.concat(val), []);
        keyA = timeOfDayArray.indexOf(a.timeOfDay)
        keyB = timeOfDayArray.indexOf(b.timeOfDay)
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
    "location": (a,b) => {
        
        let filteredA = a.sublocations.filter(location => !documentSetting.groupExclusions?.includes(location));
        let filteredB = b.sublocations.filter(location => !documentSetting.groupExclusions?.includes(location));

        if(!documentSetting.groupByParenthesis){
            filteredA = filteredA.filter(location => !a.other.includes(location));
            filteredB = filteredB.filter(location => !b.other.includes(location));
        }
   
        keyA = filteredA.join(',')
        keyB = filteredB.join(',')
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
    "prefixOption": (a,b) => {
        keyA = a.prefix.trim()
        keyB = b.prefix.trim()
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
    "prefixTimeOfDay":
    (a,b) => {
        keyA = a.color
        keyB = b.color
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
}


function updateScenePanel(){

    if (!$(".scenestab.selectedtab")) return

    parseSceneHeadings()
    return

}

function swapLocationParts(startIndex, endIndex, newText, oldText){

    Beat.call(`
        Beat.replaceRange(${startIndex}, ${endIndex - startIndex}, "${newText}")`
    )

}

function makeLocationToD(item) {

    $$(".item").forEach(el => {if (el.textContent == item.textContent) el.classList.add("highlighted")})

    let text = item.textContent.toUpperCase() 
    let occurences = Array.from($$(".item")).filter(el => el.textContent == text).length

    Beat.callAndWait(([text, occurences]) => {
        let result = Beat.dropdownPrompt(`Do you want to add\n${text} (occurs ${occurences} times)\nto the list of Times-of-Day?`, `Sort ${text} as...`, ["DAY", "NIGHT", "SAME AS PREVIOUS"])
        return result
    }, [text, occurences])
    .then(
        response => {

            let val = response

                if(val == ""){
                    Beat.callAndWait(() => {
                        Beat.alert("Selection needed", "The Scene Manager needs all Time-of-Days to be sorted as one of either DAY, NIGHT or SAME.\n\nPlease make a selection in the dropdown box, or hit cancel to abort.")
                        return "whatever"
                    })
                    .then(
                        response => {
                            makeLocationToD(item)
                        })
                }

                console.log("OK was pressed and returned with the value", val)
                val = val.split(" ")[0] //get only first word if several (to get "SAME" from "SAME AS PREVIOUS")
            
                userDefault.timeOfDayObject[val.toLowerCase()]?.push(text)
                $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
                updateScenePanel()
        },
        error => {
            
            console.log(error)
            console.log("Make Location ToD cancelled (or ran into an error)")
            $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
            
        }
    )
}

function makeTodLocation(item) {

    $$(".item").forEach(el => {if (el.textContent == item.textContent) el.classList.add("highlighted")})

    let text = item.textContent.toUpperCase() 
    let occurences = Array.from($$(".item")).filter(el => el.textContent == text).length

    Beat.callAndWait(([text, occurences]) => {
        let result = Beat.confirm(`This will remove\n${text}\nfrom the list of Times-of-Day. \n\nGo ahead?`, `${text} currently occurs ${occurences} times in your sceneheadings. Removing it from the list will treat it as a location, and sceneheadings ending with ${text} will be considered having no Time-of-day.`)
        
            return JSON.stringify(result)
    }, [text, occurences])
    .then(
        response => {

            if (response == "false") return

            for (key in userDefault.timeOfDayObject) {
                userDefault.timeOfDayObject[key] = userDefault.timeOfDayObject[key].filter(item => item !== text)
            }

            $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
            updateScenePanel()
        },
        error => {
            
            console.log(error)
            console.log("Make Location ToD cancelled (or ran into an error)")
            $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
            
        }
    )
}

function deselectAllScenepanelItems(){

    $$('.item.isSelected, .item.highlighted').forEach(element => {
        element.classList.remove('isSelected');
        element.classList.remove('highlighted');
    })

}

function setScrollShadow(){

    // let myDiv = $id("scenespanelcontent")
    let myDiv = event.target

    if (myDiv.scrollTop > 0) {
        myDiv.classList.add('scrolled');
    } else {
        myDiv.classList.remove('scrolled');
    }


}

</script>

<style>

#scenespanelbuttons{

    display: flex !important;
    align-items: center;

    font-weight: bold;
    color: hsla(var(--paperBehindInk), 1);

    padding-top: 1px;
    
}

/* :has(.scenestab:not(.selectedtab)) #scenespanelbuttons{ */
:not(:has(.scenestab.selectedtab)) #scenespanelbuttons{
    
    display: none !important;

}
    

#scenespanelbuttons > *{
    vertical-align: middle;
}

#sortDropDown{
    color: black !important;
}

#checkboxSpan {

    position: relative;

    display: inline-block;
    vertical-align: middle;
    margin-left: 3px;
    margin-right: 52px;

    white-space: nowrap !important;
    overflow: hidden;
    /* text-overflow: ellipsis; */

    flex-grow: 1;
    flex-shrink: 1;
}
    
    #checkboxSpan label{
    
        position: relative;
        display: inline-block;
        
        /* outline: 1px solid lime;  */
        text-overflow: ellipsis !important;
        /* overflow: hidden !important; */
        white-space: nowrap !important;
    }



#mergeSimilarLocations, #mergeSimilarLocations + label{

    position: relative;

    margin-left: 2px;
    margin-right: 0px;
    display: none;
    font-weight: normal;
    white-space: nowrap !important;
}
    
    /* &:is(:has(#sortDropDown.location) #mergeSimilarLocations),
    &:is(:has(#sortDropDown.location) #mergeSimilarLocations + label){ */
    #mergeSimilarLocations:is(:has(#sortDropDown.location) #mergeSimilarLocations + label),
    #mergeSimilarLocations:is(:has(#sortDropDown.location) #mergeSimilarLocations),
    #mergeSimilarLocations + label:is(:has(#sortDropDown.location) #mergeSimilarLocations),
    #mergeSimilarLocations + label:is(:has(#sortDropDown.location) #mergeSimilarLocations + label){
        display: inline-block;
    }


#onlyShowTypos, #onlyShowTypos + label{

    position: relative;

    margin-left: 2px;
    margin-right: 0px;
    display: inline-block;
    font-weight: normal;
    white-space: nowrap !important;

}

#onlyShowTypos{
    margin-left: 10px;
    margin-right: 0px;
}

#scenepanelSettingsButton{

    position: absolute;
    right: 8px;
    top: 2px;
    width: 16px;
    height: 16px;
    
    display: inline-block;
    font-weight: normal;

}

#scenepanelHelpButton{

    position: absolute;
    right: 28px;
    top: 2px;
    width: 16px;
    height: 16px;

    font-size: 10px;
    text-align: center;
    
    display: inline-block;
    font-weight: normal;

    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 50%;

    color: black;
    background: white;
    opacity: 0.4;
}

        #scenepanelHelpButton:hover{
            opacity: 1;
            cursor: pointer;
        }

#scenespanelcontent{

    --scenesPanelLeftColumnWidth: 120px;

    background: #888 !important;

    position: absolute;
    width: calc(100% + 3px);
    height: calc(100% - 48px);
    margin-left: -8px;
    margin-right: -4px;
    padding: 8px !important;
    padding-top: 0px !important;
    padding-right: 12px !important;
    overflow-x: hidden;
    overflow-y: auto;
    text-overflow: ellipsis;

    /* white-space: pre !important; */
    font-size: calc(11px * var(--fontSizeFactor));
    font-weight: bold;
    color: white;

    border-bottom-right-radius: 10px;

    /* border-top: 2px groove #555 !important; */

}

    /* & #dividerline{         */
    #scenespanelcontent #dividerline{        
        
        position: fixed;
        top: 60px;
        left: calc(var(--scenesPanelLeftColumnWidth) + 12px);
        height: calc(100% - 110px);
        width: 4px;

        opacity: 0;
        border-right: 2px solid red;

        z-index: 999999;

    }
        
        /* &:hover{ */
        #scenespanelcontent #dividerline:hover{
            opacity: 0;
            cursor: col-resize;
            /* transition: opacity 1s 0.5s; */
        }
    
    /* &:has(#dividerline:hover) .leftColumn{ */
    #scenespanelcontent:has(#dividerline:hover) .leftColumn{
        
        border-right: 0.5px solid rgba(0, 0, 0, 0.9);
        transition: border 1s 0.5s;
        box-shadow: 1px 0 0 0 rgba(255, 255, 255, 0.7),
                    -1px 0 0 0 rgba(0, 0, 0, 0.7) inset;

    }

    /* &.dragging *{ */
    #scenespanelcontent.dragging *{

        cursor: col-resize !important;
    }

    /* & .scenepanelgroup{ */
    #scenespanelcontent .scenepanelgroup{

        position: relative;

        border: 3px solid rgba(255, 255, 255, 0.6);
        border-radius: 12px;
        /* margin-top: 2px;
        margin-bottom: 33px; */
        background-color: #555;

        margin-top: 4px;
        margin-bottom: 8px;

        overflow: hidden;

        padding-top: 26px;
        box-shadow: inset 0 26px 0 0px rgba(255, 255, 255, 0.6);
    }

        /* &:empty, 
        &:has(.groupHeadline:empty){ */
        #scenespanelcontent .scenepanelgroup:empty, 
        #scenespanelcontent .scenepanelgroup:has(.groupHeadline:empty){
            display: none;
        }

        /* &.singlegroup{ */
        #scenespanelcontent .scenepanelgroup.singlegroup{
            /* border-color: rgba(220, 100, 100, 0.6) !important;
            box-shadow: inset 0 26px 0 0px rgba(220, 100, 100, 0.6); */
            border-color: var(--singlegroupColor) !important;
            box-shadow: inset 0 26px 0 0px var(--singlegroupColor);
        }

    /* & .groupHeadline{ */
    #scenespanelcontent .groupHeadline{

        text-align: center;
        width: 100%;
        padding: 0px 10px;
        /* outline: 1px solid orange; */

        position: absolute;
        /* left: 15px !important; */
        top: 5px !important;
        font-weight: normal;
        color: black;

        overflow: hidden;
        text-overflow: ellipsis;
    }
        /* & strong{ */
        #scenespanelcontent .groupHeadline strong{
            font-weight: bold;
        }

    /* & .leftColumn{ */
    #scenespanelcontent .leftColumn{

        position: relative;
        left: 0;
        top: 0;

        width: var(--scenesPanelLeftColumnWidth) !important;
        display: inline-block;
        vertical-align: top;
        height: auto !important;

        padding: 0 4px 0 0;
        margin: none;

        border-right: 0.5px solid rgba(0, 0, 0, 0.4);

        overflow: hidden;
        white-space: nowrap;

        /* &:is(:has(.isDouble) .leftColumn){
            text-align: right;
        } */

        transition: height 0.5s !important;
    }

        /* &:is(:has(#sortDropDown.location):has(#mergeSimilarLocations:checked) .leftColumn){ */
        #scenespanelcontent .leftColumn:is(:has(#sortDropDown.location):has(#mergeSimilarLocations:checked) .leftColumn){

            width: var(--scenesPanelLeftColumnWidth) !important;
            white-space: normal;
        }
        
        /* & .flexdiv{ */
        #scenespanelcontent .leftColumn .flexdiv{

            width: var(--scenesPanelLeftColumnWidth);

            display: flex;
            /* flex-direction: row; */
            justify-content: flex-start; /* space-between; */
            align-items: stretch;
            /* height: 100%; */
        }
            
            /* &:is(:has(#sortDropDown.location):has(#mergeSimilarLocations:checked) .flexdiv){ */
            #scenespanelcontent .leftColumn .flexdiv:is(:has(#sortDropDown.location):has(#mergeSimilarLocations:checked) .flexdiv){
                
                flex-wrap: wrap;
                justify-content: end !important;

            }

        
    
    /* & .item{ */
    #scenespanelcontent .item{

        width: auto;
        height: calc(11px * var(--fontSizeFactor) + 4px);
        line-height: calc(12px * var(--fontSizeFactor));
            
        display: inline-block;
        padding: 2px 6px 2px 6px;
        
        box-shadow: inset 0.5px 0.5px 0px 0.5px rgba(255, 255, 255, 0.4),
                    inset -0.5px -0.5px 0px 0.5px rgba(0, 0, 0, 0.4);

        border-radius: none;
        border: none;
        vertical-align: middle;

        overflow: hidden;
        opacity: 1;

        /* transition: width 0s, height 0.5s, opacity 0.5s !important; */
        
    }

    /* & .item.isSelected:not(.highlighted), & .item:hover{ */
    #scenespanelcontent .item.isSelected:not(.highlighted), 
    #scenespanelcontent .item:hover{
        background-image: linear-gradient(rgba(0,0,0, 0.7), rgba(0,0,0,0.7)) !important;
        color: white !important;
    }


    /* & .leftItem,
    & .rightItem { */
    #scenespanelcontent .leftItem,
    #scenespanelcontent .rightItem {

        margin-left: 0px;
        margin-right: 0px;

    }

    /* & .leftItem:not(.leftItem:not(.isDouble) + .leftItem),
    & .rightItem:not(.rightItem:not(.isDouble) + .rightItem) { first item */
    #scenespanelcontent .leftItem:not(.leftItem:not(.isDouble) + .leftItem),
    #scenespanelcontent .rightItem:not(.rightItem:not(.isDouble) + .rightItem) { /* first item */

        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;

    }

    /* & .leftItem:not(:has( + .leftItem:not(.duplicateSceneNum))),
    & .rightItem:not(:has( + .rightItem:not(.duplicateSceneNum))) { last item */
    #scenespanelcontent .leftItem:not(:has( + .leftItem:not(.duplicateSceneNum))),
    #scenespanelcontent .rightItem:not(:has( + .rightItem:not(.duplicateSceneNum))) { /* last item */

        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;

    }

    /* & .sceneNum{ */
    #scenespanelcontent .sceneNum{

        color: black;
        background-color: lightcoral;

        text-align: right;
        padding-left: 8px;
        border-radius: 10px 0 0 10px !important;

        flex-shrink: 0;

        transition: border-radius 1.5s, height 0.5s 0s, width 0.5s 0.0s, opacity 0.4s 0.1s !important;
    }

        /* &:is(:has(.isDouble):has(#mergeSimilarLocations:checked) .sceneNum){ */
        #scenespanelcontent .sceneNum:is(:has(.isDouble):has(#mergeSimilarLocations:checked) .sceneNum){
            padding-right: 8px;
            border-radius: 10px !important;
        }

    /* & .prefix{ */
    #scenespanelcontent .prefix{

        color: black;
        background-color: lightcoral;

        text-align: center;

        flex-shrink: 0;

        transition: border 0s, height 0.5s 0s, width 0.0s 0.0s, opacity 0.4s 0.1s !important;

    }

    /* & .timeOfDay{ */
    #scenespanelcontent .timeOfDay{

        color: black;
        background-color: lightcoral;

        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;

        text-align: left;

        max-width: 100%;

        flex-grow: 1;

        transition: border 0s, height 0.5s 0s, width 0.0s 0.5s, opacity 0.4s 0.1s !important;

    }

    /* & .location{ */
    #scenespanelcontent .location{

        position: relative;
        background-color: hsl(200, 40%, 30%);
        transition: height 0.5s 0s, width 0.5s 0s, opacity 0.4s 0.1s !important;

        text-overflow: ellipsis;

        z-index: 9999;

    }
        
        /* &:not(.location + .location){ first item of class location */
        #scenespanelcontent .location:not(.location + .location){ /* first item of class location */

            margin-left: 4px;

        }

        /* &.similarLocation:not(.excludedLocation){ */
        #scenespanelcontent .location.similarLocation:not(.excludedLocation){

            background-color: hsl(40, 70% , 40%);
            color: white;
            font-weight: bold;

        }
            /* &.majority{ */
            #scenespanelcontent .location.similarLocation:not(.excludedLocation).majority{
                background-color: hsl(90, 40%, 30%);
                color: white;
                font-weight: bold;
            }
            /* &.minority{ */
            #scenespanelcontent .location.similarLocation:not(.excludedLocation).minority{
                background-color: hsl(0, 60%, 30%);
                color: white;
                font-weight: bold;
            }

        /* &.highlighted{ */
        #scenespanelcontent .location.highlighted{
            background-color: white !important;
            color: black !important;
            box-shadow: inset 0 0 0 1px black !important;

        }

        /* &.excludedLocation{ */
        #scenespanelcontent .location.excludedLocation{
        
            background-image: linear-gradient(to top, yellowgreen 0px, yellowgreen 2.5px, transparent 2.5px) ;
        }

        /* &.dontCompare{ */
        #scenespanelcontent .location.dontCompare{
            
            opacity: 0.4 !important;
        } 


#notepanelcontent::before,
#scenespanelcontent::before {
        
        content: "";
        display: block;
        opacity: 0;
        
        z-index:99999;
        
        position: sticky;
        top: 0;
        left: -10px;
        width: 1000px !important;
        height: 50px !important;
        margin-bottom: -50px !important;
        
        box-shadow: inset 0 30px 30px -30px rgba(0, 0, 0, 0.7);
        
        pointer-events: none;

    }

#notepanelcontent.scrolled::before,
#scenespanelcontent.scrolled::before {
        opacity: 1;
    }

.line{

    position: relative;
    display: block;   
    height: auto !important;

    line-height: 0;

    border-radius: 0;
    padding: 2px 6px;
    margin: 0px !important;

    border-top: 0.5px solid rgba(0, 0, 0, 0.6);

    transition: padding 0.5s, border 0.2s, height 0.5s, opacity 0.5s !important;

}
        
    /* &.even{ */
    .line.even{
        background: rgba(255, 255, 255, 0.45);
    }   
        /* &:not(.even + .even){ */
        .line.even:not(.even + .even){
            border-top: 0.5px solid black;
        }
    
    /* &.odd{ */
    .line.odd{
        background: rgba(255, 255, 255, 0.35);
    }
        /* &:not(.odd + .odd){ */
        .line.odd:not(.odd + .odd){
            border-top: 0.5px solid black;
        }
    

    /* &.newgroup,
    &:first-child{ */
    .line.newgroup,
    .line:first-child{
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
    }

    /* &:has(+ .newgroup),
    &:last-child{ */
    .line:has(+ .newgroup),
    .line:last-child{
        /* border-bottom: 1px solid rgba(0, 0, 0, 0.6); */
        border-bottom-left-radius: 10px;
        border-bottom-right-radius: 10px;
    }


.pagesForLine {

    z-index: -9999 !important;

}

.pagesForLine *{
        position: absolute;
        right: 0;
        top: 0;
        padding: 4px 6px !important;

        font-size: calc(9px * var(--fontSizeFactor));
        line-height: calc(12px * var(--fontSizeFactor));
        font-weight: normal;
        color: white;

    }

.isDouble .multiplePageCount{
    display: none !important;
}

:not(:has(#mergeSimilarLocations:checked)) .multiplePageCount,
:has(#mergeSimilarLocations:checked) .pagesForLine .singlePageCount{
            
    opacity: 0 !important;
    transition: opacity 0.6s 0.0s !important;

}

:has(#mergeSimilarLocations:checked) :not(.line.isDouble) > .multiplePageCount,
:not(:has(#mergeSimilarLocations:checked)) .singlePageCount {

    opacity: 0.7 !important;
    transition: opacity 0.5s 0.1s !important
}

:has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .item, 
/* :has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .leftColumn,  */
:has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .timeOfDay, 
:has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .prefix{

        min-height: 0px !important; 
        min-width: 0px !important;
        height: 0px !important; 
        width: 0px !important;
        margin: -2px 0 !important;
        padding: 0px !important;
        border: none !important;
        border-width: 0px !important;
        overflow: hidden;
        opacity: 0 !important;

        flex-grow: 0 !important;
        flex-shrink: 0 !important;
        
        /* float: right !important; */

        /* transition: height 0.5s, opacity 0.5s !important;     */

}

.duplicateSceneNum{

    --sceneNumWidth: 0px;

    display: inline-block;
    opacity: 1 !important;
    width: var(--sceneNumWidth);

    border-radius: 10px !important;

    transition: border-width 0.5s 0.5s, width 0.5s 0.0s, height 0.5s 0s, opacity 0.4s 0.1s !important;
}

    /* &:not(:has(#mergeSimilarLocations:checked):has(#sortDropDown.location) .duplicateSceneNum){ */
    .duplicateSceneNum:not(:has(#mergeSimilarLocations:checked):has(#sortDropDown.location) .duplicateSceneNum){
        
        height: 0px !important;
        width: 0px !important;
        /* max-width: 0px !important; */
        margin: 0px !important;
        padding: 0px !important;
        opacity: 0 !important;
        color: transparent;

        transition: width 0.0s 0s, height 0.5s 0s, opacity 0.4s 0.1s !important;


    }



:has(#mergeSimilarLocations:checked):has(#sortDropDown.location) .hideWhenMergeIsChecked.line{
        
        min-height: 0px !important; 
        min-width: 0px !important;
        height: auto !important;
        padding: 0px !important;
        border: none !important;
        border-width: 0px !important;
        margin: 0px !important;

        transition: padding 0.5s, border 0.2s, height 0.5s, opacity 0.5s !important;

    }

    :has(#mergeSimilarLocations:checked):has(#sortDropDown.location) /*.hideWhenMergeIsChecked*/ .innerdiv{

        white-space: normal !important;

    }

:has(#onlyShowTypos:checked) :is(.line, .scenepanelgroup):not(:has(.similarLocation:not(.excludedLocation))){

    display: none;

}

html[data-outdoors="1"] #scenespanelbuttons{

    color: black !important;

}

    html[data-outdoors="1"] #scenespanelbuttons *{
        color: black !important;
        border-color: black !important;
        fill: black !important;
    }

html[data-outdoors="1"] #scenespanelcontent{

    background: white !important;

}

    /* & .item{ */
    html[data-outdoors="1"] #scenespanelcontent .item{

        border: 1px black solid;
        padding-top: 1px !important;
        box-shadow: none !important;

    }

    /* & .scenepanelgroup{ */
    html[data-outdoors="1"] #scenespanelcontent .scenepanelgroup{

        outline: 1px solid black;
        background: #ddd;
        
    }

    /* & .line{ */
    html[data-outdoors="1"] #scenespanelcontent .line{

        border: 1px 1px 0px 1px solid black !important;

    }

    /* & .location{ */
    html[data-outdoors="1"] #scenespanelcontent .location{

        background-color: #fff;
        color: black;
    }

        /* &.highlighted{ */
            html[data-outdoors="1"] #scenespanelcontent .location.highlighted{
            background-color: black !important;
            color: white !important; 
        
        }

    /* & .pagesForLine *{ */
    html[data-outdoors="1"] #scenespanelcontent .pagesForLine *{

        font-weight: bold;
        color: black !important;

    }

</style>