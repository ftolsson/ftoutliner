<!doctype html>
<html>
	<head>
		<meta charset="utf-8"/>
		
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        
		<title>Beat Plugin Panel</title>

		<style type="text/css">
			* {
				box-sizing: border-box;
				cursor: default;
			}
			
			@font-face
			{
				font-family: 'Courier Prime';
				font-weight: normal;
				src: url("Courier Prime.ttf");
			}

			@font-face
			{
				font-family: 'Courier Prime';
				font-weight: bold;
				src: url("Courier Prime Bold.ttf");
			}
			@font-face
			{
				font-family: 'Courier Prime';
				font-style: italic;
				src: url("Courier Prime Italic.ttf");
			}
			@font-face
			{
				font-family: 'Courier Prime';
				font-weight: bold;
				font-style: italic;
				src: url("Courier Prime Bold Italic.ttf");
			}
			
			body {
				margin: 0;
				padding: 1rem;
				background-color: #f8f8f8;
				font-family: "Helvetica Neue", Helvetica, sans-serif;
				font-size: .8em;

				color: #333;

				user-select: none;
				-webkit-user-select: none;
			}
			body.dark {
				background-color: #151515;
				color: #eee;
			}

			.columns {
				width: 100%;
				display: flex;
				justify-content: space-between;
			}
			.column {
				width: 48%;
				display: flex;
				flex-direction: column;
			}
			.right {
				padding-left: 1em;
				width: 50%;
			}
			.left {
				padding-right: 1em;
				width: 50%;
			}
		
			section {
				margin: 0 auto 1rem auto;
			}

			h1, h2 {
				margin: 0 0 1rem 0;
				font-family: "Helvetica Neue", Helvetica, sans-serif;
				font-weight: normal;
				font-weight: 300;
				font-size: 2em;
			}
			h1 {
				margin-bottom: .5rem;
			}
			h2 {
				margin-top: 1rem;
				font-size: 1em;
				font-weight: bold;
			}
			p {
				line-height: 1.4em;
			}

			table { width: 100%; }
			td {
				font-size: .9em;
				padding: .35rem .25rem .35rem .25rem;
				border-bottom: 1px dotted #ddd;
			}

			.bar {
				color: #eee;
				background-color: rgb(0,129,239);
				display: flex;
				justify-content: center;
				align-items: center;
			}

			/* Beat colors */
			.red { background-color: rgb(239,0,73); color: white; }
			.blue { background-color: rgb(0,129,239); color: white; }
			.textBlue { color: rgb(0,129,239); }
			.green { background-color: rgb(0,223,121); color: white; }
			.pink { background-color: rgb(250,111,193); color: white; }
			.magenta { background-color: rgb(236,0,140); color: white; }
			.textMagenta { color: rgb(236,0,140); }
			.gray { background-color: gray; color: white; }
			.textGray { color: #ccc; }
			.purple { background-color: rgb(181, 32, 218); color: white; }
			.textPurple { color: rgb(181, 32, 218); }
			.prince { background-color: rgb(181, 32, 218); color: white; }
			.yellow { background-color: rgb(255, 162, 0); color: #333; }
			.cyan { background-color: rgb(7, 189, 236); color: white; }
			.teal { background-color: rgb(12, 224, 227); color: white; }
			.orange { background-color: rgb(255, 161, 13); color: white; }
			.textOrange { color: #006573; }
			.brown { background-color: rgb(169, 106, 7); color: white; }
			
			input[type="radio"] {
				margin: 0;
				border-radius: 50%;

				cursor: pointer;
				display: inline-block;
				
				width: 12px;
				height: 12px;
				border: solid 1px #bbb;
				
				position: relative;

				-webkit-appearance: none;
			}
			input[type="radio"]:focus {
				outline: none;
			}
			input[type="radio"]:after {
				background-color: transparent;
				border-radius: 25px;
				box-shadow: inset 0 0 0 0px hsla(0,0%,0%,.2),
							0 0px 0px hsla(0,0%,100%,.5);
				content: '';
				display: block;
				height: 8px;
				left: 1px;
				position: relative;
				top: 1px;
				width: 8px;
			}
			input[type="radio"]:checked:after {
				background-color: #888;
			}

		</style>
	</head>

	<body>
		<script crossorigin='anonymous'>			
			// Prevent native WKWebView context menu
			document.body.setAttribute('oncontextmenu', 'event.preventDefault();');
			
			// Override console methods.
			// This doesn't seem to work, though.
			function log(emoji, type, args) {
				if (type == "log") type = '';
				window.webkit.messageHandlers.log.postMessage(
															  `${emoji} ${type} ${Object.values(args)
															  .map(v => typeof(v) === "undefined" ? "undefined" : typeof(v) === "object" ? JSON.stringify(v) : v.toString())
															  .map(v => v.substring(0, 3000)) // Limit msg to 3000 chars
															  .join(", ")}`
															  )
			}

			let originalLog = console.log
			let originalWarn = console.warn
			let originalError = console.error
			let originalDebug = console.debug

			console.log = function() { log("", "log", arguments); originalLog.apply(null, arguments) }
			console.warn = function() { log("🟠", "Warning:", arguments); originalWarn.apply(null, arguments) }
			console.error = function() { log("🔴", "Error:", arguments); originalError.apply(null, arguments) }
			console.debug = function() { log("🔵", "Debug:", arguments); originalDebug.apply(null, arguments) }

			

			// Custom Beat HTML window object to allow some interaction with the host
			let Beat = {
				setData: function(data) {
					Beat.data = data;
				},
				data: null, // user-generated data to be passed back to plugin
				log: function(message) {
					window.webkit.messageHandlers.log.postMessage(message);
				},
				closeAndSendData: function() {
					sendBeatData();
				},
				call: function(value, ...parameters) {
					// We convert the value into a string, just as a safety measure
					window.webkit.messageHandlers.call.postMessage(evalToString(value, parameters))
				},
				callAndWait: function(value, ...parameters) {
					// We convert the value into a string, just as a safety measure
					return window.webkit.messageHandlers.callAndWait.postMessage(evalToString(value, parameters))
				},
				callback: function(value, param1, param2, param3) {
					let method
					let parameters
					let errorHandler
					
					if (param1 instanceof Function || typeof param1 === 'function') {
						method = param1
						parameters = param2
					}
					else {
						parameters = param1
						method = param2
					}
					
					if (param2 instanceof Function || typeof param2 === 'function') {
						errorHandler = param2
					} else {
						errorHandler = param3
					}
					 
					// We convert the value into a string, just as a safety measure
					var promise = window.webkit.messageHandlers.callAndWait.postMessage(evalToString(value, parameters))
					promise.then(
						(result) => {
							method(result)
						},
						(error) => {
							errorHandler()
						}
					)
				}
			};
			
			function evalToString (value, parameters) {
				// It's a string, do nothing, we'll just eval it
				if (value instanceof String || typeof value === 'string') {
					return value
				}
				
				if (value instanceof Function || typeof value === 'function') {
					// We'll make the value a self-executing function
					let params = ""
										
					// Handle parameters if needed
					if (parameters != null) {
						// Convert parameters to arguments by stringifying them
						for (const p of parameters) {
							// JS doesn't fucking care for my types, so let's misuse it.
							let pStr = p
							
							// Why the fuck do we need this? instanceof and typeof seem to return different values at times, so both have to be checked. Sigh.
							if (p instanceof String || p instanceof Array || p instanceof Object ||
								typeof p === "string" || typeof p === "array" || typeof p === Object) {
								pStr = JSON.stringify(pStr)
							}
							
							// Add to string and add commas
							params += pStr
							if (p != parameters[parameters.length - 1]) params += ',';
						}
					}
					
					value = "(" + value.toString() + ")(" + params + ")"
				} else {
					value = value.toString()
				}
				
				return value
			}
		
			function sendBeatData() {
				let inputs = document.querySelectorAll("[rel='beat']");
				let formData = [];
				
				for (const input of inputs) {
					let value = {
						name: input.name,
						value: input.value,
						checked: input.checked
					}
					formData.push(value);
				}
				
				let outputData = {
					inputData: formData,
					data: Beat.data
				}
				
				let data = JSON.stringify(outputData);
				window.webkit.messageHandlers.sendData.postMessage(data);
			}
		</script>
		
		<style>

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}

.red, .orange, .yellow, .green, .teal, .cyan,
.blue, .purple, .magenta, .pink, .brown, .black, .gray {
	color: none;
	background: none;
}

</style><style>

/*
MARK: -Root
*/

@font-face
{
	font-family: 'Courier Prime';
	font-weight: normal;
	src: ("Courier Prime.ttf");
}

@font-face
{
	font-family: 'Courier Prime';
	font-weight: bold;
	src: url("Courier Prime Bold.ttf");
}
@font-face
{
	font-family: 'Courier Prime';
	font-style: italic;
	src: url("Courier Prime Italic.ttf");
}
@font-face
{
	font-family: 'Courier Prime';
	font-weight: bold;
	font-style: italic;
	src: url("Courier Prime Bold Italic.ttf");
}

:root{
	--fixedHeight: 14px;
	--fontSizeFactor: 1.2;
	--heightFactor: 1;

	--baseFontSize: 12px;
		
	--showSceneNum: none;
	--showPageNum: none;
	--showSceneLength: none;

	--columnWidth: 100px; /*initial value*/ /*PURGE?*/
	
	--putPopupHereX: 0;
	--putPopupHereY: 0;

	--indexCardHeight: 60px;

	--indexReferenceForHeight: auto;
	--pageBackground: #555;
	--hslPageBackground: 0, 0%, 33%;

	--menu-background: rgb(240, 240, 240); /*was 232*/
	--menu-border-color: #c1c1c1;
	--menu-color: rgb(233,233,233);
	--menu-hover-color: #027aff;

	--wider-width: 4;

	--colorTransparency: 100%;

	--inkOnPaper: 0, 0%, 0%;
	--paperBehindInk: 0, 0%, 100%;

	
	
}

:root, 
html[data-theme='FTOutliner']{

	--indexCardHeight: 140px;

	--yellow: 60, 70%, 70%; 
	--red: 0, 70%, 70%; 
	--green: 120, 70%, 70%; 
	--blue: 220, 70%, 70%; 
	--cyan: 180, 70%, 70%; 
	--magenta: 320, 70%, 70%; 
	--orange: 30, 70%, 70%; 
	--purple: 260, 70%, 70%; 
	--pink: 340, 70%, 85%; 
	--brown: 32, 30%, 70%; 
	--teal: 205,70%,70%;
	--gray: 0, 0%, 80%;
	--black: 0, 0%, 40%;
	--white: 0, 0%, 100%; 
	--special: rgba(0,0,0,0);

}

html[data-theme='Beat']{

	--yellow: 49, 100%, 50%;
	--red: 342, 100%, 47%;
	--green: 153, 100%, 44%;
	--blue: 208, 100%, 47%;
	--cyan: 192, 94%, 48%;
	--magenta: 324, 100%, 46%;
	--orange: 37, 100%, 53%;
	--purple: 288, 74%, 49%;
	--pink: 325, 93%, 71%;
	--brown: 37, 92%, 35%;
	--teal: 181, 90%, 47%;
	--gray: 0, 0%, 59%;
	--black: 0, 0%, 16%;
	--white: 0, 0%, 100%;
	--special: rgba(0,0,0,0);

	--pageBackground: #222;
	--hslPageBackground: 0, 0%, 13%;
	
	--act-length-opacity: 60%;

}

* {
	white-space: nowrap;
	overscroll-behavior-y: none;
	scroll-behavior: smooth !important;
	box-sizing: border-box;
}

html, body {
	/* background-color: var(--pageBackground) !important; */
	height: 100% !important;
	padding: 0px !important;

}

body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
	background-color: var(--pageBackground) !important;
	overflow: hidden !important;
}


body:has(.drag) * {

	cursor: move !important
}

body:has(.wait) * {

	cursor: wait !important;

}

.positionRelative {
	position: relative !important;
}

.displayNone {
	display: none !important
}

/*
MARK: -FlexiContainer 
*/
______FLEXICONTAINER{}

#flexiContainer{

	display: flex;

	flex-direction: row !important;
	flex-wrap: nowrap !important;

	align-items: flex-start !important;
	justify-content: space-evenly;

	width: 100%;
	height: calc(100% - 50px) !important;
	padding: 10px 5px 0px 5px !important;

	overflow-y: scroll;
	overflow-x: hidden;

	transition: width 0.4s, margin-left 0.4s, padding-right 0.2s, height 0.2s; /* padding used for page-numbers */

	--flexiScroll: 0px;

}

#flexiContainer.horizontal{

	border: 10px solid red !important;

	display: flex;

	flex-direction: column !important;
	flex-wrap: nowrap !important;

	align-items: flex-start !important;
	height: auto !important;
	overflow: scroll !important;
}

body:has(.horizontal){
	overflow: scroll !important;
}

#flexiContainer.horizontal .level1{

rotate: -90deg;

}

#flexiContainer.horizontal .section:not(.level1){

	rotate: 80deg;

}

#flexiContainer.red,
#flexiContainer.orange,
#flexiContainer.yellow,
#flexiContainer.green,
#flexiContainer.teal,
#flexiContainer.cyan,
#flexiContainer.blue,
#flexiContainer.purple,
#flexiContainer.magenta,
#flexiContainer.pink,
#flexiContainer.brown,
#flexiContainer.gray,
#flexiContainer.white {
	background: transparent !important;
}


#flexiContainer::-webkit-scrollbar{
	display: none;
}

/*
MARK: -Basic Elements
*/
__________BASIC ELEMENTS{}

.section {

	--localColor: #bbb;

	position: relative;

	margin-top: 2px; 
	margin-left: 6px;
    padding: 0px;
	
	font-size: calc(12px * var(--fontSizeFactor)); 
	font-weight: bold; 
	line-height: calc(17px * var(--fontSizeFactor)); 
	
	border-left: 3px solid var(--localColor); 
	border-radius: 3px 0px 0px 4px;
	background-color: none;
	
    flex-grow: 1;
	flex-basis: 0;
	min-width: 0px; /*without this, flex-boxes with long titles will get wider than those with short titles*/

	pointer-events: none; /*testing if this breaks somethgin*/

	transition: flex-grow 0.2s ease-out !important;
}

.section-heading {
	
	height: calc(17px * var(--fontSizeFactor));
	margin: 0px;
	margin-bottom: 2px;

	font-size: calc(12px * var(--fontSizeFactor)); 
	font-weight: bold; 
	line-height: calc(17px * var(--fontSizeFactor)); 
	text-align: left;

	text-transform: uppercase;
	
	pointer-events: all;

	background-color: #bbb;
	color: black;
    border: none;
	padding-left: 5px;
	padding-right: 3px;
	width: 100%;

	overflow: hidden;
	text-overflow: ellipsis;

	transition: font-size 0.1s, line-height 0.1s, height 0.1s, margin 0.2s;
}

.level1 {
	color: #ccc !important;
	position: relative !important;
	
	background-image: none !important;
	background-color: none !important;
	border: 0px none !important; 

	overflow: visible !important;

	margin-left: 5px !important;
	margin-right: 5px !important;
	margin-bottom: 8px !important;

	flex-grow: 1 !important;
	flex-basis: 0 !important;
	min-width: 0px !important;

}

.level1 > .section-heading {

	background-color: var(--special) !important;
	color: white; 

	text-align: center;

}

.faux:has( + .level1):not(:has(.scene, .section)){

	flex-grow: 0 !important; 
	flex-basis: 20px !important;

}

.scene, .orphanText{

	position: relative;
	/* container-name: scene;
	container-type: size; */
	overflow: visible;
	
	/* setting margin-top programmatically due to allowing space for orphan material */
	margin-top: 1px;
	margin-top: 0px;
    margin-right: 8px;
	margin-left: 6px;
	margin-bottom: 0px;

	padding-left: 0px;
	
	text-align: left;
	font-size: calc(10px * var(--fontSizeFactor)); 
	font-weight: normal;
	line-height: calc(14px * var(--fontSizeFactor));
	
	border: none; 
	border: 0.5px solid rgba(0, 0, 0, 0.35);
	border-radius: 3px;	
	
	color: #000;
	background-color: var(--localColor);
    
    flex-grow: 1;
	flex-basis: 0;
    min-width: 0px;

	pointer-events: all;

	box-shadow: 0 1rem 2rem hsl(0 0% 0% / 20%),
				inset 0.5px 0.5px 0 0px rgba(255, 255, 255, 0.3),
				inset -0.5px -0.5px 0 0px rgba(0, 0, 0, 0.3); 
	transition: height 0.1s, width 0.2s;

	height: calc(var(--flexibleHeight) * var(--heightFactor));

}

#flexiContainer.nonProportionalMode .isExpanded > .scene{

	height: calc(var(--fixedHeight) * var(--fontSizeFactor) + 1px) !important;

	/* padding-top: 1px;
	padding-bottom: 1px; */

}

.sceneheading {

	margin-left: 0px;
	margin-top: -1px;

	padding-left: 6px;
	padding-right: 4px;
	padding-top: 0px;
	padding-bottom: 0px;

	height: inherit;
	max-height: calc(14px * var(--fontSizeFactor));
	

	color: black;

	overflow: hidden;
	text-overflow: ellipsis;

	transition: opacity 0.2s;

}

.slugtext {
	pointer-events: none;
}

.orphanText{

	position: relative;
	display: block;

	border: none;

	background: transparent;
	box-shadow: none;

	background: 	repeating-linear-gradient(
			-45deg,
			transparent 0px,
			transparent 3px,
			rgba(255,255,255,0.1) 3px,
			rgba(255,255,255,0.1) 6px)
	;
}

.orphanText:hover{
	background: 	/*repeating-linear-gradient(
			-45deg,
			transparent 0px,
			transparent 3px,
			rgba(255,255,255,0.1) 3px,
			rgba(255,255,255,0.1) 6px)
			,*/
			rgba(0, 0, 0, 0.3)
			;
	border: 0px !important;
	transition: border 50ms ;
}

.nonProportionalMode:not(.indexcards) .orphanText:not(.showSynopsisInScenes .orphanText:has(.synopsis)){
	display: none;
	height: 0px;
}

.nonProportionalMode.showSynopsisInScenes .synopsiscontainer,
.nonProportionalMode.showSynopsisInScenes .orphanText:has(.synopsis){
	height: auto !important;
}

.synopsiscontainer{
	display: none;
	margin: 0 !important;
	min-height: 0 !important;

	overflow-x: hidden !important;
	overflow-y: auto !important;

	pointer-events: all;
	
}

.synopsis,
.inSynopse.editBox{

	font-size: calc(10px * var(--fontSizeFactor)); 
	font-weight: normal;
	line-height: calc(15px * var(--fontSizeFactor));

	white-space: normal;

	margin-top: 0px;
	margin-bottom: 0;
	padding-top: 0;
	padding-bottom: 0;

	color: black;
	background-color: var(--localSynopsisColor);
}

.synopsis {

	position: relative;
	display: block;

	text-align: left;

	/* opacity: 0.8; */

	/* padding-top: calc(2px * var(--fontSizeFactor)); */
	padding-left: 16px;
	padding-right: 6px;
	margin-left: 4px;
	width: calc(100% - 8px);

	border-radius: 3px;

	-webkit-user-select: auto;
	user-select: auto;
	
}

.level1 > .synopsiscontainer > .synopsis,
.level1 > .orphanText > .synopsiscontainer > .synopsis,
#flexiContainer:not(.indexcards) .section > .synopsiscontainer > .synopsis,
#flexiContainer:not(.indexcards) .section > .orphanText > .synopsiscontainer > .synopsis{

	background-color: var(--localSynopsisColor, rgba(255,255,255,0.0));

}

.synopsis::before {
	position: absolute;
	content: "•";
	font-size: calc(22px * var(--fontSizeFactor));
	line-height: calc(0px * var(--fontSizeFactor));
	margin-left: -11px;
	margin-left: -15px;
	margin-top: calc(5.5px * var(--fontSizeFactor));
	height: calc(4px * var(--fontSizeFactor));
	width: calc(4px * var(--fontSizeFactor));
	border-radius: 50%;
	color: inherit !important;

}

/*synopsis on document background*/
.section > .orphanText > .synopsiscontainer > .synopsis:not(.indexcards .section > .orphanText > .synopsiscontainer > .synopsis),
.section > .synopsiscontainer > .synopsis:not(.indexcards .section > .synopsiscontainer > .synopsis){

	--localColor: rgba(0,0,0,0.2);
	
	color: white;
	
}

.synopsis.isSelected,
.synopsis.isSelected:hover {

	color: white !important;
	background-image: linear-gradient(black 0%, black 100%) !important;

}

/*
MARK: -Scrollbar Fix
*/
______SCROLLBAR FIX FOR ALWAYS OS SETTING {}

/* .synopsiscontainer::-webkit-scrollbar{
	
	background-color: inherit !important;
	width: 8px !important; 
	height: 8px !important; 
} 

.synopsiscontainer:hover::-webkit-scrollbar-thumb{
	
	background-color: rgba(0, 0, 0, 0.5) !important;
	
	border-radius: 30px;

}  */
/* .synopsiscontainer::-webkit-scrollbar-thumb{color: black !important}  */

/*.synopsiscontainer::-webkit-scrollbar {

	/* -webkit-overflow-scrolling: auto !important; */

    /* -webkit-appearance: none;
    width: 0;
    height: 0; 
}*/

/*
MARK: -Dual Lines
*/
__________ DUAL LINES{}

#flexiContainer:not(.indexcards) .isExpanded > .scene:has(.isBeingEdited),
#flexiContainer.nonProportionalMode:not(.indexcards).dualSceneLines .isExpanded > .scene{

	height: auto !important;
	transition: height 0.1s, width 0.2s !important;

}

#flexiContainer:not(.indexcards) .section:not(.level1):has( > .isBeingEdited){

	--localColor: black !important;
	border-color: black;

}

.isBeingEdited.section-heading,
.isBeingEdited.sceneheading,
#flexiContainer.dualSectionLines .section-heading,
#flexiContainer.dualSceneLines .sceneheading{

	line-height: calc(14px * var(--fontSizeFactor)) !important;
	height: auto;
	max-height: 100% !important;
	white-space: normal !important;
	word-wrap:break-word;

	transition: max-height 0.1s, height 0.1s, width 0.2s !important;

}

#flexiContainer.dualSectionLines .section-heading,
.isBeingEdited.section-heading{

	min-height: calc(17px * var(--fontSizeFactor)) !important;
	padding-top: 2px;
	padding-bottom: 1px;

}


.section:has( > .isBeingEdited) .showSectionPageNumber{

	display: none
}

#flexiContainer.allowLowerCaseSections .section-heading,
#flexiContainer.allowLowerCaseSections .inSection.editBox{

	text-transform: none !important;

}

/*
MARK: -Graphic Stuff
*/
#---------------GRAPHIC STUFF{}
	
.clickThru{
	pointer-events: none !important;
	}

.showActLength{
	display: var(--showPageNum);
		
	font-weight: bold;
	/* font-size: calc(8px * var(--fontSizeFactor)) !important; */
	background-color: #fff;
	color: #555;
	height: calc(15px * var(--fontSizeFactor)) !important;
	font-size: calc(10px * var(--fontSizeFactor)) !important;
	line-height: calc(15px * var(--fontSizeFactor));
		
	position: absolute !important;
	float: right !important;
	right: 8px !important;
	bottom: calc(-18px * var(--fontSizeFactor)) !important;/*-18px !important; */
		
	opacity: var(--act-length-opacity, 35%) !important;
	border-radius: calc(10px * var(--fontSizeFactor)) !important;
	margin-top: 0px !important;
	padding: 0px 3px 0px 4px;
	pointer-events: all !important;
	}

.showActLength:hover{
    opacity: 55% !important;
	opacity: calc(var(--act-length-opacity, 35%) * 1.5) !important;

}

.faux:has( + .level1):not(:has(.scene, .section)) .showActLength{

	display: none;
}

/*
MARK: -OK: Page Breaks
*/
__________PAGE BREAK REREPRESENTATIONS{}

#flexiContainer:not(.indexcards):not(.nonProportionalMode) .blankPage {

	position: absolute !important;
	left: -0.5px !important;
	width: calc(100% + 1px) !important;

	border-top: 10px transparent !important; /* prepare space for cogs */
	background-image: linear-gradient(transparent, transparent),
					linear-gradient(to bottom right, 
						transparent 50.5%, 
						var(--pageBackground) 50.5%), 
					linear-gradient(to bottom left, 
						transparent 50.5%, 
						var(--pageBackground) 50.5%),
					linear-gradient(var(--pageBackground),var(--pageBackground));
	background-repeat: repeat, repeat-x, repeat-x, repeat-x;
	background-position: 0 0, 5px 0, 5px 0, 0 5px;
	background-size: auto auto, 5px 5px, 5px 5px;
	background-clip: padding-box, border-box, border-box; /* trim the edges of the overall fill */
	
	background-origin: padding-box, border-box, border-box, border-box, border-box; /* position the teeth relative to the upper border, and the background relative to the inner margin */
		
}

/* #flexiContainer.showPageDividers{

	padding-right: 10px !important;

} */

#flexiContainer.showPageDividers:not(.indexcards, .nonProportionalMode) :is(.scene, .orphanText){
/* #flexiContainer.showPageDividers.always:not(.indexcards, .nonProportionalMode) :is(.scene, .orphanText),
#flexiContainer.showPageDividers:not(.always, .indexcards, .nonProportionalMode) .level1:hover :is(.scene, .orphanText){ */

	margin-right: calc(2px + (10px * var(--fontSizeFactor))) !important;
	transition: height 0.1s, width 0.2s, margin 0.2s;

}

#flexiContainer.showPageDividers:not(.indexcards, .nonProportionalMode) .level1{

	/* background-color: teal; */
	pointer-events: all !important;

}

#flexiContainer.showPageDividers:not(.indexcards, .nonProportionalMode) .level1:hover{

	/* background-color: hotpink; */
}

.pageDivider,
.pageDivider::after{


	color: var(--pageDividerColor);
	border-color: var(--pageDividerColor);
	
	
	
}

.pageDivider {

	transition: font-size 0.2s, width 0.2s, right 0.2s;
	transition-delay: color 500ms, border-color 0.5s !important;

	--pageDividerColor: rgba(255,255,255,0);

	display: none;

	position: absolute;
	right: calc(-10px - (10px * var(--fontSizeFactor)));
	width: calc(10px + (10px * var(--fontSizeFactor)));
	height: auto;

	/* border-top: 2px solid transparent;
	border-left: 3px solid var(--pageBackground);
	border-right: 3px solid var(--pageBackground);
	border-bottom: 2px solid transparent; */
	
	opacity: 0.6;

	font-size: calc(8px * var(--fontSizeFactor));
	line-height: calc(8px * var(--fontSizeFactor));
	text-align: right !important;
	/* padding-right: calc(100% + 20px); */

	z-index: 1000;
	pointer-events: all;

}

#flexiContainer.showPageDividers:not(.indexcards):not(.nonProportionalMode) .pageDivider{

	display: inline-block; /* to enable transitions, it is displayed but transparent until...*/

}

#flexiContainer.showPageDividers:not(.indexcards):not(.nonProportionalMode) .level1 .pageDivider{
/* #flexiContainer.showPageDividers.always:not(.indexcards):not(.nonProportionalMode) .level1 .pageDivider,
#flexiContainer.showPageDividers:not(.indexcards):not(.nonProportionalMode) .level1:hover .pageDivider{ */

	--pageDividerColor: rgba(255,255,255,1); /*and now we set the color to visible*/
	
}

 .pageDivider::after{

	position: absolute;
	top: -1px;
	right: 0;
	
	content: " ";
	
	width: calc(10px + (10px * var(--fontSizeFactor)));
	height: 100%;
	background-color: transparent;

	border-top: 1px dotted var(--pageDividerColor);
	/*border-top-color: inherit !important;  */

	/* pointer-events: none !important; */

	z-index: -1000 !important;

} 

.pageDivider:hover{
	
	opacity: 1 !important;
	text-shadow: 0 0 1px --pageDividerColor
	/* font-weight: bold; */
	
}

.pageDivider:hover::after{

	/* border-color: rgba(255,255,255,1) !important; */

	/* background-color: rgba(0,0,0,0.8) */
	width: inherit !important;

	/* border-width: 3px !important; */
	/*transition: width 0.2s;
	pointer-events: none; */

}

.scene:has(.pageDivider:hover){

	background-image: transparent !important;

}

/*
MARK: -OK: Wider Acts
*/
__________WIDER ACTS{}

.wider {

    flex-grow: var(--wider-width) !important;

}

.widerButton,
.widerButtonOn {
	display: none
}

.widerButtonOn {
	transform: scale(0.8)
}

.level1:not(.wider) > .section-heading:hover > .widerButton, 
.level1.wider > .section-heading > .widerButtonOn {

	display: unset;
	position: absolute;
	margin-right: 0px; 
	margin-top: 2px;
	/* right: 0px; */
	left: 0px;

	height: calc(12px * var(--fontSizeFactor));
	width: 30px;
	border-radius: 1000px;
	fill: white;

	opacity: 0.4;

}

.widerButton:hover,
.widerButtonOn:hover{
	opacity: 1 !important;
}

/*
MARK: -Expand Collapsed (Fixed View)
*/
__________COLLAPSED IN FIXED VIEW{}

.nonProportionalMode:not(.indexcards) .arrowForIndexCards{

	display: block;
	color: #999 !important;
	opacity: 1 !important;
	transform: translateY(calc(-14px * var(--fontSizeFactor)));
	
}

.nonProportionalMode:not(.indexcards) .section:not(.isExpanded){
	
	border-radius: 3px 0 0 3px !important;
	padding-top: 0px !important;
	padding-bottom: 0px !important;
	
}

.nonProportionalMode:not(.indexcards) .section:not(.isExpanded) > .section-heading{

	margin-bottom: 0px !important;

}

.nonProportionalMode:not(.indexcards) .scene > .arrowForIndexCards::before{

	line-height: calc(12px * var(--fontSizeFactor)) !important; 
	left: -14px !important;
	transform: scale(0.7);
}

.nonProportionalMode:not(.indexcards) .isExpanded > .scene > .arrowForIndexCards::before{

	transform: rotate(90deg) scale(0.7) translateY(9px) !important;
	top: -2px !important;

}

.nonProportionalMode:not(.indexcards) .section:not(.isExpanded) > .scene{

	height: 0px !important;
	margin: 1px !important;
	/* margin-top: 1px !important; *//*REMMED OUT 2023-08*/
	min-height: 0px !important;
	border: none !important;

}

.nonProportionalMode:not(.indexcards) .level1 > .section > .section > .scene > .arrowForIndexCards::before{
	left: -23px !important
}
.nonProportionalMode:not(.indexcards) .level1 > .section > .section > .section > .scene > .arrowForIndexCards::before{
	left: -32px !important
}
	.nonProportionalMode:not(.indexcards) .level1 > .section > .section > .section > .section > .scene > .arrowForIndexCards::before{
	left: -41px !important
}
	.nonProportionalMode:not(.indexcards) .level1 > .section > .section > .section > .section > .section > .scene > .arrowForIndexCards::before{
	left: -50px !important
}

.arrowForIndexCards:hover::before{
	color: white !important;
	transform: inherit, scale(1.2) !important;
}

/*
MARK: -FIX THIS PRONTO!
*/
	#-------------{}
	#------OLD{}
	#---------{}

	
.indexcards .isOmitted > .synopsiscontainer,
.isOmitted:not(.sceneheading):not(.synopsis) {
	background:
			linear-gradient(
				to right,
				hsla(var(--hslPageBackground), 20%) 0%,
				hsla(var(--hslPageBackground), 20%) 12px,
				hsla(var(--hslPageBackground), 70%) 12px,
				hsla(var(--hslPageBackground), 70%) 100%)
			, 	
			repeating-linear-gradient(
			-45deg,
			hsla(var(--hslPageBackground), 30%) 0px,
			hsla(var(--hslPageBackground), 30%) 3px, 
			/* rgba(0,0,0,.3) 0px,
			rgba(0,0,0,.3) 3px,  */
			rgba(255,255,255,0.2) 3px,
			rgba(255,255,255,0.2) 6px)
			/* , */
	/* rgba(221, 221, 221, 1) */, var(--localColor)
	;
	/* color: rgba(0,0,0,0.9); */

	font-style: italic;
	margin-left: 16px;

	--colorTransparency: 80%;
}

.synopsis.isOmitted{

	background:
			/* linear-gradient(
				to right,
				hsla(var(--hslPageBackground), 20%) 0%,
				hsla(var(--hslPageBackground), 20%) 12px,
				hsla(var(--hslPageBackground), 70%) 12px,
				hsla(var(--hslPageBackground), 70%) 100%)
			, 	 */
			repeating-linear-gradient(
			-45deg,
			hsla(var(--hslPageBackground), 30%) 0px,
			hsla(var(--hslPageBackground), 30%) 3px, 
			/* rgba(0,0,0,.3) 0px,
			rgba(0,0,0,.3) 3px,  */
			rgba(255,255,255,0.2) 3px,
			rgba(255,255,255,0.2) 6px)
			/* , */
	;

	/* font-style: italic; */
	opacity: 0.6;
	--colorTransparency: 80%;

}

:not(.indexcards) .isExpanded > .isOmitted.scene > .arrowForIndexCards{

	margin-left: -10px !important;

}

.isOmitted > .sceneheading
/* .isOmitted > .synopsiscontainer > .synopsis */
{

	opacity: 70%;
	background: none !important;
	background-image: none !important;
	background-color: transparent !important;
	padding-left: 18px !important;
}

.isOmitted > .synopsiscontainer > .synopsis {

	padding-left: 16px !important;
	margin-left: 16px !important;
	opacity: 70%;
}

.omittedScenesAreHidden {
	display: none;
}

#flexiContainer:not(.nonProportionalMode):not(.indexcards) .isOmitted {
	display: none;
}

.showSceneNum{
	display: var(--showSceneNum);
	font-weight: bold;
	opacity: 45%;
	float: left;

	pointer-events: none;
	}

.isOmitted .showSceneNum{
	color: rgba(0, 0, 0, 0.9) !important;
	opacity: 90% !important;
	font-weight: bold !important;
	font-size: calc(8px * var(--fontSizeFactor)) !important;
	line-height: calc(10px * var(--fontSizeFactor)) !important;
	background-color: rgba(255,255,255,0.8);
	border-radius: calc(5px * var(--fontSizeFactor));
	padding-left: 3px !important;
	margin-right: 5px !important;
	/* padding-top: 0;
	padding-bottom: 0px; */
	font-style: normal !important;

	margin-top: calc(2px * var(--fontSizeFactor));
	height: calc(10px * var(--fontSizeFactor));
}

.showSceneLength{
	display: var(--showSceneLength);
	
	font-weight: bold;
	font-size: calc(8px * var(--fontSizeFactor)) !important;

	float: right !important;
	
	opacity: 45% !important;
	margin-top: 0px !important;
	margin-left: 0px !important;

	padding: 0px 4px 0px 4px !important;

	pointer-events: none;

}

.isOmitted .showSceneLength{
	display: none;
}

p >.clear{

	float: none;

	margin-top: 40px !important;
	max-width: 100% !important;
	overflow: hidden !important;
}

.sectionInfoDiv {

	float: right;
	white-space: nowrap;
}

/* #flexiContainer.dualSectionLines .sectionInfoDiv{

	white-space: normal !important;
	height: inherit !important;
	outline: 1px dotted red

} */

.showSectionPageNumber,
.sectionLengths{

	display: var(--showPageNum);
	
	color: inherit;
	font-weight: normal;
	font-size: calc(8px * var(--fontSizeFactor)) !important;

	text-transform: none !important;
	
	/* float: right !important; */
	text-align: right !important;
	right: 0px !important;
	
	opacity: 45% !important; 
	border-radius: 6px;
	margin-top: calc(1px * var(--fontSizeFactor) - 1) !important;
	padding: 0px 0px 0px 4px;

	height: auto; 
	margin-bottom: calc(-5px * var(--fontSizeFactor));
	pointer-events: none !important;

	text-align: right;

}

.sectionLengths {

	font-weight: normal;

	display: none;
	padding-left: 0 !important;
	padding-right: 0 !important;

	height: auto;
	overflow: visible;

}

/*#flexiContainer:not(.dualSectionLines)*/ .sectionLengths br {
	display: none;
}

#flexiContainer.showLengthsInSections .sectionLengths{

	display: inline;

}

#flexiContainer.showLengthsInSections .showSectionPageNumber{

	font-weight: bold;

}

.expandedNote .showSectionPageNumber{
	display: none
}

	
.text-shift {
	line-height: calc(17px * var(--fontSizeFactor)) !important;
	position: relative !important;
	top: calc(-2px * var(--fontSizeFactor)) !important;
}

/*
MARK: -OK: Colors
*/
________COLORS{}

/*.synopsis*/ /*will get its color from --localSynopsisColor instead*/ 
.scene,
.scene > .synopsiscontainer,
.section:not(.level1) > .section-heading,
.indexcards .section:not(.level1) > .synopsiscontainer,
.indexcards .section:not(.level1) > .orphanText > .synopsiscontainer{

	background-color: var(--localColor);

}

.section.special:not(.level1) > .section-heading,
/* .indexcards .scene.special > .synopsiscontainer, */
.indexcards .section.special:not(.level1) > .synopsiscontainer,
.indexcards .section.special:not(.level1) > .orphanText > .synopsiscontainer{

	background-color: var(--special);
	text-align: center;

	background-image: none;
	border-bottom: none;

}

.section:not(.level1, .special){

	border-color: var(--localColor)

}

.section.special:not(.level1) {

	background-image: none;
	border-color: var(--special) !important; 
	color: hsl(0deg, 0%, 75%) !important; 
	text-align: center;

}

.section.special:not(.level1) > .section-heading{

	background-image: none;
	border-color: var(--special) !important; 
	color: hsl(0deg, 0%, 95%) !important; 
	text-align: center;

}

/*ONE TO REPLACE THEM ALL?*/
.uncolorAllScenesBut.red .scene:not(.red), 
.uncolorAllScenesBut.yellow .scene:not(.yellow),
.uncolorAllScenesBut.orange .scene:not(.orange),
.uncolorAllScenesBut.green .scene:not(.green), 
.uncolorAllScenesBut.teal .scene:not(.teal),
.uncolorAllScenesBut.cyan .scene:not(.cyan),
.uncolorAllScenesBut.blue .scene:not(.blue),
.uncolorAllScenesBut.purple .scene:not(.purple),
.uncolorAllScenesBut.magenta .scene:not(.magenta),
.uncolorAllScenesBut.pink .scene:not(.pink),
.uncolorAllScenesBut.brown .scene:not(.brown),
.uncolorAllScenesBut.gray .scene:not(.gray),
.uncolorAllScenesBut.white .scene:not(.white),
.uncolorAllScenesBut.black .scene:not(.black),

.uncolorAllScenesBut.red .section:not(.red) > .section-heading, 
.uncolorAllScenesBut.yellow .section:not(.yellow) > .section-heading,
.uncolorAllScenesBut.orange .section:not(.orange) > .section-heading,
.uncolorAllScenesBut.green .section:not(.green) > .section-heading, 
.uncolorAllScenesBut.teal .section:not(.teal) > .section-heading,
.uncolorAllScenesBut.cyan .section:not(.cyan) > .section-heading,
.uncolorAllScenesBut.blue .section:not(.blue) > .section-heading,
.uncolorAllScenesBut.purple .section:not(.purple) > .section-heading,
.uncolorAllScenesBut.magenta .section:not(.magenta) > .section-heading,
.uncolorAllScenesBut.pink .section:not(.pink) > .section-heading,
.uncolorAllScenesBut.brown .section:not(.brown) > .section-heading,
.uncolorAllScenesBut.gray .section:not(.gray) > .section-heading,
.uncolorAllScenesBut.white .section:not(.white) > .section-heading,
.uncolorAllScenesBut.black .section:not(.black) > .section-heading,

.uncolorAllScenesBut.red .synopsiscontainer:not(.red), 
.uncolorAllScenesBut.yellow .synopsiscontainer:not(.yellow),
.uncolorAllScenesBut.orange .synopsiscontainer:not(.orange),
.uncolorAllScenesBut.green .synopsiscontainer:not(.green), 
.uncolorAllScenesBut.teal .synopsiscontainer:not(.teal),
.uncolorAllScenesBut.cyan .synopsiscontainer:not(.cyan),
.uncolorAllScenesBut.blue .synopsiscontainer:not(.blue),
.uncolorAllScenesBut.purple .synopsiscontainer:not(.purple),
.uncolorAllScenesBut.magenta .synopsiscontainer:not(.magenta),
.uncolorAllScenesBut.pink .synopsiscontainer:not(.pink),
.uncolorAllScenesBut.brown .synopsiscontainer:not(.brown),
.uncolorAllScenesBut.gray .synopsiscontainer:not(.gray),
.uncolorAllScenesBut.white .synopsiscontainer:not(.white),
.uncolorAllScenesBut.black .synopsiscontainer:not(.black),

.scene.dimmedScene, 
.scene.toBeDeleted,

.dimmedSection > .section-heading,
.dimmedSection > .synopsiscontainer,

.section.dimmedScene > .section-heading,
.section.toBeDeleted > .section-heading,
.section.dimmedScene > .orphanText > .displayNumberOf
.section.toBeDeleted > .orphanText > .displayNumberOf
{

	opacity: 0.15 !important

}

	.uncolorAllScenesBut.red .scene:not(.red), 
	.uncolorAllScenesBut.yellow .scene:not(.yellow),
	.uncolorAllScenesBut.orange .scene:not(.orange),
	.uncolorAllScenesBut.green .scene:not(.green), 
	.uncolorAllScenesBut.teal .scene:not(.teal),
	.uncolorAllScenesBut.cyan .scene:not(.cyan),
	.uncolorAllScenesBut.blue .scene:not(.blue),
	.uncolorAllScenesBut.purple .scene:not(.purple),
	.uncolorAllScenesBut.magenta .scene:not(.magenta),
	.uncolorAllScenesBut.pink .scene:not(.pink),
	.uncolorAllScenesBut.brown .scene:not(.brown),
	.uncolorAllScenesBut.gray .scene:not(.gray),
	.uncolorAllScenesBut.white .scene:not(.white),
	.uncolorAllScenesBut.black .scene:not(.black),

	.uncolorAllScenesBut.red .sceneheading:not(.red), 
	.uncolorAllScenesBut.yellow .sceneheading:not(.yellow),
	.uncolorAllScenesBut.orange .sceneheading:not(.orange),
	.uncolorAllScenesBut.green .sceneheading:not(.green), 
	.uncolorAllScenesBut.teal .sceneheading:not(.teal),
	.uncolorAllScenesBut.cyan .sceneheading:not(.cyan),
	.uncolorAllScenesBut.blue .sceneheading:not(.blue),
	.uncolorAllScenesBut.purple .sceneheading:not(.purple),
	.uncolorAllScenesBut.magenta .sceneheading:not(.magenta),
	.uncolorAllScenesBut.pink .sceneheading:not(.pink),
	.uncolorAllScenesBut.brown .sceneheading:not(.brown),
	.uncolorAllScenesBut.gray .sceneheading:not(.gray),
	.uncolorAllScenesBut.white .sceneheading:not(.white),
	.uncolorAllScenesBut.black .sceneheading:not(.black),

	/*.uncolorAllScenesBut.red .section-heading:not(.red):not(.level1 > .section-heading):not(.special), 
	.uncolorAllScenesBut.yellow .section-heading:not(.yellow):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.orange .section-heading:not(.orange):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.green .section-heading:not(.green):not(.level1 > .section-heading):not(.special), 
	.uncolorAllScenesBut.teal .section-heading:not(.teal):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.cyan .section-heading:not(.cyan):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.blue .section-heading:not(.blue):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.purple .section-heading:not(.purple):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.magenta .section-heading:not(.magenta):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.pink .section-heading:not(.pink):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.brown .section-heading:not(.brown):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.gray .section-heading:not(.gray):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.white .section-heading:not(.white):not(.level1 > .section-heading):not(.special),
	.uncolorAllScenesBut.black .section-heading:not(.black):not(.level1 > .section-heading):not(.special),*/

	.uncolorAllScenesBut.red .section:not(.red) /*> .section-heading*/, 
.uncolorAllScenesBut.yellow .section:not(.yellow) /*> .section-heading*/,
.uncolorAllScenesBut.orange .section:not(.orange) /*> .section-heading*/,
.uncolorAllScenesBut.green .section:not(.green) /*> .section-heading*/,
.uncolorAllScenesBut.teal .section:not(.teal) /*> .section-heading*/,
.uncolorAllScenesBut.cyan .section:not(.cyan) /*> .section-heading*/,
.uncolorAllScenesBut.blue .section:not(.blue) /*> .section-heading*/,
.uncolorAllScenesBut.purple .section:not(.purple) /*> .section-heading*/,
.uncolorAllScenesBut.magenta .section:not(.magenta) /*> .section-heading*/,
.uncolorAllScenesBut.pink .section:not(.pink) /*> .section-heading*/,
.uncolorAllScenesBut.brown .section:not(.brown) /*> .section-heading*/,
.uncolorAllScenesBut.gray .section:not(.gray) /*> .section-heading*/,
.uncolorAllScenesBut.white .section:not(.white) /*> .section-heading*/,
.uncolorAllScenesBut.black .section:not(.black) /*> .section-heading*/,
	
	.uncolorAllScenesBut.red .synopsiscontainer:not(.red), 
	.uncolorAllScenesBut.yellow .synopsiscontainer:not(.yellow),
	.uncolorAllScenesBut.orange .synopsiscontainer:not(.orange),
	.uncolorAllScenesBut.green .synopsiscontainer:not(.green), 
	.uncolorAllScenesBut.teal .synopsiscontainer:not(.teal),
	.uncolorAllScenesBut.cyan .synopsiscontainer:not(.cyan),
	.uncolorAllScenesBut.blue .synopsiscontainer:not(.blue),
	.uncolorAllScenesBut.purple .synopsiscontainer:not(.purple),
	.uncolorAllScenesBut.magenta .synopsiscontainer:not(.magenta),
	.uncolorAllScenesBut.pink .synopsiscontainer:not(.pink),
	.uncolorAllScenesBut.brown .synopsiscontainer:not(.brown),
	.uncolorAllScenesBut.gray .synopsiscontainer:not(.gray),
	.uncolorAllScenesBut.white .synopsiscontainer:not(.white),
	.uncolorAllScenesBut.black .synopsiscontainer:not(.black),

	.uncolorAllScenesBut.red .synopsiscontainer:not(.red) > .synopsis:not(.red), 
	.uncolorAllScenesBut.yellow .synopsiscontainer:not(.yellow) > .synopsis:not(.yellow),
	.uncolorAllScenesBut.orange .synopsiscontainer:not(.orange) > .synopsis:not(.orange),
	.uncolorAllScenesBut.green .synopsiscontainer:not(.green) > .synopsis:not(.green), 
	.uncolorAllScenesBut.teal .synopsiscontainer:not(.teal) > .synopsis:not(.teal),
	.uncolorAllScenesBut.cyan .synopsiscontainer:not(.cyan) > .synopsis:not(.cyan),
	.uncolorAllScenesBut.blue .synopsiscontainer:not(.blue) > .synopsis:not(.blue),
	.uncolorAllScenesBut.purple .synopsiscontainer:not(.purple) > .synopsis:not(.purple),
	.uncolorAllScenesBut.magenta .synopsiscontainer:not(.magenta) > .synopsis:not(.magenta),
	.uncolorAllScenesBut.pink .synopsiscontainer:not(.pink) > .synopsis:not(.pink),
	.uncolorAllScenesBut.brown .synopsiscontainer:not(.brown) > .synopsis:not(.brown),
	.uncolorAllScenesBut.gray .synopsiscontainer:not(.gray) > .synopsis:not(.gray),
	.uncolorAllScenesBut.white .synopsiscontainer:not(.white) > .synopsis:not(.white),
	.uncolorAllScenesBut.black .synopsiscontainer:not(.black) > .synopsis:not(.black),

	.dimmedSection > .section-heading
	{

		--localColor: rgb(255,255,255) !important;

	}

	.uncolorAllScenesBut.red .section:not(.red), 
	.uncolorAllScenesBut.yellow .section:not(.yellow),
	.uncolorAllScenesBut.orange .section:not(.orange),
	.uncolorAllScenesBut.green .section:not(.green), 
	.uncolorAllScenesBut.teal .section:not(.teal),
	.uncolorAllScenesBut.cyan .section:not(.cyan),
	.uncolorAllScenesBut.blue .section:not(.blue),
	.uncolorAllScenesBut.purple .section:not(.purple),
	.uncolorAllScenesBut.magenta .section:not(.magenta),
	.uncolorAllScenesBut.pink .section:not(.pink),
	.uncolorAllScenesBut.brown .section:not(.brown),
	.uncolorAllScenesBut.gray .section:not(.gray),
	.uncolorAllScenesBut.white .section:not(.white),
	.uncolorAllScenesBut.black .section:not(.black),
	.dimmedSection
	{

		border-color: rgba(255,255,255,0.15) !important;

	}
	
REMOVE	.dimmedSection > .section-heading,
REMOVE	.dimmedSection > .synopsiscontainer,
REMOVE	.dimmedSection > .synopsis
	{

		background-image: 
			-webkit-linear-gradient(rgba(255,255,255,.1), rgba(255,255,255,0.1)),
			-webkit-linear-gradient(top, var(--pageBackground), var(--pageBackground) 100%)
		!important;
		/* background-image: transparent !important;*/
		/* background-color: transparent !important;  */

		border-color: rgba(0, 0, 0, 0.2) !important;
		box-shadow: none !important;
		color: rgba(0, 0, 0, 0.5) !important;
		/* border-color: transparent !important; */

	}

/*
MARK: -"End of Types". so now what?
*/

#----------------------- {}
#---------- END OF types {}
#----------------------- {}

.sceneTitlePopup{
	position: absolute;
	border: 1px #555 solid;
	opacity: 0;
	color: black;
	padding: 2px 4px;

	width: auto;

	font-size: calc(11px * var(--fontSizeFactor)) !important;
	overflow: hidden;
	text-overflow: ellipsis;

	background-image: -webkit-linear-gradient(top, rgba(255,255,255,0.4), rgba(255,255,255,0.4) 100%);

	transition: opacity 0.8s !important;
	z-index: 10000;
}

.revealPopup{
	-webkit-backdrop-filter: blur(2px) !important;
	backdrop-filter: blur(2px) !important;

	opacity: 0.95;
	transition: opacity 0.3s !important;
}

.sceneTitlePopup > p{
	overflow: hidden;
}

.sceneTitlePopup > .showSceneLength {
	top: 0.5px !important; 
}

#----------- INDICATOR {}
	
.indicator {
	position: absolute; 
    top:0px; 
	width: calc(100% + 30px);
	height: 1px;
	margin-left: -8px;
	border: 1px red solid;
	box-shadow:3px 3px 5px rgba(0, 0, 0, 0.2) !important;

	z-index: 9995;

	pointer-events: none;
	line-height: 14px !important;
	padding: 0px !important;

	margin-top: 0px !important;
	margin-bottom: 0px !important;
	text-align: left !important;
	font-size: 15px !important;

	}

.scene .indicator {
	left: 3px;
}

.indicator p{
	display: none ;
}

.loggingIsOn .indicator p{

	display: block !important; /*block for on*/
	float: right !important;
	padding: 1.5px 2px !important;
	height: 16px;
	width: 45px;
	background-color: red !important;
	margin-top: -8px !important;
	margin-right: -1px !important;
	text-align: right !important;
	color: white !important;
	font-size: 10px !important;
	font-weight: bold !important;

	clip-path: polygon(20% 0, 100% 0, 100% 100%, 20% 100%, 0 50%);
	border-radius: 0 4px 4px 0;

}

nope.loggingIsOn .indicator p { /*for debugging purposes only*/
	display: block !important; /*block for on*/
	float: right !important;
	padding: 0px 2px !important;
	background-color: red !important;
	margin-top: -16px !important;
	margin-right: -1px !important;
	text-align: right !important;
	color: white !important;
	font-size: 10px !important;
	font-weight: bold !important;
}
	
.indicator::before{
	padding: 0px !important;
	margin-top: 0px !important;
	margin-bottom: 0px !important;
	text-align: left !important;

	min-width: 1px !important;
	max-width: 1px !important;
	min-height: 1px !important;
	max-height: 1px !important;
	width: 1px !important;
	height: 1px !important;
	background-color: red !important;
	border: 4px red solid !important; 
	border-radius: 6px 6px 6px 6px !important;
	content: " a " !important;
	color: rgba(0,0,0,0) !important;
	overflow: hidden;

	font-size: 1px !important;
	line-height: 1px !important;

	/* position: absolute !important; */
	position: relative !important;
	/* line-height: 14px !important;
	height: 14px !important;
	content: "\26AB";
	color: red;
	font-size: 15px;
	font-weight: bold; */
	margin-left: -9px !important;
	left: 2px !important;
	/* top: calc(-7px * var(--fontSizeFactor)) !important;	 */
	top: -12.5px !important;	
	/* top: calc(calc(var(--fixedHeight) - 6px) * var(--fontSizeFactor)) !important;  */
	/* float: left; */
	}

/* 
@audit-ok The levels indicator -- done
*/ 

.level1 > .indicator{
	margin-left: -2px !important;
	width: calc(100% + 0px)
}
/* .level2 > .indicator, */
.level1 > .section > .indicator,
.level1 > .scene > .indicator{
	margin-left: -8px !important;
	width: calc(100% + 16px)
}
/* .level3 > .indicator, */
.level1 > .section > .section > .indicator,
/* .level2 > .scene > .indicator{ */
.level1 > .section > .scene > .indicator{
	margin-left: -17px !important;
	width: calc(100% + 25px)
}
/* .level4 > .indicator, */
.level1 > .section > .section > .section > .indicator,
/* .level3 > .scene > .indicator{ */
.level1 > .section > .section > .scene > .indicator{
	margin-left: -26px !important;
	width: calc(100% + 34px)
}
/* .level5 > .indicator, */
.level1 > .section > .section > .section > .section > .indicator,
/* .level4 > .scene > .indicator{ */
.level1 > .section > .section > .section > .scene > .indicator{
	margin-left: -35px !important;
	width: calc(100% + 43px)
}

/* .level6 > .indicator, */
.level1 > .section > .section > .section > .section > .section > .indicator,
/* .level5 > .scene > .indicator{ */
.level1 > .section > .section > .section > .section > .scene > .indicator{
	margin-left: -44px !important;
	width: calc(100% + 52px)
}

/* .level6 > .scene > .indicator{ */
.level1 > .section > .section > .section > .section > .section > .scene > .indicator{
	margin-left: -53px !important;
	width: calc(100% + 61px)
}


/* .section > .indicator::before{

	top: calc(-9px * var(--fontSizeFactor)) !important;

}

.level1 > .indicator::before{

	top: calc(-16px * var(--fontSizeFactor)) !important;

} */


.indicatorEnd {
	position: absolute;
    top:0px; /*new*/
	width: calc(100% + 30px);
	height: 1px;
	margin-left: -18px;
	margin-top:-14px; /* hacky way to align the indicator with top of scene */
	border: 1px red solid;
	box-shadow:3px 3px 5px rgba(0, 0, 0, 0.2) !important;

	}
	
.indicatorEnd::after{
	position: relative;
	content: "\26AB";
	color: red;
	font-size: 15px;
	font-weight: bold;
	float: right !important;
	top: -6px;
    margin-right: -9px !important;
	}
	
/* div.tooltipContent {
	height: 100% !important;
	overflow: scroll !important;
	border-bottom: 3px dotted rgba(0,0,0,0.2) !important;
	}
	
.tooltipContent>p {
	padding: 0px 10px 0px 10px !important;
	white-space: normal !important;
	font-family: "courier prime", courier, "courier new", monospace !important;
	line-height: 12px !important;
	font-size: 12px !important;
	color: black !important;
	}
	
.tooltipContent>p:hover{
	text-decoration: underline;
	display: block;
	background-color: rgba(255, 255, 255, 0.6) !important;
	}
	
.action{
	margin-top: 10px !important;	
	margin-bottom: 0px !important;
	}
	
.dialogue{
	margin-top: 0px !important;
	margin-left: 40px !important;
	margin-right: 30px !important;
	margin-bottom: 0px !important;
	}
		
.character{
	margin-top: 10px !important;
	margin-left: 80px !important;
	margin-right: 40px !important;
	margin-bottom: 0px !important;
	}
		
.parenthetical{
	margin-top: 0px !important;
	margin-left: 60px !important;
	margin-bottom: 12px !important;
	margin-bottom: 0px !important;
	}
	
.transition{
	margin-top: 10px !important;
	text-align: right;
	margin-bottom: 0px !important;
	}
	
.heading, .empty{
	display:none
	} */
	
/* p.synopse {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol" !important;
	/* font-style: italic; 
	color: rgba(0,0,0,0.8);
	margin-left: 4px !important;
	margin-right: 4px !important;
	background-color: rgba(255,255,255,0.8);
	} */
	
/* --- HOVER COMES AFTER ALL COLORS --- */

.scene:not(.noHover)/*:not(.synopsiscontainer)*/:not(.uncolorAllScenesBut .scene):not(.indexcards .scene):not(:has(.marker:hover, .synopsis:hover, .pageDivider:hover)):hover{
	background-image: -webkit-linear-gradient(top, rgba(20,20,20,0.60), rgba(20,20,20,0.60) 100%) !important;
	color: white !important;
}

.scene:not(.noHover)/*:not(.synopsiscontainer)*/:not(.uncolorAllScenesBut .scene):not(:has(.marker:hover, .synopsis:hover, .pageDivider:hover)):hover > .sceneheading{
	/* color: inherit !important; */
	color: white !important;
}

.indexcards .scene:not(.noHover):hover > .sceneheading{
	color: white !important; 
	background-color: black;
}

/* .indexcards  */
.synopsis:hover{
	background-image: -webkit-linear-gradient(top, rgba(20,20,20,0.70), rgba(20,20,20,0.70) 100%) !important;
	color: white !important; 
}

.uncolorAllScenesBut .scene:hover{
	background-image: -webkit-linear-gradient(top, rgba(20,20,20,0.0), rgba(20,20,20,0.0) 100%) !important;
	/* outline: 3px rgba(20,20,20,0.8) solid !important; */
}

.scene.isSelected{
	background-image: -webkit-linear-gradient(top, rgba(0,0,0,0.8), rgba(0,0,0,0.8) 100%) !important;	
	color: white !important;
}

.scene.isSelected > .sceneheading{
	/* background-image: -webkit-linear-gradient(top, rgba(0,0,0,0.8), rgba(0,0,0,0.8) 100%) !important;	 */
	color: white !important;
}
#flexiContainer:not(.indexcards) .scene.isSelected > .synopsiscontainer > .synopsis,
#flexiContainer:not(.indexcards) .section.isSelected > .synopsiscontainer > .synopsis {
	/* background-image: -webkit-linear-gradient(top, rgba(0,0,0,0.8), rgba(0,0,0,0.8) 100%) !important;	 */
	color: white !important;
}
	
/* .sluglineIsHidden,  */
.sluglineIsHidden > .sceneheading{
	opacity: 0 !important;
}

.animateOpacity >.sceneheading{
	transition: opacity 0.5s;
}



.sluglineIsHidden:not(:has(.marker:hover)):hover{
		background-image: -webkit-linear-gradient(top, rgba(20,20,20,0.80), rgba(20,20,20,0.80) 100%) !important;
}
	
.section:not(.level1):not(.noHover):not(:has(:hover)):hover,
.section:not(.level1):not(.noHover):has(.section-heading:hover){
	color: white !important;
	border-color: rgba(40,40,40,1) !important;
}

.section:not(.level1):not(.noHover):not(:has(:hover)):hover > .section-heading,
.section:not(.level1):not(.noHover):has(.section-heading:hover) > .section-heading{
	color: white !important;
	background-color: rgba(40,40,40,1) !important;
}

.section/*:not(.level1)*/.isSelected {
	color: white !important;
	border-color: rgba(0,0,0,0.9) !important;
}
.section/*:not(.level1)*/.isSelected > .section-heading {
	color: white !important;
	background-color: rgba(0,0,0,0.9) !important;	
}
.section.level1.isSelected > .section-heading {
	border-radius: 3px
}
#flexiContainer:not(.indexcards) .section:not(.level1).isSelected > .synopsiscontainer {
	color: white !important;
	background-color: rgba(0,0,0,0.9) !important;	
}

/* html[data-theme='Beat'] #flexicontainer:not(.uncolorAllScenesBut) .section:not(.level1):not(.noHover):hover{
	border-color: rgba(40, 40, 40, 1) !important;
	/* color: black !important */
/*} */

html[data-theme='Beat'] :not(.indexcards) .section:not(.level1):not(.noHover):has(> .section-heading:hover)/*:hover*/{
	border-color: rgba(85, 85, 85, 1) !important;
	/* color: black !important */
}

html[data-theme='Beat'] :not(.indexcards) .section:not(.level1):not(.noHover):has(> .section-heading:hover) > .section-heading{
	background-color: rgba(85, 85, 85, 1) !important;
	color: white !important
}

/*
MARK: -UI
*/

#----------------------------{}
#----------- UI -------------{}
#----------------------------{}

#buttonRow{
	position: absolute;
	bottom: 0px;
	width: 100%;
	height: 48px;
	
	/* opacity: 40%; */

	transition: 0.5s ease-out;
	transition-delay: 2s;
}

.bottomButton{
	position: fixed !important;
	bottom:12px !important;

	color: white !important;
	font-size: 48px !important;
	font-weight: 700 !important;
	text-align: center !important;
	height: 26px !important;
	width: 30px !important;
	
	/* opacity: 20% !important;  */
	z-index: 9998;

	transform: scale(0.9) !important;

	transition: 0.5s ease-out;
	transition-delay: 2s;
}

#buttonRow .bottomButton{
	opacity: 10%;

	
}


#buttonRow:hover .bottomButton{

	opacity: 30%;

	transition-delay: 0s;
	transition: opacity 0.2s ease-out;
}


.bottomButton:hover{
	opacity: 80% !important;
	transition: none;
}
	
#helpButton{
	left: 24px;
	/* right: 12px !important; */
	font-size: 36px !important; /*48px !important;*/
	line-height: 24px !important;
	}

#helpButton:hover{
	transition: 0.1s ease-out;
	transform: rotate(18deg) scale(1.05);
}

#printButton{
	left: 74px !important;
	font-size: 36px !important; /*48px !important;*/
	line-height: 24px !important;
	transform: scale(0.95);
	}

#printButton:hover{
	transition: 0.1s ease-out;
	transform: scale(1.00);
}
		
#refreshButton{
	right: 48px !important;
	font-size: 32px !important;
	line-height: 32px !important;
	}

#speedometer{
	position: absolute;
	left: 100px;
	bottom: 8px;
	height: 45px;
	width: 200px;
	padding-left: 3px;
	background: white;
	border: black 2px solid;
	border-radius: 4px;
	font-size: 10px;
	font-weight: bold;
}
 




#zoomButton{
	line-height: 22px !important;
	font-size: 24px !important;
	right: 24px !important;
	bottom: 12px !important;
	fill: white;
}

#characterButton{
	right: 74px !important;
	bottom: 14px !important;
	
	font-size: 32px !important;
	line-height: 30px !important;
	margin-top: -20px !important;
	fill: white;
}

#notesButton{
	height: 22px !important;
	right: 124px !important;
	font-size: 24px !important;
	line-height: 24px !important;
	bottom: 14px !important;
	fill: white;
}

#showStuffButton{
	right: 174px !important;
	bottom: 30px !important;
	fill: white;
}

#indexCardButton{
	right: 224px !important;
	fill: white !important;

	font-size: 32px !important;
	line-height: 34px !important;
	bottom: 15px !important;
}

#indexCardButton:hover{
	transition: 0.1s ease-out;
	transform: scale(1.1);
}

#indexCardButton svg, #indexCardButton:hover svg{
	pointer-events: all !important;
}

#characterButton:hover{
	transition: 0.1s ease-out;
	transform: scale(1.05);
}

#characterButton.buttonIsActive{

	transition: none !important;

	opacity: 100% !important;

}

/* :not(.sectionCards) ~ #indexCardBkg {
	display: none;
	opacity: 0;
	width: 30px;
	
	transition-delay: 0.5s;
	transition: width 0.5s, opacity 0.5s;
}

.sectionCards ~ #indexCardBkg {
	position: fixed;
	bottom: 8px;
	right: 100px;
	background-color: rgba(255,255,255,0.1) !important;
	width: 200px !important; 
	height: 30px !important;
	display: block !important;
	opacity: 1;
	border-radius: 4px !important;
	/ * position: absolute; * /
	/ * right: 0px !important; 
	bottom: 0px !important; * /

	transition: width 0.5s, opacity 0.5s;
} */


/* #indexCardSizeButton {
	right: 264px !important;
	opacity: 100% !important;
	bottom: 11px !important;
}

#indexCardSizeButton:not(.active) {
	display: none !important;
	border: 10px orange solid !important;
} */

.roundButton{
	/* background-color: white;
	height: 12px !important;
	width: 12px !important; */
	/* border-radius: 6px !important;
	color: black !important; */
	font-size: 12px !important;
	/* font-weight: bold !important; */
	text-align: center !important;
	height: 12px !important;

	opacity: 30% !important;
}

.roundButton:hover {
	opacity: 100% !important;
}

		
.bottomButton:hover{
	opacity: 80%!important;
	}
	
button:hover{
	color: blue !important;
	}

#speedReport{
	left: 20px !important;
	/* background-color: white;
	border-radius: 15px !important;
	color: black !important; */
	font-size: 28px !important;
    font-weight: 600 !important; /*was 800 for questionmark*/
	line-height: 26px !important;
	padding-top: 0px;

	
	/* opacity: 80% !important; */

	/*display: none; /* for development/debugging purposes only */
}

#speedReport.red{
	background-color: red !important;
	border: 4px red solid;
}

#speedReport:hover{
	transform: scale(1.02);
	transition: 0.1s ease-out;
}
	
#theDataDiv{
	width: 90%;
	height: 20px;
	border: 2px yellow solid;
	background-color: black;
	display: none; /*this was a console of sorts for verifying that settings were brought over, so now not rendering it anymore.*/
	position: absolute;
	bottom:10px;
	left: 10px;
	color: yellow;
	font-weight: 700;
	overflow: scroll;
	}
		
#outOfSyncDiv{
	position: absolute !important;
	top: 0 !important;
	left: 0 !important;
	width: 100%;
	height: 100%;
/*	background-color: rgba(85,85,85,0.4) !important;*/
	background: 	repeating-linear-gradient(
		-45deg,
		transparent,
		transparent 3px,
		#444 3px,
		#444 6px)
		/* ,#555 !important */
	;
	color: rgba(255,255,255,1) !important;
	font-size: 18px !important;
	font-weight: 700 !important;
	display: none;
	z-index: -999;	

	opacity: 0.4;
}
	
#outOfSyncDiv.animate{
	animation: barberpole 0.5s linear infinite !important;
	/* opacity: 0.4 !important; */
}

/* html[data-theme='Beat'] #outOfSyncDiv{
	opacity: 0.2;
} */
	
@keyframes barberpole {
	from { background-position: 0 0; }
	to   { background-position: 8.64px 8.64px; }
}
	
#outOfSyncDiv>p {
	width: calc(100% - 160px) !important;
	position: absolute;
	bottom: 14px;
	text-align: right;
	right: 160px;
	white-space: normal;
	line-height: 18px !important;
	opacity: 1 !important;
}

.padlockIcon{
	/* position: absolute !important; */
	/* left: 0px !important; */
	/* top: 0px !important; */
	/* height: 9px !important; */
	height: calc(9px * var(--fontSizeFactor)) !important;
	width: 12px !important;
	max-height: 20px !important;
	
	/* transform: translateY(-0.5px) !important;  */
	transform: translateX(-1px) !important; 
	/* overflow: visible !important; */
	/* background-color: coral !important; */
	display: inline-block !important; 
	opacity: 0.8 !important;
	/* z-index: 9999 !important; */
	
	transition: none !important;
}

.padlockIcon svg{
	transition: none !important;
}

.sluglineIsHidden .padlockIcon{
	/* height: 9px !important; */
	height: calc(9px * var(--fontSizeFactor)) !important;
	width: 12px !important;
	opacity: 0 !important;

	transition: none !important;
}

.hidden, div.hidden, div.hidden>p {
	/* display:none !important; */
	height: 0px !important;
	min-height: 0px !important;
	transform: scaleY(0.01) !important; 
	margin-top: 0px !important;
	margin-bottom: 0px !important;
	padding-top: 0px !important;
	padding-bottom: 0px !important;
	overflow: none !important;
	opacity: 0 !important;

	width: 0px;


	transition: height 2s 3s, transform 3s 0s, opacity 5s 0s , width 5s 0s;
	/* transition-delay: 0.5s, 0.5s, 0s;
	transition-duration: 0.2s, 0.3s, 0.5s, 0.2; */
	/* transition-duration: height 0.5s !important; */

	/* transition: all 0.2s !important */
}

/*
MARK: -Inline Synopsis
*/

--------------------------------------------- {}
-- SHOWING INLINE SYNOPSIS ------------------ {}
--------------------------------------------- {}

.showSynopsisInScenes:not(.indexcards) .synopsiscontainer:not(.sluglineIsHidden > .synopsiscontainer)
	:not(.nonProportionalMode .section:not(.isExpanded) > .scene >.synopsiscontainer){
	display: block;
}

#flexiContainer.nonProportionalMode.showSynopsisInScenes:not(.indexCards) .isExpanded > .scene {
	min-height: calc(15px * var(--fontSizeFactor)) !important;
	height: auto !important;
}

.showSynopsisInScenes:not(.indexcards) .scene:nth-child(1 of .scene){

	margin-top: 2px !important;

}

.showSynopsisInScenes:not(.indexcards) .scene:not(.sluglineIsHidden) .sceneheading{
	opacity: 0.5;
	font-weight: bold;
	
	/* font-style: italic; */
}

/* .showSynopsisInScenes:not(.indexcards) .scene .showSceneNum,
.showSynopsisInScenes:not(.indexcards) .scene .showSceneLength{
	display: none !important;
} */

.showSynopsisInScenes:not(.indexcards) .synopsiscontainer{
	display: block	 !important;
	/* max-height: 110% !important; */
	height: auto;
	/* overflow-x: hidden;
	overflow-y: scroll; */

	font-size: calc(10px * var(--fontSizeFactor)) !important;
	line-height: calc(14px * var(--fontSizeFactor)) !important;
	/* padding-top: 0px !important; */
	
	margin: 0;
	padding: 0;
	
	background: none !important;
	position:relative;
	/* padding-top: 3px !important;
	padding-bottom: 3px !important; */
}



.showSynopsisInScenes:not(.indexcards):not(.nonProportionalMode) .synopsiscontainer{

	max-height: calc(100% - 14px * var(--fontSizeFactor)) !important;
}

.showSynopsisInScenes:not(.indexcards) .scene.temporarilyShowSynopsisContainer > .synopsiscontainer:not(:has(.synopsis)){

	height: calc(14px * var(--fontSizeFactor)) !important;
	/* outline: 1px lime solid !important; */
	/* background-color: gold !important; */

}


/* #flexiContainer.showSynopsisInsteadOfSceneheading:not(.sceneCards):not(.sectionCards) .section .iAmASyn:not(.sceneheading .iAmASyn){
	color: hsl(0, 0%, 60%) !important;
} */


DISABLED.showSynopsisInScenes:not(.indexcards) .scene:hover .synopsis,
DISABLED.showSynopsisInScenes:not(.indexcards) .synopsiscontainer:hover .synopsis{
	color: white !important
}

.showSynopsisInScenes:not(.indexcards) .synopsis {

	margin-top: 1px

}

/* .showSynopsisInsteadOfSceneheading.nonProportionalMode .scene{

	height: auto !important;
} */

.showSynopsisInScenes.onlySynopsis:not(.indexcards) .sceneheading{
	display: none;
}
.showSynopsisInScenes.onlySynopsis:not(.indexcards):not(.nonProportionalMode) .synopsiscontainer{

	max-height: calc(100% - 0px * var(--fontSizeFactor)) !important;
}

/*
MARK: -Grey only
*/

#--------------------------------------------- {}
#----- TURNING_OFF_COLORS -------------------- {}
#--------------------------------------------- {}

.greyonly .scene:not(.special),
html:not(html[data-outdoors='1']) .greyonly.indexcards .synopsiscontainer:not(.level1 > .synopsiscontainer):not(.special > .synopsiscontainer):not(.dimmedScene .synopsiscontainer):not(.dimmedSection > .synopsiscontainer):not(.dimmedSection > .orphanText > .synopsiscontainer) { 
	/* background-color: #ddd !important; */
	--localColor: #ddd !important;
}

.greyonly/*:not(html[data-outdoors='1'] .greyonly)*/ .section,
.greyonly/*:not(html[data-outdoors='1'] .greyonly)*/ .section-heading:not(.level1>.section-heading):not(.special>.section-heading):not(.section-heading:hover)/*:not(.section:hover>.section-heading)*/ { 
	/* background-color: #ccc !important; */
	--localColor: #ccc !important;
}

.greyonly .synopsis{

	--localSynopsisColor: black !important;

}

html:not([data-outdoors='1']) #flexiContainer.greyonly .scene .synopsis,
html:not([data-outdoors='1']) #flexiContainer.greyonly.indexcards .section:not(.level1, .special) > .synopsiscontainer > .synopsis{
	color: black !important;
	background: transparent !important;
}

html:not([data-outdoors='1']) #flexiContainer.greyonly .section > .synopsiscontainer > .synopsis{
	color: white !important;
	background: transparent !important;
}

html:not([data-outdoors='1']) #flexiContainer.greyonly:not(.indexcards) .section > .synopsiscontainer > .synopsis:hover,
html:not([data-outdoors='1']) #flexiContainer.greyonly:not(.indexcards) .section > .synopsiscontainer > .synopsis:hover::before,
html:not([data-outdoors='1']) #flexiContainer.greyonly .scene .synopsis:hover,
html:not([data-outdoors='1']) #flexiContainer.greyonly .scene .synopsis:hover::before{
	color: white !important;
	background: black !important;
}

/*
MARK: -High Contrast
*/

#---------------- HI CONTRAST --------------{}

html[data-outdoors='1']{
	
	--pageBackground: #fff; /* scrap this entire line when done with light bkg */
	
}

html[data-outdoors='1'] #notepanel{

	box-shadow: 0 0 0 2px black !important;

	&:not(.expanded){

		box-shadow: none!important;

	}

}


html[data-outdoors='1'] #notepanel .closetab{

	color: black !important;

}

html[data-outdoors='1'] #notepanel .tab{

	box-shadow: 1.2px -1px 0 0.7px rgba(0,0,0,1);


}

html[data-outdoors='1'] .menu .name {

	background: #888;

}

html[data-outdoors='1'] .menu {

	box-shadow: 0 0 0 2px black !important;
	background: white;

}

html[data-outdoors='1'] .menu::before{

	

	box-shadow: -1.2px -1.2px 0 1.1px black !important;

}

html[data-outdoors='1'] .menu::after{

	border-color: transparent !important;
	border-top-color: white !important;
	border-left-color: white !important;

	box-shadow: none !important;
	background: transparent !important;

}

html[data-outdoors='1'] .menu input:not(input:checked) + .radio,
html[data-outdoors='1'] .menu input:not(input:checked) + .switch,
html[data-outdoors='1'] .menu input:not(input:checked) + label + .switch{

	border-color: #666 !important;
	box-shadow: inset 0 0 0 1px #aaa !important;

}

html[data-outdoors='1'] .menu .switch::before{

	border-color: black !important;
	box-shadow: inset 0 0 0 1px black !important;

}

html[data-outdoors='1'] .menu .radio::after{

	box-shadow: none !important;
	background-color: white !important;

}

html[data-outdoors='1'] .notepanelNote {

	background-image: linear-gradient(rgba(255, 255, 255, var(--saturation)), rgba(255, 255, 255, var(--saturation))) !important;

}

html[data-outdoors='1'] #flexiContainer:not(.indexcards) .section:not(.level1){

	border-color: black;
	border-width: 1px;
	padding-left: 2px;
	
	border-top-width: 1px;
	box-sizing: border-box;
	border-top-style: solid;

	box-shadow: inset 5px 0 0 0 var(--localColor);
	margin-top: 1px;

}

html[data-outdoors='1'] body:has(.displayNumberOf) .section:not(.level1){  

	box-shadow: none !important;

}  

html[data-outdoors='1'] .section > .section-heading:not(.level1 > .section-heading){
	
	color: black !important;
	background: white !important;
	background: transparent !important;
	/* border-top: 0px black solid;
	border-left: 0px black solid;*/
	border-right: 1px black solid; 

	/* box-shadow: inset -1.75px 0 0 0.25px yellow; */

}

html[data-outdoors='1'] :not(.indexcards) .section:not(.level1, .special) > .section-heading{

	border-top: none;
	border-left: none;

}

html[data-outdoors='1'] .indexcards .section:not(.level1, .special) > .section-heading,
html[data-outdoors='1'] .indexcards .section:not(.level1, .special) > .synopsiscontainer{

	border: 1px black solid !important;
	box-shadow: 8px 0 0 0px inset var(--localColor) !important;

}

html[data-outdoors='1'] .indexcards .section:not(.level1, .special) > .section-heading{

	padding-left: 10px !important;
	
}

html[data-outdoors='1'] .scene,
html[data-outdoors='1'] .isExpanded > .scene{

	border: 0.5px solid black !important;
	box-sizing: border-box !important;
	
	background-color: color-mix(in oklab, var(--localColor), white var(--saturation));

	box-shadow: none !important; 

}

html[data-outdoors='1'] .colorBorderInOutdoorMode .scene,
html[data-outdoors='1'] .colorBorderInOutdoorMode .isExpanded > .scene{

	box-shadow: 6px 0 0 0px inset var(--localColor);
				/* 0px 0 0 1px inset var(--localColor) !important; */
	

}

html[data-outdoors='1'] .isExpanded > .scene.isOmitted{

	--hslPageBackground: 180, 0%, 50% !important;
	background-color: var(--localColor);
	background-color: white

}

html[data-outdoors='1'] .isExpanded > .scene::before{

	border-color: black;

}

html[data-outdoors='1'] .sceneheading,
html[data-outdoors='1'] .synopsiscontainer,
html[data-outdoors='1'] .synopsis{
	
	color: black !important;
	background: transparent !important;
	box-shadow: none !important;
	
}

html[data-outdoors='1'] .sceneheading{

	padding-left: 6px !important;

}

html[data-outdoors='1'] .sceneheading:not(.nonProportionalMode .sceneheading:not(.isExpanded > .sceneheading)){

	margin-top: -1.5px !important;
}


html[data-outdoors='1'] .level1 > .section-heading,
html[data-outdoors='1'] .section.special > .section-heading,
html[data-outdoors='1'] #buttonRow *,
html[data-outdoors='1'] .showActLength
{

	color: black !important;
	fill: black !important;
	opacity: 1 !important;

	transition: opacity 0s !important;
	
}

html[data-outdoors='1'] /* .greyonly */ .scene:not(.special){

	/* font-weight: 600 !important; */

}

html[data-outdoors='1'] #flexiContainer:not(.indexcards):not(.nonProportionalMode) .blankPage {
	
	position: absolute !important;
	left: -1px !important;
	width: calc(100% + 2px) !important;

	/* border-top: 2px dotted var(--pageBackground); */
	border-left: 1px #333 solid;
	border-right: 1px #333 solid; 
	border-bottom: 1px white solid;
	

	/* border-bottom: 1px black solid; */

	border-top: 10px transparent !important; /* prepare space for cogs */
	background-image: linear-gradient(transparent, transparent),/*linear-gradient(orange, orange), /* general block background, always goes first, overlapping everything below it */
					linear-gradient(to bottom right, 
						transparent 50.5%, 
						#333 50.5%), 
					linear-gradient(to bottom left, 
						transparent 50.5%, 
						#333 50.5%),
					linear-gradient(white,white);
	background-repeat: repeat, repeat-x, repeat-x, repeat-x;
	background-position: 0 0, 5px 0, 5px 0, 0 5px;
	background-size: auto auto, 5px 5px, 5px 5px;
	background-clip: padding-box, border-box, border-box; /* trim the edges of the overall fill */
	
	background-origin: padding-box, border-box, border-box, border-box, border-box; /* position the teeth relative to the upper border, and the background relative to the inner margin */
		
	/* opacity: 0.9; */

}

html[data-outdoors='1'] #flexiContainer:not(.indexcards):not(.nonProportionalMode) .blankPage::after {

	box-sizing: content-box;

	position: absolute !important;
	content: " ";
	top: 1px;
	left: -1px;
	width: calc(100% + 2px);
	height: calc(100% + 2px);

	/* border-left: 1px white solid;
	border-right: 1px white solid; 
	border-bottom: 1px white solid;  */
	/*border-top-left-radius: 2px;
	border-top-right-radius: 2px; */

	border-top: 10px white !important; /* prepare space for cogs */
	background-image: linear-gradient(transparent, transparent),/*linear-gradient(orange, orange), /* general block background, always goes first, overlapping everything below it */
					linear-gradient(to bottom right, 
						transparent 50.5%, 
						white 50.5%), 
					linear-gradient(to bottom left, 
						transparent 50.5%, 
						white 50.5%),
					linear-gradient(white,white);
	background-repeat: repeat, repeat-x, repeat-x, repeat-x;
	background-position: 0 0, 5px 0, 5px 0, 0 5px;
	background-size: auto auto, 5px 5px, 5px 5px;
	background-clip: padding-box, border-box, border-box; /* trim the edges of the overall fill */
	
	background-origin: padding-box, border-box, border-box, border-box, border-box; /* position the teeth relative to the upper border, and the background relative to the inner margin */


}

html[data-outdoors='1'] .showSceneLength,
html[data-outdoors='1'] .showSceneNum{
	
	opacity: 1 !important;

}

html[data-outdoors='1'] .section-heading,
html[data-outdoors='1'] .boneyardIsClosed .boneyard::before,
html[data-outdoors='1'] .section-heading > .showSectionPageNumber{
	
	color: black !important;
	opacity: 1 !important;

}

html[data-outdoors='1'] #outOfSyncDiv{

	background: 	repeating-linear-gradient(
		-45deg,
		transparent,
		transparent 3px,
		#ddd 3px,
		#ddd 6px)
		/* ,#555 !important */
	;
}

html[data-outdoors='1'] .indexcards .section:not(.level1, .dimmedSection) > .section-heading{

	border-style: solid !important;

}

html[data-outdoors='1'] :not(.indexcards, :has(.displayNumberOf)) .section:not(.dimmedSection) > .section-heading:not(.level1 > .section-heading){

	border-bottom: 1px var(--localColor) solid;
	/* border-top: 1px var(--localColor) solid; */
	/* border-left: 8px transparent solid; */

}

html[data-outdoors='1'] .section:not(.level1):not(.noHover):not(:has(:hover)):hover,
html[data-outdoors='1'] .section:not(.level1):not(.noHover):has(.section-heading:hover){

	--localColor: black !important

}

html[data-outdoors='1'] .section:not(.level1):not(.noHover):not(:has(:hover)):hover > .section-heading,
html[data-outdoors='1'] .section:not(.level1):not(.noHover):has(.section-heading:hover) > .section-heading{
/* html[data-outdoors='1'] .section:not(:has(:hover)):hover > .section-heading:not(.level1 > .section-heading){ */

	color: white !important;	
	/* background: black !important; */

}

html[data-outdoors='1'] :not(.indexcards) .section.special > .section-heading{

	border: none !important

}


html[data-outdoors='1'] .level1 .synopsis,
html[data-outdoors='1'] .section.special > .synopsiscontainer > .synopsis
{
	color: black !important

}


html[data-outdoors='1'] .indexcards .isExpanded > .scene:not(.special)
{ 

	border-left: 1px solid black !important;
	border-right: 1px solid black !important;
	border-bottom: 1px solid black !important;
	/* background-color: white !important; */
	background-image: linear-gradient(white, white);

}

html[data-outdoors='1'] :not(.indexcards) .synopsis{
	background: transparent !important;
	color: black !important;
}

html[data-outdoors='1'] .synopsis::before
{

	color: var(--localSynopsisColor) !important;
	/* font-size: calc(30px * var(--fontSizeFactor)) !important; */

}

html[data-outdoors='1'] .synopsis:hover::before
{

	color: inherit !important;

}

html[data-outdoors='1'] .indexcards .synopsis:hover{

	color: white !important;
	background-color: black !important;

}

html[data-outdoors='1'] .synopsis.isSelected {

	color: white !important;
	background-color: black !important;
	background-image: linear-gradient(black, black);
	background: black !important;

}

html[data-outdoors='1'] .indexcards .section:hover .sectionArrow {

	border-color: white !important;
	opacity: 1;

}

html[data-outdoors='1'] .orphanText {

	background: 	repeating-linear-gradient(
		-45deg,
		transparent 0px,
		transparent 3px,
		rgba(0,0,0,0.1) 3px,
		rgba(0,0,0,0.1) 6px)
		/* ,
rgba(221, 221, 221, 1) !important */
;
}

html[data-outdoors='1'] .scene:not(.sluglineIsHidden):hover > .sceneheading {

	color: black !important;
	background-color: transparent !important;
	/* background-color: var(--localColor) !important; */
	mix-blend-mode: normal;
	opacity: 1 !important;

}

html[data-outdoors='1'] .indexcards .scene:hover > .sceneheading{

	background-color: black !important;
	color: white !important
}


html[data-outdoors='1'] .padlockIcon, 
html[data-outdoors='1'] .showSceneNum {

	opacity: 0.6;
	font-weight: normal;

}

html[data-outdoors='1'] .arrowForIndexCards::before {

	color: black !important;

}

html[data-outdoors='1'] .indexcards .arrowForIndexCards::before {

	left: -12.5px !important;
	top: -2px !important;

}

html[data-outdoors='1'] .indexcards .section.isExpanded > .scene > .arrowForIndexCards::before {

	left: -21px !important;
	
}

html[data-outdoors='1'] .arrowForIndexCards:hover::before {
	
	color: black !important;

} 

html[data-outdoors='1'] .synopsis:hover {
	color: white !important;
	background-color: black !important;
}

html[data-outdoors='1']  .section:not(.level1).isSelected > .section-heading,
html[data-outdoors='1']  .section:not(.level1).isSelected > .synopsiscontainer,
html[data-outdoors='1']  .scene.isSelected,
html[data-outdoors='1']  .scene.isSelected:not(.sluglineIsHidden) > .sceneheading,
html[data-outdoors='1']  .scene.isSelected > .synopsiscontainer{
	
		color: white !important;
		
		opacity: 1 !important;
		/* background-image: linear-gradient(black, black) !important; */
		background: black !important;
	
}

html[data-outdoors='1'] .widerButton,
html[data-outdoors='1'] .widerButtonOn{

	fill: black !important;

}

html[data-outdoors='1'] .pageDivider {

	--pageDividerColor: rgba(0,0,0,1) !important;

}

html[data-outdoors='1'] #notepanel .tab,
html[data-outdoors='1'] #notepanel .chunkHeading:not(:hover, :has(:hover)) {

	color: black ;

}

html[data-outdoors='1'] #notepanel .chunkHeading:has(:hover) {

	color: white !important;

}

html[data-outdoors='1'] {

	--dragging-cursor-color: blue !important

}

#saturationSlider{

	-webkit-appearance: none; 
	appearance: none;

	position: absolute;
	width: 190px;
	height: 24px;
	right: 280px;
	bottom: 14px;

	display: none

}

#saturationSlider:hover{

	box-sizing: content-box;
	translate: 30px 30px;
	border: 30px solid transparent !important;

}

html[data-outdoors='1'] #saturationSlider{

	display: block

}


/* html[data-outdoors='1'] #flexiContainer.showPageDividers.always:not(.indexcards):not(.nonProportionalMode) .level1 .pageDivider,
html[data-outdoors='1'] #flexiContainer.showPageDividers:not(.indexcards):not(.nonProportionalMode) .level1:hover .pageDivider{

	--pageDividerColor: rgba(0,0,0,1) !important; 
	
} */

/*
MARK: -Boneyard
*/

#--------------------------------------------- {}
#----- BONEYARD_STUFF ------------------------ {}
#--------------------------------------------- {}

.level1.boneyard{

	background-color: rgba(212,228,255,0.15) !important;
	background-image: none !important;

	/* background: repeating-linear-gradient(
			45deg,
			transparent 0px,
			transparent 3px,
			rgba(255,255,255,0.1) 3px,
			rgba(255,255,255,0.1) 6px)
	!important; */

	border: 2px solid rgba(255,255,255,0.1) !important;
	border-radius: 5px !important;
	height: calc(100% - 20px) !important;
	max-height: calc(100% - 20px) !important;
	padding-bottom: 0px !important;

	/* opacity: 0.85 !important; */

	overflow: auto !important;
	padding-left: 10px !important;
	padding-right: 10px !important;

	pointer-events: all !important;

	transition: margin 0.25s, flex-grow 0.25s, opacity 0.25s !important;

	position: sticky !important;
	top: 0px;

}

.indexcards .boneyard{

	height: calc(100% - 20px) !important;
	max-height: calc(100% - 20px) !important;
	padding-bottom: 0px !important;
	padding-top: 0px !important;

}

#flexiContainer:not(.oneColumnOutline).boneyardIsClosed .level1.boneyard{

	flex-grow: 0.0 !important;
	padding-left: 0 !important;
	padding-right: 0 !important;

	border-radius: 1px !important;

	/* margin-right: calc(15px * var(--fontSizeFactor)) !important;  */
	border: 0px none transparent !important;
	border-left: 2px solid rgba(255,255,255,0.3) !important;
	border-right: calc(15px * var(--fontSizeFactor)) transparent solid !important;
	 /* rgba(255,0,0,0) !important; */
	background: none !important;

	pointer-events: all;

	overflow: visible !important;

	/* background-color: transparent !important; */
	/* background: linear-gradient(90deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0.0) 10px) !important; */

}

#flexiContainer:not(.oneColumnOutline):not(.boneyardIsClosed) .level1.boneyard > .section-heading::before{

content: "\25BA";

float: right;

}

#flexiContainer:not(.oneColumnOutline).boneyardIsClosed .level1.boneyard *{

	width: 0 !important;
	height: 1vh !important;
	overflow: hidden !important;

	opacity: 0 !important;
	pointer-events: none !important;

	transition: width 0.25s, opacity 0.25s !important;

}

.level1.boneyard::before{

	position: absolute;

	top: 300px;
	left: 0px;

	width: 300px;
	height: calc(12px * var(--fontSizeFactor));

	text-align: right;


	/* width: 10px;
	height: 30px; */

	/* background-color: rgba(255,255,255,0.2);
	background-image: none;
	border: 2px solid rgba(255,255,255,0.2);
	border-radius: 5px 0 0 5px; */

	content: "BONEYARD\00a0\00a0▲";

	/* border: 100px lime solid !important; */

	transform-origin: 0% 0%;
	transform: rotate(-90deg);
	
	opacity: 0;
	transition: opacity 0.25s !important;
	transition-delay: opacity 0.25 !important;
}

#flexiContainer.boneyardIsClosed:not(.oneColumnOutline) .level1.boneyard::before{
	
	opacity: 1;
	transition: opacity 0.25s !important;
	transition-delay: opacity 0.25 !important;
}


.level1.boneyard .showActLength,
.level1.boneyard + .showActLength,
.boneyard .showActLength,
.boneyard + .showActLength,
.level1.boneyard .showSectionPageNumber,
.boneyard .showSectionPageNumber,

.boneyard .showSceneNum:not(.sceneheading:has(.padlockIcon) .showSceneNum)
{
	display: none !important; 
	
}

#flexiContainer.oneColumnOutline .level1.boneyard{
	
	margin-top: calc(24px * var(--fontSizeFactor)) !important;
}
.boneyard:not(.indexcards .boneyard) .orphanText{
	display: none
}

.boneyard:not(.indexcards .boneyard) .scene{

	height: calc(var(--fixedHeight) * var(--fontSizeFactor)) !important;
	max-height: calc(var(--fixedHeight) * var(--fontSizeFactor)) !important;
	min-height: calc(var(--fixedHeight) * var(--fontSizeFactor)) !important;
	
	transition: max-height 0.2s, min-height 0.2s, height 0.2s;
	}
	
:not(.indexcards) .boneyard .section{

	margin-bottom: 11px !important;
}

.boneyard * {
	opacity: 0.85 !important;
}

.boneyard:hover *{
	opacity: 1 !important;
}

/*
MARK: -Buttons
*/

#----- BUTTONS ---------------{}

@media screen and (max-width: 380px){

	#buttonRow{

		/* opacity: 1 !important; */

		display: flex;
		flex-direction: row;
		justify-content: space-evenly;
		align-items: flex-end;

		/* transform: translateY(20px) !important; */
	}

	#buttonRow *{

		flex-basis: 1;
		
		position: relative !important;
		left: unset !important;
		right: unset !important;
		/* top: unset !important; */
		/* bottom: unset !important; */

		/* float: left !important; */
		/* outline: 1px lime solid */
	}
	
}

#----- INFO FIELD ---------------{}

#infoField{

	position: absolute;
	left: 125px;
	top: 7px;

	display: inline-block;

	padding: 3px 6px;
	border-radius: 4px;

	font-size: 10px;
	font-weight: bold;
	line-height: 12px;

	opacity: 30%;

	background-color: white;
	color: black;

	/* position: absolute; */
	/* top: 0px; */
	/* left: 0px; */
	width: auto;

	
}

#infoField::first-line{

	font-weight: 600 !important;

}

#infoField:hover{
	
	opacity: 80%;
	
}

#infoField:not(:empty){
	
	transition: opacity 0.2s !important;

}

#infoField:empty{

	opacity: 0% !important

}

#----- SLIDERS ---------------{}

#saturationRange {

	position: absolute;
	top: 10px;
	width: 150px;

	display: none

}

#saturationSlider:hover #saturationRange {

	display: block

}

input[type=range]:focus {
  outline: none;
}

input[type=range]::-webkit-slider-runnable-track {
  height: 4px;
  background: grey;
  border: 1px black solid;
  border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.1), 
  			inset 0px 0px 0px 2px black;
  border: 1px solid black !important;
  height: 20px;
  width: 20px;
  border-radius: 50%;
  background: silver;
  margin-top: -9px;
}
input[type=range]:focus::-webkit-slider-thumb {
  border: 1px solid black;
  box-shadow: 0px 0px 5px black;
}

.paletteIcon{

	position: absolute;
	top: 0px;
	right: 0px;

	width: 24px;
	height: 24px;


}

.debug{

	display: none;

}

:has(.loggingIsOn) .debug{

	display: inline-block !important;

}



</style><script>

var indexCardIcon = /*svg*/`
    <svg width="110%" height="110%" viewBox="0 0 591 355" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-520.351,-475.64)">
            <path d="M1110.9,800.214L520.351,800.214L520.351,810.258C520.351,821.138 529.185,829.971 540.065,829.971L1091.19,829.971C1102.07,829.971 1110.9,821.138 1110.9,810.258L1110.9,800.214ZM1110.9,797.089L520.351,797.089L520.351,746.603L1110.9,746.603L1110.9,797.089ZM1110.9,743.478L520.351,743.478L520.351,692.993L1110.9,692.993L1110.9,743.478ZM1110.9,689.868L520.351,689.868L520.351,639.383L1110.9,639.383L1110.9,689.868ZM1110.9,636.258L520.351,636.258L520.351,586.057L1110.9,586.057L1110.9,636.258ZM520.351,571.474L1110.9,571.474L1110.9,495.354C1110.9,484.473 1102.07,475.64 1091.19,475.64L540.065,475.64C529.185,475.64 520.351,484.473 520.351,495.354L520.351,571.474Z" style="fill:white;"/>
        </g>
    </svg>
`

var padlockIcon = /*svg*/`
	<svg class="padlockIcon" width="100%" height="100%" viewBox="0 0 163 239" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    	<g transform="matrix(1,0,0,1,-306.153,-935.624)">
        	<path d="M333.581,1022.43L316.359,1022.43C310.722,1022.43 306.153,1027 306.153,1032.64C306.153,1066.7 306.153,1174.32 306.153,1174.32L468.427,1174.32L468.427,1032.64C468.427,1027 463.857,1022.43 458.22,1022.43L440.999,1022.43L440.999,989.332C440.999,959.67 416.953,935.624 387.29,935.624L387.289,935.624C357.627,935.624 333.581,959.67 333.581,989.332L333.581,1022.43ZM418.082,1022.43L356.497,1022.43L356.497,989.332C356.497,972.326 370.283,958.54 387.289,958.54L387.29,958.54C404.296,958.54 418.082,972.326 418.082,989.332L418.082,1022.43Z"/>
    	</g>
	</svg>
`

var funnelIcon = /*svg*/`
    <svg width="90%" height="90%" viewBox="0 0 134 129" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(0.0914882,0,0,0.0914882,-55.722,-69.8855)">
            <path d="M1460.88,1521.97L1460.88,1934.76L1215.5,2170.98L1215.5,1732.94C1170.4,1774.99 1109.91,1800.73 1043.45,1800.73C904.154,1800.73 791.064,1687.64 791.064,1548.35C791.064,1430.32 872.253,1331.11 981.765,1303.57L609.063,955.318L2067.32,955.318L1460.88,1521.97ZM1043.45,1418.32C1115.21,1418.32 1173.48,1476.58 1173.48,1548.35C1173.48,1620.11 1115.21,1678.38 1043.45,1678.38C971.685,1678.38 913.422,1620.11 913.422,1548.35C913.422,1476.58 971.685,1418.32 1043.45,1418.32ZM2067.32,763.875L609.063,763.875L609.063,931.696L2067.32,931.696L2067.32,763.875Z" />
        </g>
    </svg>
`

var warningSign = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 802 714" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-1499.38,-2013.16)">
            <g transform="matrix(0.972244,0,0,0.96871,993.058,-444.701)">
                <path d="M933.111,2610.37L1272.59,3200.51L593.632,3200.51L933.111,2610.37Z" style="fill:rgb(255,221,0);"/>
            </g>
            <path d="M1961.61,2048.58C1948.96,2026.66 1925.58,2013.16 1900.27,2013.16C1874.96,2013.16 1851.58,2026.66 1838.93,2048.58L1508.87,2620.25C1496.22,2642.17 1496.22,2669.17 1508.87,2691.08C1521.52,2713 1544.91,2726.5 1570.21,2726.5L2230.33,2726.5C2255.63,2726.5 2279.01,2713 2291.67,2691.08C2304.32,2669.17 2304.32,2642.17 2291.67,2620.25L1961.61,2048.58ZM1900.27,2083.99L2230.33,2655.67L1570.21,2655.67L1900.27,2083.99ZM1899.71,2507.49C1914.83,2507.49 1927.8,2512.86 1938.62,2523.59C1949.45,2534.32 1954.86,2547.34 1954.86,2562.64C1954.86,2577.39 1949.45,2590.03 1938.62,2600.58C1927.8,2611.12 1914.83,2616.39 1899.71,2616.39C1884.97,2616.39 1872.32,2611.17 1861.78,2600.72C1851.23,2590.26 1845.96,2577.57 1845.96,2562.64C1845.96,2547.15 1851.18,2534.09 1861.64,2523.45C1872.09,2512.81 1884.78,2507.49 1899.71,2507.49ZM1954.3,2293.61L1917.07,2484.54L1884.31,2484.54L1847.08,2296.13C1846.71,2294.45 1846.33,2292.4 1845.96,2289.97C1843.91,2278.78 1842.88,2271.59 1842.88,2268.42C1842.88,2253.67 1848.15,2241.78 1858.7,2232.72C1869.24,2223.67 1883.1,2219.15 1900.27,2219.15C1917.44,2219.15 1931.3,2223.72 1941.84,2232.87C1952.39,2242.01 1957.66,2253.86 1957.66,2268.42C1957.66,2271.03 1957.38,2274.48 1956.82,2278.78C1956.26,2283.07 1955.42,2288.01 1954.3,2293.61Z"/>
        </g>
    </svg>
`

var gearIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 639 643" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-712.417,-2277.47)">
            <path d="M984.5,2344.81L990.4,2280.03C1003.89,2278.34 1017.64,2277.47 1031.59,2277.47C1045.55,2277.47 1059.29,2278.34 1072.78,2280.03L1078.68,2344.81C1101.33,2348.9 1122.95,2355.88 1143.15,2365.34L1186.21,2316.17C1210.56,2329.24 1233.04,2345.3 1253.14,2363.85L1219.75,2419.88C1235.78,2436.36 1249.62,2454.94 1260.81,2475.16L1324.96,2460.59C1336.73,2484.93 1345.49,2510.97 1350.76,2538.22L1290.37,2564.11C1291.93,2575.52 1292.73,2587.14 1292.73,2598.95C1292.73,2610.75 1291.93,2622.37 1290.37,2633.78L1350.76,2659.67C1345.49,2686.92 1336.73,2712.96 1324.96,2737.3L1260.81,2722.73C1249.62,2742.95 1235.78,2761.52 1219.75,2778.01L1253.14,2834.04C1233.04,2852.59 1210.57,2868.65 1186.21,2881.72L1143.15,2832.55C1122.94,2842.02 1101.31,2848.99 1078.68,2853.08L1072.78,2917.86C1059.29,2919.55 1045.55,2920.42 1031.59,2920.42C1017.64,2920.42 1003.89,2919.55 990.4,2917.86L984.5,2853.08C961.856,2848.99 940.227,2842.01 920.029,2832.55L876.974,2881.72C852.621,2868.65 830.141,2852.59 810.038,2834.04L843.435,2778.01C827.402,2761.53 813.558,2742.95 802.371,2722.73L738.217,2737.3C726.452,2712.96 717.694,2686.92 712.417,2659.67L772.807,2633.78C771.251,2622.37 770.449,2610.75 770.449,2598.95C770.449,2587.14 771.251,2575.52 772.807,2564.11L712.417,2538.22C717.693,2510.97 726.452,2484.93 738.217,2460.59L802.371,2475.16C813.559,2454.94 827.399,2436.37 843.435,2419.88L810.038,2363.85C830.137,2345.3 852.616,2329.24 876.974,2316.17L920.029,2365.34C940.24,2355.87 961.867,2348.9 984.5,2344.81ZM1031.59,2419.78C1131.55,2419.78 1212.71,2500.06 1212.71,2598.95C1212.71,2697.83 1131.55,2778.11 1031.59,2778.11C931.629,2778.11 850.473,2697.83 850.473,2598.95C850.473,2500.06 931.629,2419.78 1031.59,2419.78ZM1031.59,2529.46C1070.36,2529.46 1101.83,2560.6 1101.83,2598.95C1101.83,2637.29 1070.36,2668.43 1031.59,2668.43C992.824,2668.43 961.35,2637.29 961.35,2598.95C961.35,2560.6 992.824,2529.46 1031.59,2529.46Z" style="fill:white;"/>
        </g>
    </svg>
`

var printerIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 328 310" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-778.679,-2332.44)">
        <path d="M838.528,2588.35L838.528,2627.7C838.528,2635.76 845.057,2642.29 853.112,2642.29L1032.15,2642.29C1040.2,2642.29 1046.73,2635.76 1046.73,2627.7L1046.73,2588.35L1087.6,2588.35C1098.08,2588.35 1106.58,2579.86 1106.58,2569.37C1106.58,2537.54 1106.58,2473.77 1106.58,2441.93C1106.58,2431.45 1098.08,2422.95 1087.6,2422.95C1029.67,2422.95 855.59,2422.95 797.661,2422.95C787.178,2422.95 778.679,2431.45 778.679,2441.93C778.679,2473.77 778.679,2537.54 778.679,2569.37C778.679,2579.86 787.178,2588.35 797.661,2588.35L838.528,2588.35ZM1032.15,2549L853.112,2549L853.112,2627.7L1032.15,2627.7L1032.15,2549ZM1058.02,2444.55C1065.79,2444.55 1072.09,2450.86 1072.09,2458.62C1072.09,2466.38 1065.79,2472.68 1058.02,2472.68C1050.26,2472.68 1043.96,2466.38 1043.96,2458.62C1043.96,2450.86 1050.26,2444.55 1058.02,2444.55ZM1032.15,2332.44L853.112,2332.44L853.112,2411.14L1032.15,2411.14L1032.15,2332.44Z" style="fill:white;"/>
    </g>
</svg>
`

var tagIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 328 185" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-1625.63,-1535.48)">
            <path d="M1952.83,1548.92C1952.83,1545.36 1951.41,1541.94 1948.89,1539.42C1946.37,1536.89 1942.95,1535.48 1939.38,1535.48C1889.94,1535.48 1719.03,1535.48 1679.45,1535.48C1674.4,1535.48 1669.78,1538.31 1667.48,1542.8C1658.43,1560.51 1635.49,1605.38 1627.11,1621.77C1625.14,1625.62 1625.14,1630.17 1627.11,1634.01C1635.49,1650.41 1658.43,1695.28 1667.48,1712.98C1669.78,1717.48 1674.4,1720.31 1679.45,1720.31L1939.38,1720.31C1942.95,1720.31 1946.37,1718.89 1948.89,1716.37C1951.41,1713.85 1952.83,1710.43 1952.83,1706.86C1952.83,1672.74 1952.83,1583.05 1952.83,1548.92ZM1675.94,1613.83C1683.71,1613.83 1690.01,1620.13 1690.01,1627.89C1690.01,1635.66 1683.71,1641.96 1675.94,1641.96C1668.18,1641.96 1661.88,1635.66 1661.88,1627.89C1661.88,1620.13 1668.18,1613.83 1675.94,1613.83Z" style="fill:white;"/>
        </g>
    </svg>
`

var toNewIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 476 343" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-1227.66,-1776.57)">
            <path d="M1427.6,2072.54C1427.6,2065.64 1422.01,2060.04 1415.1,2060.04L1240.16,2060.04C1233.25,2060.04 1227.66,2065.64 1227.66,2072.54L1227.66,2106.23C1227.66,2113.14 1233.25,2118.73 1240.16,2118.73L1415.1,2118.73C1422.01,2118.73 1427.6,2113.14 1427.6,2106.23L1427.6,2072.54ZM1468.1,1810.81C1471.27,1811.75 1474.38,1813.2 1477.36,1815.16L1497.27,1828.25L1497.27,1805.74L1673.5,1805.74L1673.5,2089.57L1497.27,2089.57L1497.27,1972.57L1477.36,1985.66C1474.38,1987.62 1471.27,1989.07 1468.1,1990.01L1468.1,2097.68C1468.1,2109.31 1477.43,2118.73 1488.93,2118.73L1681.83,2118.73C1693.34,2118.73 1702.66,2109.31 1702.66,2097.68L1702.66,1797.63C1702.66,1786 1693.34,1776.57 1681.83,1776.57L1488.93,1776.57C1477.43,1776.57 1468.1,1786 1468.1,1797.63L1468.1,1810.81ZM1427.6,1978.05C1427.6,1971.15 1422.01,1965.55 1415.1,1965.55L1240.16,1965.55C1233.25,1965.55 1227.66,1971.15 1227.66,1978.05L1227.66,2011.74C1227.66,2018.65 1233.25,2024.24 1240.16,2024.24L1415.1,2024.24C1422.01,2024.24 1427.6,2018.65 1427.6,2011.74L1427.6,1978.05ZM1452.83,1871.06L1452.83,1845.97C1452.83,1842.83 1454.02,1839.92 1455.98,1838.26C1457.94,1836.6 1460.4,1836.42 1462.48,1837.79C1481.57,1850.34 1524.12,1878.32 1545.28,1892.23C1547.59,1893.75 1549.06,1896.93 1549.06,1900.41C1549.06,1903.89 1547.59,1907.07 1545.28,1908.59C1524.12,1922.5 1481.57,1950.48 1462.48,1963.03C1460.4,1964.4 1457.94,1964.22 1455.98,1962.56C1454.02,1960.9 1452.83,1957.99 1452.83,1954.85L1452.83,1929.76L1287.4,1929.76C1280.5,1929.76 1274.9,1924.16 1274.9,1917.26L1274.9,1883.56C1274.9,1876.66 1280.5,1871.06 1287.4,1871.06L1452.83,1871.06ZM1427.6,1789.07C1427.6,1782.17 1422.01,1776.57 1415.1,1776.57L1240.16,1776.57C1233.25,1776.57 1227.66,1782.17 1227.66,1789.07L1227.66,1822.77C1227.66,1829.67 1233.25,1835.27 1240.16,1835.27L1415.1,1835.27C1422.01,1835.27 1427.6,1829.67 1427.6,1822.77L1427.6,1789.07Z"/>
        </g>
    </svg>

`
var noteIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 343 343" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-536.383,-2910.08)">
            <g transform="matrix(-1,0,0,1,1415.28,0)">
                <path d="M703.687,3223.07L703.417,3222.8L703.417,3118.93C703.417,3100.31 688.307,3085.2 669.696,3085.2L565.819,3085.2L565.549,3084.93L565.549,3085.2L565.549,2943.8C565.549,2941.29 567.59,2939.25 570.103,2939.25L845.182,2939.25C847.695,2939.25 849.736,2941.29 849.736,2943.8L849.736,3218.52C849.736,3221.03 847.695,3223.07 845.182,3223.07L703.687,3223.07ZM594.986,3114.37L669.696,3114.37C672.209,3114.37 674.25,3116.41 674.25,3118.93L674.25,3193.64L594.986,3114.37ZM691.606,3252.24L536.383,3097.01L536.383,2943.8C536.383,2925.19 551.492,2910.08 570.103,2910.08L845.182,2910.08C863.793,2910.08 878.902,2925.19 878.902,2943.8L878.902,3218.52C878.902,3237.13 863.793,3252.24 845.182,3252.24L691.606,3252.24Z"/>
            </g>
        </g>
    </svg>
`

var zoomIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 407 407" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-1563.75,-2936.09)">
            <path d="M1807.68,3203.45C1748.74,3250.7 1662.33,3247.01 1607.7,3192.38C1549.1,3133.78 1549.1,3038.63 1607.7,2980.03C1666.29,2921.44 1761.44,2921.44 1820.04,2980.03C1874.67,3034.67 1878.37,3121.08 1831.12,3180.02L1853.7,3202.6L1863.02,3193.28L1970.53,3300.8L1928.46,3342.87L1820.94,3235.36L1830.26,3226.04L1807.68,3203.45ZM1628.32,3000.66C1675.54,2953.44 1752.2,2953.44 1799.41,3000.66C1846.63,3047.87 1846.63,3124.54 1799.41,3171.75C1752.2,3218.97 1675.54,3218.97 1628.32,3171.75C1581.11,3124.54 1581.11,3047.87 1628.32,3000.66L1628.32,3000.66ZM1732.73,3067.34L1732.73,3008.19L1695,3008.19L1695,3067.34L1635.86,3067.34L1635.86,3105.07L1695,3105.07L1695,3164.22L1732.73,3164.22L1732.73,3105.07L1791.88,3105.07L1791.88,3067.34L1732.73,3067.34Z"/>
        </g>
    </svg>
`

var outlineIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 602 460" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-2823.78,-2508.54)">
            <g transform="matrix(1,0,0,1,-0.648294,0)">
                <g transform="matrix(1,0,0,1,0.648294,0)">
                    <path d="M3403.76,2508.54L2845.11,2508.54C2839.23,2508.54 2833.91,2510.92 2830.05,2514.77L2830.03,2514.79C2830.03,2514.79 2830.01,2514.8 2830.01,2514.8C2826.17,2518.66 2823.78,2523.99 2823.78,2529.86L2823.78,2946.78C2823.78,2958.55 2833.34,2968.1 2845.11,2968.1L2845.11,2593.84L3403.76,2593.84C3415.53,2593.84 3425.08,2584.28 3425.08,2572.51L3425.08,2529.86C3425.08,2518.09 3415.53,2508.54 3403.76,2508.54ZM3401.46,2929.66C3401.46,2917.89 3391.9,2908.34 3380.13,2908.34L2892.35,2908.34C2880.58,2908.34 2871.03,2917.89 2871.03,2929.66L2871.03,2936.88C2871.03,2948.65 2880.58,2958.2 2892.35,2958.2L3380.13,2958.2C3391.9,2958.2 3401.46,2948.65 3401.46,2936.88L3401.46,2929.66ZM2871.15,2785.63C2871.07,2786.39 2871.03,2787.16 2871.03,2787.93L2871.03,2866.01C2871.03,2877.78 2880.58,2887.34 2892.35,2887.34L3380.13,2887.34C3391.9,2887.34 3401.46,2877.78 3401.46,2866.01L3401.46,2787.93C3401.46,2787.16 3401.42,2786.39 3401.34,2785.63C3401.42,2784.88 3401.46,2784.11 3401.46,2783.34L3401.46,2740.69C3401.46,2728.92 3391.9,2719.36 3380.13,2719.36L2892.35,2719.36C2880.58,2719.36 2871.03,2728.92 2871.03,2740.69L2871.03,2783.34C2871.03,2784.11 2871.07,2784.88 2871.15,2785.63ZM3401.46,2634.39C3401.46,2622.62 3391.9,2613.06 3380.13,2613.06L2892.35,2613.06C2880.58,2613.06 2871.03,2622.62 2871.03,2634.39L2871.03,2677.04C2871.03,2688.81 2880.58,2698.36 2892.35,2698.36L3380.13,2698.36C3391.9,2698.36 3401.46,2688.81 3401.46,2677.04L3401.46,2634.39Z"/>
                </g>
            </g>
        </g>
    </svg>
`
var fixedIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 602 460" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-3545.58,-2508.54)">
            <g transform="matrix(1,0,0,1,-0.648294,0)">
                <g transform="matrix(1,0,0,1,0.648294,0)">
                    <path d="M3566.91,2593.84L4125.55,2593.84C4137.32,2593.84 4146.88,2584.28 4146.88,2572.51L4146.88,2529.86C4146.88,2518.09 4137.32,2508.54 4125.55,2508.54L3566.91,2508.54C3561.03,2508.54 3555.71,2510.92 3551.85,2514.77L3551.83,2514.79C3551.83,2514.79 3551.81,2514.8 3551.81,2514.8C3547.96,2518.66 3545.58,2523.99 3545.58,2529.86L3545.58,2946.78C3545.58,2958.55 3555.14,2968.1 3566.91,2968.1L3566.91,2593.84ZM4123.26,2903.58C4123.26,2893.53 4115.1,2885.37 4105.05,2885.37L3611.03,2885.37C3600.98,2885.37 3592.83,2893.53 3592.83,2903.58L3592.83,2939.99C3592.83,2950.05 3600.98,2958.2 3611.03,2958.2L4105.05,2958.2C4115.1,2958.2 4123.26,2950.05 4123.26,2939.99L4123.26,2903.58ZM4123.26,2812.81C4123.26,2802.76 4115.1,2794.6 4105.05,2794.6L3611.03,2794.6C3600.98,2794.6 3592.83,2802.76 3592.83,2812.81L3592.83,2849.23C3592.83,2859.28 3600.98,2867.44 3611.03,2867.44L4105.05,2867.44C4115.1,2867.44 4123.26,2859.28 4123.26,2849.23L4123.26,2812.81ZM4123.26,2722.04C4123.26,2711.99 4115.1,2703.83 4105.05,2703.83L3611.03,2703.83C3600.98,2703.83 3592.83,2711.99 3592.83,2722.04L3592.83,2758.46C3592.83,2768.51 3600.98,2776.67 3611.03,2776.67L4105.05,2776.67C4115.1,2776.67 4123.26,2768.51 4123.26,2758.46L4123.26,2722.04ZM4123.26,2631.27C4123.26,2621.22 4115.1,2613.06 4105.05,2613.06L3611.03,2613.06C3600.98,2613.06 3592.83,2621.22 3592.83,2631.27L3592.83,2667.69C3592.83,2677.74 3600.98,2685.9 3611.03,2685.9L4105.05,2685.9C4115.1,2685.9 4123.26,2677.74 4123.26,2667.69L4123.26,2631.27Z"/>
                </g>
            </g>
        </g>
    </svg>
`

var searchIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 857 857" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-614.519,-1315.75)">
            <path d="M1195.49,1930.88L1128.67,1864.06C1006.62,1968.58 822.092,1962.71 706.107,1846.72C584.349,1724.96 583.938,1527.67 705.19,1406.42C826.443,1285.16 1023.74,1285.58 1145.49,1407.33C1261.48,1523.32 1267.35,1707.85 1162.84,1829.89L1229.65,1896.71L1245.15,1881.22L1471.26,2107.33L1406.1,2172.48L1179.99,1946.38L1195.49,1930.88ZM1099.18,1800.4C1194.47,1705.11 1194.14,1550.06 1098.46,1454.37C1002.77,1358.68 847.716,1358.36 752.425,1453.65C657.133,1548.94 657.456,1703.99 753.145,1799.68C848.834,1895.37 1003.88,1895.69 1099.18,1800.4Z"/>
        </g>
    </svg>
`

var newIndexCardIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 605 450" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-3542.37,-3020.76)">
            <g transform="matrix(1,0,0,1,-0.648294,0)">
                <g transform="matrix(1.26906,0,0,1.26906,2882.66,2417.15)">
                    <path d="M996.692,800.214L520.351,800.214L520.351,810.258C520.351,821.138 529.185,829.971 540.065,829.971L976.978,829.971C987.859,829.971 996.692,821.138 996.692,810.258L996.692,800.214ZM996.692,797.089L520.351,797.089L520.351,746.603L996.692,746.603L996.692,797.089ZM996.692,743.478L520.351,743.478L520.351,692.993L996.692,692.993L996.692,743.478ZM996.692,689.868L520.351,689.868L520.351,639.383L996.692,639.383L996.692,689.868ZM996.692,636.258L520.351,636.258L520.351,586.057L996.692,586.057L996.692,636.258ZM520.351,571.474L996.692,571.474L996.692,495.354C996.692,484.473 987.859,475.64 976.978,475.64L540.065,475.64C529.185,475.64 520.351,484.473 520.351,495.354L520.351,571.474Z"/>
                </g>
            </g>
        </g>
    </svg>
`

var pinIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 415 415" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-5429.13,-393.183)">
            <g transform="matrix(1,0,0,1,-0.648294,0)">
                <g transform="matrix(0.707107,0.707107,-0.707107,0.707107,1522.78,-4355.75)">
                    <path d="M6349.43,457.862L6328.66,457.862L6328.66,387.341L6499.28,387.341L6499.28,457.862L6478.5,457.862L6478.5,585.597C6529.61,605.802 6564.98,649.229 6564.98,699.493L6437.72,699.493L6437.72,821.439L6413.97,888.633L6390.22,821.439L6390.22,699.493L6262.96,699.493C6262.96,649.229 6298.33,605.802 6349.43,585.597L6349.43,457.862Z"/>
                </g>
            </g>
        </g>
    </svg>
`

var pinPushedIcon = /*svg*/`
    <svg width="100%" height="100%" viewBox="0 0 363 363" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-6827.59,-409.855)">
            <g transform="matrix(1,0,0,1,-0.648294,0)">
                <g transform="matrix(1,0,0,1,0.648294,0)">
                    <path d="M6866.44,700.812C6812.81,632.25 6814.34,536.248 6873.31,477.279C6906.81,443.784 6952.25,428.82 6997.82,431.971C6982.62,438.212 6968.39,447.491 6956.08,459.805C6905.82,510.068 6906.13,592.149 6956.97,642.984C7007.8,693.82 7089.88,694.135 7140.15,643.872C7152.46,631.557 7161.74,617.333 7167.98,602.13C7171.13,647.698 7156.17,693.143 7122.67,726.638C7063.71,785.6 6967.72,787.14 6899.16,733.531L6867.34,765.349C6859.47,773.218 6845.75,772.272 6836.71,763.238C6827.68,754.204 6826.73,740.48 6834.6,732.61C6834.83,732.385 6835.06,732.167 6835.29,731.957L6866.44,700.812ZM6964.54,478.177C6957.14,517.753 6970.26,562.676 7003.77,596.183C7037.27,629.69 7082.2,642.811 7121.77,635.412C7078.51,673.505 7012.02,671.521 6970.22,629.726C6928.43,587.932 6926.44,521.444 6964.54,478.177ZM7006.87,435.532C7044.74,397.66 7110.78,402.211 7154.26,445.688C7197.74,489.165 7202.29,555.21 7164.42,593.081C7126.55,630.953 7060.5,626.402 7017.03,582.925C6973.55,539.448 6969,473.403 7006.87,435.532Z"/>
                </g>
            </g>
        </g>
    </svg>
`

var leftClickIcon = /*svg*/`
<svg width="12" height="14" viewBox="420 310 672 910" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="translate: 0 2px !important; margin-left: -4px; fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-367.278,-323.611)">
        <path d="M702.782,323.611C887.951,323.611 1038.29,473.945 1038.29,659.115L1038.29,888.442C1038.29,1073.61 887.951,1223.94 702.782,1223.94C517.612,1223.94 367.278,1073.61 367.278,888.442L367.278,659.115C367.278,473.945 517.612,323.611 702.782,323.611ZM727.355,575.886C727.355,562.324 716.344,551.313 702.782,551.313C689.219,551.313 678.209,562.324 678.209,575.886L678.209,769.059C678.209,782.622 689.219,793.633 702.782,793.633C716.344,793.633 727.355,782.622 727.355,769.059L727.355,575.886ZM425.612,758.281L425.612,888.442C425.612,1041.42 549.807,1165.61 702.782,1165.61C855.756,1165.61 979.952,1041.42 979.952,888.442L979.952,758.281L785.688,758.281L785.688,769.059C785.688,814.817 748.539,851.966 702.782,851.966C657.024,851.966 619.875,814.817 619.875,769.059L619.875,758.281L425.612,758.281ZM731.948,498.264C763.334,510.077 785.688,540.391 785.688,575.886L785.688,699.948L979.952,699.948L979.952,659.115C979.952,515.99 871.235,398.058 731.948,383.464L731.948,498.264Z"/>
    </g>
</svg>
`

var paletteIcon = /*svg*/`
<svg class="paletteIcon" width="100%" height="100%" viewBox="0 0 1194 1194" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-1110.11,-652.796)">
        <path d="M1706.83,652.796C2036.16,652.796 2303.54,920.175 2303.54,1249.51C2303.54,1408.47 2027.37,1434.58 1880.19,1425.52C1456.18,1399.43 1877.2,1846.23 1706.83,1846.23C1377.49,1846.23 1110.11,1578.85 1110.11,1249.51C1110.11,920.175 1377.49,652.796 1706.83,652.796ZM1591.73,799.773C1530.75,799.773 1481.24,846.406 1481.24,903.846C1481.24,961.286 1530.75,1007.92 1591.73,1007.92C1652.72,1007.92 1702.23,961.286 1702.23,903.846C1702.23,846.406 1652.72,799.773 1591.73,799.773ZM2043.26,1051.84C1982.27,1051.84 1932.76,1098.48 1932.76,1155.92C1932.76,1213.36 1982.27,1259.99 2043.26,1259.99C2104.24,1259.99 2153.75,1213.36 2153.75,1155.92C2153.75,1098.48 2104.24,1051.84 2043.26,1051.84ZM1864.43,843.697C1803.45,843.697 1753.94,890.33 1753.94,947.77C1753.94,1005.21 1803.45,1051.84 1864.43,1051.84C1925.41,1051.84 1974.93,1005.21 1974.93,947.77C1974.93,890.33 1925.41,843.697 1864.43,843.697ZM1450.89,1416.82C1411.5,1427.32 1393.11,1486.88 1409.86,1549.75C1426.6,1612.61 1472.19,1655.13 1511.58,1644.64C1550.98,1634.14 1569.37,1574.58 1552.62,1511.71C1535.87,1448.85 1490.29,1406.33 1450.89,1416.82ZM1370.74,947.77C1309.76,947.77 1260.25,994.404 1260.25,1051.84C1260.25,1109.28 1309.76,1155.92 1370.74,1155.92C1431.73,1155.92 1481.24,1109.28 1481.24,1051.84C1481.24,994.404 1431.73,947.77 1370.74,947.77Z"/>
    </g>
</svg>
`

var isFullScreen = false //this one will be TRUE when entering full screen (and false when exiting) and stop window size from being saved

var scenesWereProportionalBeforeIndexMode = false
var actualChangesToScriptInProgress = false //this is for the errorhandler to know what was happening if an error fires
var errorHasFired = false //will disable SOME eventlisteners if error fires

var absoluteTextLength
var globalNotesData
var globalMarkerData
var globalBeatData
var globalReviewsData

var globalAllNotes //this is not the same as globalNotesData, but after being processed by collectNotes()

var weAreCurrentlyEditingText = false
var currentlyHoveredElement = false // this holds the currently hovered element so that any time we press ALT, buttons will appear

var indexCardHeight

var paperHeightFactor // second heightFactor for printing purposes, set by CalclateHeights()

var colorsArray=[
    "Remove Color",
    "Red",
    "Orange",
    "Yellow",
    "Green",
    "Teal",
    "Cyan",
    "Blue",
    "Purple",
    "Magenta",
    "Pink",
    "Brown",
    "Gray",
    "White",
    "Special"
]

var storyColors=[
    "purple", 
    "midnightblue", 
    "forestgreen", 
    "firebrick", 
    "deeppink", 
    "black",
    "darkslategray",
    "indigo",
    "maroon",  
    "darkgoldenrod",
    "darkolivegreen",
    "darkslateblue",
    "darkviolet",
    "darkmagenta",
    "darkred",
    "darkorange",
]

var alternatePageNumber = 0


var $id = document.getElementById.bind(document)
var $ = document.querySelector.bind(document)
var $$ = document.querySelectorAll.bind(document)

var altIsBeingPressed = false

var aBeatIsHovered = false

var cardStateForScenes = []
var cardStateForSections = []
var outlineBeforeUpdate = []

var popupTimer

var loggingIsOn = false

var documentSetting = {}
var userDefault = {}
var cardState = []

// GLOBAL UI VARIABLES MOVED FROM OUTLINE.HTML

//# HEADER

var settingsContainerVisibility = 0;
var trackingContainerVisibility = 0;
var helpContainerVisibility = 0;
var notesAreDisplayed = false;
var markersAreDisplayed = false;
var synopsisAreDisplayed = false;
var beatsAreDisplayed = false;
var reviewsAreDisplayed = false;
var scenesAreHidden = false;
var currentZoomLevel;

var settingsContainer = document.getElementById('settings');
var trackingContainer = document.getElementById('tracking');
var helpContainer = document.getElementById('helpWindow');
var coverContainer = document.getElementById('cover');
var theRoot = document.querySelector(':root');
var blockOrNone = ['block', 'none'];

var classListArray = []

var contextMenuIsOpen = false

var logArray=[]

// GLOBAL DOCUMENT-RELATED VARIABLES

var outline, pages, pageBreaks, frontMatter
var heightFactor = 10 //initial value if all else fails
var unDistributableHeight

var currentSectionDepth;
var previousSectionDepth;
var lastIndexOfScene;
var currentLine;

var lengthOfScene = [];
var lengthOfSceneInEights = [];
var outlineElementNumber
var actNumber, endElement
var location, length 

var omittedNumber

var firstLineThatIsNoSynopsis = 0
var selectedNote = -1
var previouslyHovered

var entireScreenplay
var globalStartTime
var globalEndTime

var butWeAreInASynopsis = false
var currentParentScroll = false

var pageDividers = []

// var alreadyRunningPainting = false
var editBoxResizeObserver

var currentCaretPosition
var currentCaretLength

var knownTimesOfDayObject = {
        day: [
            "DAY", "DAWN", "MORNING", "EARLY MORNING", "SUNRISE", "EARLY", "AFTERNOON",
            "DAG", "GRYNING", "MORGON", "TIDIG MORGON", "SOLUPPGÅNG", "TIDIGT", "EFTERMIDDAG",
            "TAG", "MORGENGRUEN", "MORGEN", "FRÜHER MORGEN", "SONNENAUFGANG", "FRÜH", "NACHMITTAG",
            "JOOR", "GRYNING", "MORJEN", "FRÖH MORJEN", "SUNNENUPGANG", "FRÖH", "NOMITTAG",
            "JOUR", "AUBE", "MATIN", "TÔT LE MATIN", "LEVER DU SOLEIL", "TÔT", "L'APRÈS-MIDI",
            "DÍA", "ALBA", "MAÑANA", "MAÑANA TEMPRANO", "AMANECER", "TEMPRANO", "TARDE",
            "PÄIVÄ", "SARASTUS", "AAMU", "VARHAINEN AAMU", "AURINGONNOUSU", "VARHAIS", "ILTAPÄIVÄ",
            "DAG", "DAGGRY", "MORGEN", "TIDLIG MORGEN", "SOLOPPGANG", "TIDLIG", "ETTERMIDDAG",
            "DAG", "DÅGNING", "MORGEN", "TIDLIG MORGEN", "SOLØJSENING", "TIDLIG", "EFTERMIDDAG"
        ],
        night: [
            "NIGHT", "DUSK", "EVENING", "LATE EVENING", "SUNSET", "LATE", "MIDNIGHT",
            "NATT", "SKYMNING", "KVÄLL", "SEN KVÄLL", "SOLNEDGÅNG", "SENT", "MIDNATT",
            "NACHT", "DÄMMERUNG", "ABEND", "SPÄTER ABEND", "SONNENUNTERGANG", "SPÄT", "MITTERNACHT",
            "NUIJT", "DÄMMERUNG", "OAVEND", "SPÄTER OAVEND", "SUNNENUNTERGANG", "SPÄT", "MIDDERNOCHT",
            "NUIT", "CREPUSCULE", "SOIR", "TARD LE SOIR", "COUCHER DE SOLEIL", "TARD", "MINUIT",
            "NOCHE", "CREPÚSCULO", "TARDE", "TARDE NOCHE", "PUESTA DE SOL", "MUY TARDE", "MEDIANOCHE",
            "YÖ", "HÄMÄRÄ", "ILTA", "MYÖHÄ ILTA", "AURINGONLASKU", "MYÖHÄ", "KESKIYÖ",
            "NATT", "SKUMRING", "KVELD", "SEN KVELD", "SOLNEDGANG", "SENT", "MIDNATT",
            "NAT", "SKUMRING", "AFTEN", "SEN AFTEN", "SOLNEDGANG", "SEN", "MIDNAT"
        ],
        same: [
            "LATER", "MOMENTS LATER", "CONTINUOUS", "SAME", "SIMULTANEOUSLY",
            "SENARE", "LITE SENARE", "ÖGONBLICKET SENARE", "FORTSÄTTNING", "DIREKT FORTSÄTTNING", "SAMMA", "SAMTIDIGT",
            "SPÄTER", "EINIGE ZEIT SPÄTER", "KONTINUIERLICH", "DASSELBE", "GLEICHZEITIG",
            "SPÄTER", "EENIGE TIEDEN SPÄTER", "DURCHGEHEND", "DASSELVE", "GLEIKTIEDIG",
            "PLUS TARD", "QUELQUES INSTANTS PLUS TARD", "CONTINU", "MÊME", "SIMULTANÉMENT",
            "MÁS TARDE", "MOMENTOS MÁS TARDE", "CONTINUO", "IGUAL", "SIMULTÁNEAMENTE",
            "MYÖHEMMIN", "HETKEÄ MYÖHEMMIN", "JATKUVA", "SAMA", "SAMANAIKAINEN",
            "SENRE", "ØYEBLIKK SENRE", "KONTINUERLIG", "SAMME", "SAMTIDIG",
            "SENERE", "ØJEBLIKKE SENERE", "KONTINUERLIG", "SAMME", "SAMTIDIG"
        ]
    }

var articleArray = ["THE", 
                    "LE", "LA", 
                    "EL", "IL", 
                    "DER", "DIE", "DAS", 
                    "O", "A", 
                    "DE", "HET"]



</script><style>

#tracking * {

    line-height: 16px !important;
    white-space: normal;
}

#tracking *:focus{
    outline: none !important;
}

html[data-outdoors='1'] #flexiContainer .dimmedScene,
html[data-outdoors='1'] #flexiContainer.indexcards .dimmedScene > .sceneheading {

    border-color: #ddd !important;
    border-style: dotted !important;

}

html[data-outdoors='1'] #flexiContainer .dimmedScene > .sceneheading{

    color: #ddd !important;

}

#characterButton:is(.red, .orange, .yellow, .green, .teal, .cyan, .blue, .purple, .magenta, .pink, .brown, .grey, .black, .white) {
    background: none !important;
    opacity: 1 !important;
    transition: none !important;
}

#characterButton.red > svg path{
    fill: hsla(var(--red),100%) !important;
}
#characterButton.orange > svg path{
    fill: hsla(var(--orange),100%) !important;
}
#characterButton.yellow > svg path{
    fill: hsla(var(--yellow),100%) !important;
}
#characterButton.green > svg path{
    fill: hsla(var(--green),100%) !important;
}
#characterButton.teal > svg path{
    fill: hsla(var(--teal),100%) !important;
}
#characterButton.cyan > svg path{
    fill: hsla(var(--cyan),100%) !important;
}
#characterButton.blue > svg path{
    fill: hsla(var(--blue),100%) !important;
}
#characterButton.purple > svg path{
    fill: hsla(var(--purple),100%) !important;
}
#characterButton.magenta > svg path{
    fill: hsla(var(--magenta),100%) !important;
}
#characterButton.pink > svg path{
    fill: hsla(var(--pink),100%) !important;
}
#characterButton.brown > svg path{
    fill: hsla(var(--brown),100%) !important;
}
#characterButton.black > svg path{
    fill: hsla(var(--black),100%) !important;
}
#characterButton.white > svg path{
    fill: hsla(var(--white),100%) !important;
}
#characterButton.grey > svg path{
    fill: hsla(var(--grey),100%) !important;
}

.section:not(.level1).dimmedSection:hover>.section-heading:not(#flexiContainer.sectionCards .section-heading){
    background-color: rgba(40,40,40,1) !important;
}

.rightfloat{
    float: right;
    width: 50% !important;
    height: 100% !important; 
    padding-right: 0px !important;
}

#tracking button {
    text-align: right;
}

.buttonIsActive {
    opacity: 100% !important;
}

svg {
    transition: 0.2s !important;
    pointer-events: none; /* Or else the icon blocks itself from being clicked. Very weird. */
}

.buttonIsActive svg {
    transform: scale(0.7) translateY(2px) !important;
    pointer-events: none; /* Or else the icon blocks itself from being clicked. Very weird. */

}

#indexCardButton.buttonIsActive svg {
    transform: scale(1) translate(0px, 0px) !important;
}

.bullets {
    margin-left: 20px;
}

.bullets::before{
    content: "•";
    margin-left: -20px;
}

#upperframe, #trackingoutro{
    max-width: 560px;
    margin-left: auto;
	margin-right: auto;
}

#selectedCharacterName, #indexCardText{
    font-size: 9px;
    font-weight: 500;
    line-height: 10px;
    text-transform: uppercase;
    transform: translateY(calc(-100% - 23px)) translateX(calc(-50% + 16px));
    width: 60px !important;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none; /* Or else the icon blocks itself from being clicked. Very weird. */
}

#indexCardText{
    transform: translateY(calc(-100% - 29px)) translateX(calc(-50% + 16px));

}

#indexCardBkg{
    padding-left: 50px !important;
    padding-top: 3px !important;
    font-size: 9px;
    font-weight: 500;
    line-height: 12px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.4)

}

/*@todo remmed out all these SELECT stuffs*/

#selectlistparent{

    width: 50% ;
}

select, select * {
    
    height: 100% !important;
    width: 100% !important;
    border-radius: 6px !important;
    border: 1px inset;

    overflow-y: scroll;
    overflow-x: hidden;

    font-size: 14px !important;
	line-height: 18px !important;
	font-weight: 500;

    padding: 10px !important;

    list-style-position: outside;
    
}

#tracking select {

    min-height: 500px;

}

option {
    line-height: 20px !important;
    width: 100% !important;
    padding: 4px !important;
}

option:nth-of-type(even){
    background: #eee;

}

option:checked{
    background: #027aff !important;
    background-color: #027aff !important;
    border: 1px gold dotted
}

#tracking .normalWindowText{
    width: 50%;
    float: left;
    padding-right: 15px !important;
}

.normalWindowText li {
    list-style-position: outside !important;
}

ul {
    margin-left: -20px;
}

li {
    margin-top: 6px !important;
    display: list-item;
    list-style-position: outside !important;
}

#okbutton2, #deselectAllCharacters {
	font-size: 14px; 
    margin-top: 15px; 
    margin-bottom: 15px !important;
	padding: 5px 0px 5px auto;
}

.scriptTextInWindow {
    font-family:'Courier Prime','Courier New', Courier, monospace; 
    font-size: 13.5px !important;
    font-weight: bold;
    letter-spacing: -0.3px;
    padding-bottom: 0px !important;
    padding-top: 1px !important;
    line-height: 16px !important;
}

/* html[data-outdoors='1'] #flexiContainer .section.dimmedSection{

    color: purple
    
} */

html[data-outdoors='1'] .dimmedSection > .section-heading:not(#flexiContainer.indexCards .section-heading),
html[data-outdoors='1'] #flexiContainer .dimmedSection > .section-heading {

    color: #ddd !important;
    opacity: 1;
    border: 1px dotted #ddd !important;
    
}

</style>

<div id="tracking" class="settingsWindow" style="display: none;" onblur="toggleTrackingContainer()">
   
    <div id="selectlistparent" class="rightfloat" style="height: calc(100% - 40px) !important; text-align: right !important;">
    <select style="height: 100% !important;" multiple onchange="updateFilter()" id="characterMenuList"></select><br/>
    
    <button class="generalButtonStyle" id="deselectAllCharacters" onclick="deselectAllCharacters()">Deselect all</button>
        <!--p id="okbuttonpara2"-->
        <button class="generalButtonStyle" id="okbutton2" type="button" onclick="toggleTrackingContainer()">Close</button><!--/p-->

    </div>

    <div  id="trackertext"><p class="normalWindowText"><span class="headline"><br/>Track characters</span><br/><br/>

        Select characters in the list to highlight scenes where they appear.<br/><br/>
        CMD + click to select multiple.<br/><br/> 
        Selecting more than one name will highlight scenes where ALL characters are present.<br/><br/>
        
        
    </p>
    </div>
    
</div>

<script>

var iCameFromToggleCharacter = false
var iCameFromMenu = false
var scenesWithCharacters = []
var searchBoxDelay

var globalScenesWithDialog = []


function collectCharacters(preselectedCharacter) {

    // important note: when this was part of the plugin back-and-forth, the plugin ended this by calling updateFilter()
    // since I do not call updateFilter from the end of this function, be vigilant about whether this may case problems
    // (and no, I don't dare calling updateFilter from here, in case this function should be able to be called without)

    mylog()
    console.time("collectCharacters2023")

    if(!outline) return

    let removal = userDefault.excludeVoiceOvers ? /(\(.+\))$/ : ""
    let allCharacters2023 = lines.filter(line => line.typeAsString == "Character" && !line.omitted).map(line => 
        line.string.replace(/^\^*@*/, "")   /* removes dual dialog ^ or forced dialog @ */
        .replace(/\'/g, `’`)                /* replaces that pesky apostrophe that creates so much problems */
        .replace(removal, "").trim())       /* if characters with extensions count as the main character, remove the extension */ 

    //sort the characters by how many times they appear in the script
        const characterCounts = allCharacters2023.reduce((acc, val) => {
            if (!acc[val]) {
                acc[val] = 1;
            } else {
                acc[val]++;
            }
            return acc;
            }, []);

        const sortedCharacters = Object.keys(characterCounts).sort((a, b) => {
            return characterCounts[b] - characterCounts[a];
        });

    //collect all characters in each scene, with different options
        let outlineElementsWithCharactersDialogOnly = []
        let outlineElementsWithCharactersIncludingAction = []
        let outlineElementsWithCharactersInSynopsisOnly = []
        let scenesWithDialog2023 = []

        let outlineElementNumber = -1
        let trimmedName
        let wordsplitters = /[,.:;!?\)\(\s\")]+/ //for now, I have removed apostrophes \' from wordsplitters to catch names like O'Neil
        for (line of lines){

            //if (line.omitted) continue

            if (line.typeAsString == "Heading" || line.typeAsString == "Section"){
                outlineElementNumber ++
                outlineElementsWithCharactersDialogOnly[outlineElementNumber] = []
                outlineElementsWithCharactersIncludingAction[outlineElementNumber] = []
                outlineElementsWithCharactersInSynopsisOnly[outlineElementNumber] = []
                scenesWithDialog2023[outlineElementNumber] = []
            }
            
            if (line.typeAsString == "Character" && !line.omitted){
                trimmedName = line.string.replace(/^@/, "").toUpperCase().replace(removal, "").replace(/\'/, "’").trim() 
                if(sortedCharacters.some(character => character.toUpperCase() == trimmedName.toUpperCase())){
                    if (!outlineElementsWithCharactersDialogOnly[outlineElementNumber]?.includes(trimmedName)) {
                        outlineElementsWithCharactersDialogOnly[outlineElementNumber].push(trimmedName)
                    }
                    if (!outlineElementsWithCharactersIncludingAction[outlineElementNumber]?.includes(trimmedName)) {
                        outlineElementsWithCharactersIncludingAction[outlineElementNumber].push(trimmedName)
                    }
                }
                alsoCollectDialog()
            }
            if (line.typeAsString == "Action" && !line.omitted){
                sortedCharacters.forEach(character => {
                    apostrophedCharacter = character.replace(/’/g, `\'`) //replacing character BACK to normal apostrophe when comparing to avoid repeating for every word
                    if (compareThese(line.string, apostrophedCharacter)) { 
                        if (!outlineElementsWithCharactersIncludingAction[outlineElementNumber]?.includes(character)) {
                            outlineElementsWithCharactersIncludingAction[outlineElementNumber].push(character.toUpperCase());
                        }
                    }
                })
            }
            if (documentSetting.trackingIncludesSynopsis && line.typeAsString == "Synopse"){
                sortedCharacters.forEach(character => {
                    apostrophedCharacter = character.replace(/’/g, `\'`) //replacing character BACK to normal apostrophe when comparing to avoid repeating for every word
                    if (compareThese(line.string, apostrophedCharacter)) { 
                        if (!outlineElementsWithCharactersInSynopsisOnly[outlineElementNumber]?.includes(character)) {
                            outlineElementsWithCharactersInSynopsisOnly[outlineElementNumber].push(character);
                        }
                    }
                })
            }
        }

        function alsoCollectDialog(){

            if (!($id("notepanel").classList.contains("expanded") && $(".selectedtab").classList.contains("dialogtab"))) return

            let additionalLines = 0
            let currentLine = lines.indexOf(line)
        
            while (["Character", "Dialogue", "Parenthetical"].includes(lines[currentLine + additionalLines]?.typeAsString)){

                scenesWithDialog2023[outlineElementNumber].push({
                    "character": trimmedName,
                    "position": lines[currentLine + additionalLines].position,
					"string": lines[currentLine + additionalLines].string, 
					"typeAsString": lines[currentLine + additionalLines].typeAsString,
					"omitted": lines[currentLine + additionalLines].omitted,
					"currentLine": lines[currentLine + additionalLines],
                })
                additionalLines ++
            }
        }

        function compareThese(string, character){

            if (!string.toLowerCase().includes(character.toLowerCase())) return false //to avoid having to loop through all words if not even present

            // FIRST, if the character has multiple words, let not split the line but compare directly. 
            // This will demand at least one uppercase letter in the match (to avoid matching "OLD BROWN" with "his old brown hat")
            // which unfortunately means not matching "the third thug" in action with a speaking character "THE THIRD THUG"
            // This seems like a reasonable trade-off for now, and will catch "Dr. Zjivago" and "Sheila's mother", both of which are more important.
            if (character.includes(" ")){
                // if (string.toLowerCase().includes(character.toLowerCase)) return true
                const regex = new RegExp(character, 'i');
                const match = string.match(regex);
                    if (match && match[0] != match[0].toLowerCase()) {
                    return true;
                    }
            } 

            //THEN, more time-consuming word-by-word comparisons for single-word characters
            
            let words = string.split(wordsplitters)

            if (words.includes(character)) return true //spelling is exactly as once captured (text: McLaren, original: @McLaren)
            if (words.includes(toInitialsCase(character))) return true //spelling is like a name, regardless of case when captured. (text: Mclaren)
            if (words.includes(character.toUpperCase())) return true //character is typed in caps now but perhaps not when captured (text: MCLAREN)

            //Below is a test to see if we can also get McLaren as well as McLAREN, and if so at what cost?
            if (words.some(word => (word.charAt(0) + word.slice(1).toLowerCase()) === (character.charAt(0) + character.slice(1).toLowerCase()))) return true;

            return false
        }

    //Finally, here's an array with characters in both action AND synopsis
    let outlineElementsWithChactersAnywhere = 
        outlineElementsWithCharactersIncludingAction.map((characters, index) => 
            characters.concat(outlineElementsWithCharactersInSynopsisOnly[index])
        )

    console.timeEnd("collectCharacters2023")

    //For now, in order to be able to use old code, let's merge this into the old variable names! Aug 2023

        allCharacters = sortedCharacters
        globalAllCharacters = allCharacters
        scenesWithCharactersProxy = 
            // documentSetting.trackingIncludesSynopsis ? outlineElementsWithCharactersInSynopsisOnly : outlineElementsWithCharactersIncludingAction
            documentSetting.trackingIncludesSynopsis ? outlineElementsWithChactersAnywhere : outlineElementsWithCharactersIncludingAction

    //Here's the old code:
    //from here, we should potentially make it a new function called applycharactes

    if ((!scenesWithCharacters.length) || (scenesWithCharacters != scenesWithCharactersProxy)){

        let previouslySelectedCharacters = Array.of(preselectedCharacter) || null
        let reselectThese = []

        let itemNumber = 0
        scenesWithCharacters = scenesWithCharactersProxy //workaround to make this globally accessible

        //remember what characters in the menu were selected before
            if ($id("characterMenuList").selectedOptions){        
                previouslySelectedCharacters = Array.from($id("characterMenuList").selectedOptions)
                for (character of previouslySelectedCharacters){
                    reselectThese.push(character.value)
                }
            }

        //populating/re-populating the character menu and track dialog menu (in case something changed)
            $id("characterMenuList").innerHTML = "" 
            $id("allDialogFor").innerHTML = "<option class='menuitem' value='ALL'>ALL</option>" 

            for (item of allCharacters){
                
                itemNumber ++

                $id("characterMenuList").innerHTML += 
                    `<option class='menuitem' value='${item}'>
                        ${itemNumber<10 ? `(${itemNumber})  ` : `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}
                        ${item}
                    </option>`

                $id("allDialogFor").innerHTML += `
                    <option class='menuitem' value="${item}">
                        ${item}
                    </option>`
            }

        //and reselect those we remembered previously
            if (reselectThese.length){
                for (character of reselectThese){
                    for (i = 0; i < characterMenuList.length; i++){
                        if (characterMenuList[i].value == character){
                            characterMenuList.options[i].selected = true;
                        }
                    }
                }
            }
    }

    if (iCameFromToggleCharacter && allCharacters.length > 0){
        toggleSoloCharacter(iCameFromToggleCharacter[0], iCameFromToggleCharacter[1])
    }

    if (iCameFromMenu){
        iCameFromMenu = false
        trackingMenu()
    }

    if(trackingContainerVisibility == 1){
        document.getElementById("characterMenuList").focus()
    }

    mylog("end of collect")

    // FINALLY, added for 2023 version:
    // make the dialog global so as to be available for the dialogpanel
        globalScenesWithDialog = scenesWithDialog2023

}

function alsoFillColorDropdown(){

    let dropdown = "<option>(None)</option>"
    let alreadySelected = false

    for (let color of colorsArray){
        if (color == "Remove Color" || color == "Special"){continue}

        if ($(".scene." + color.toLowerCase() + ", .section." + color.toLowerCase())){
            dropdown += "<option>" + color + "</option>"

            if ([...document.getElementById("flexiContainer").classList].includes(color.toLowerCase())){
                alreadySelected = color
            }
        }
    }

    document.getElementById("colorDropdown").innerHTML = dropdown   
    document.getElementById("colorDropdown").value = alreadySelected || "(None)"

}

function updateFilter(scenesWithCharactersProxy){

    mylog()    

    let allScenes = $$('.scene')
    let allSections = $$('.section')

    //if (scenesWithCharactersProxy) {scenesWithCharacters = scenesWithCharactersProxy} //again making it global

    let selectedCharacters = $id("characterMenuList").selectedOptions

    if (selectedCharacters.length){

        for (section of allSections){section.classList.add("dimmedSection")}
        for (scene of allScenes){scene.classList.add("dimmedScene")}
        
            for (i=0; i<outline.length; i++){
                //if (outline[i].typeAsString == "Heading" || outline[i].typeAsString == "Section"){
                    let num = i

                    let removeDim = false
                    if (scenesWithCharacters[num]){

                        
                        removeDim = true
                        for (currentCharacter of selectedCharacters){

                            if (!scenesWithCharacters[num].includes(currentCharacter.value.toUpperCase())) {
                            removeDim = false
                            }
                        }
                    }

                    if (removeDim == true){$id(i).classList.remove("dimmedScene")}
                    if (removeDim == true){$id(i).classList.remove("dimmedSection")}

                //}
            }
    }
    else
    {
        for (scene of allScenes){scene.classList.remove("dimmedScene")}
        for (section of allSections){section.classList.remove("dimmedSection")}
    }

    mylog("dimming is done")

    if (characterMenuList.selectedIndex == -1){
        document.getElementById("characterButton").classList.remove("buttonIsActive")
        document.getElementById("selectedCharacterName").innerHTML = ""
    }else{
        document.getElementById("characterButton").classList.add("buttonIsActive")

        let selectedCharacters = document.getElementById("characterMenuList").selectedOptions
        document.getElementById("selectedCharacterName").innerHTML = ""
        for (currentCharacter of selectedCharacters){
            document.getElementById("selectedCharacterName").innerHTML += currentCharacter.value + "<br/>"
        }
    }

    updateSelectionInfo()
    mylog("end of UpdateFilter")
}

function deselectAllCharacters() {
    characterMenuList.selectedIndex = -1; 
    if($id("trackingMenu")){trackingMenu()}
    updateFilter()
}

function toggleSoloCharacter(theKey, actualName) {
    mylog()
    mylog("theKey is " + theKey + "")

    if (!characterMenuList || characterMenuList.length == 0) {

        iCameFromToggleCharacter = [theKey, actualName]
        
        collectCharacters()
        return
    }

    if(actualName){

        for (theKey = 0; theKey < characterMenuList.length; theKey ++) {
            
            if (actualName.toUpperCase() == characterMenuList.options[theKey].value.toUpperCase()){
                theKey ++ //because soon to be reduced by one in the old code
                break
            }
        }
    }

    theKey -- //shifts one down to zero-based array, but shortcuts starting with 1

    if (event && (event.shiftKey || event.metaKey)){
        let a = characterMenuList.options[theKey].selected == false;
        characterMenuList.options[theKey].selected = a;
    }
    else
    {
        if (characterMenuList.selectedIndex != theKey){
            characterMenuList.selectedIndex = theKey 
            }else{
            characterMenuList.selectedIndex = -1; 
        }
    }
    iCameFromToggleCharacter = false

    mylog("exiting, just before sending to updateFilter()")

    if($id("trackingMenu")){trackingMenu()}
    updateFilter()
}

function simulateAltClick(){

    let theSelections = document.getElementById("colorDropdown").selectedOptions
    let theSelection = theSelections[0].value
    
    if ($id("flexiContainer").classList.contains("uncolorAllScenesBut")){
        muteColors()    
    } //i.e. if already on, this toggles it off before selecting new color

    if (theSelection != "(None)"){ //do not toggle on if user chose "none"
        muteColors($(`.scene.${theSelection.toLowerCase()}, .section.${theSelection.toLowerCase()}`))
    }

    deselectAllElements()

}


function muteColors(theClickedThing, shift){

    mylog(theClickedThing?.classList)
    // alertThis(theClickedThing.classList)
    
    if (!shift && $id("flexiContainer").classList.contains("uncolorAllScenesBut")){
        $id("flexiContainer").classList.remove("uncolorAllScenesBut")
        for (let color of colorsArray){
            if($id("flexiContainer").classList.contains(color.toLowerCase())){
                $id("flexiContainer").classList.remove(color.toLowerCase())
                $id("characterButton").classList.remove(color.toLowerCase())
            }
        }
        updateSelectionInfo()
        return
    }

    if(!theClickedThing || !theClickedThing.closest(".synopsis, .scene, .section")){
        mylog("returning bc no closest scene or section")
        return
    }
    
    $id("flexiContainer").classList.add("uncolorAllScenesBut")
    theClickedThing = theClickedThing.closest(".synopsis, .scene, .section")

    let foundOne = false

    for (let color of colorsArray){
        if(theClickedThing.classList.contains(color.toLowerCase())){
            document.getElementById("flexiContainer").classList.add(color.toLowerCase())
            document.getElementById("characterButton").classList.add(color.toLowerCase())
            foundOne = true
            break
        }
    }

    if (!foundOne && theClickedThing.classList.contains("synopsis")){
        
        theClickedThing = theClickedThing.closest(".scene, .section")
        muteColors(theClickedThing, true)
    }
    
    deselectAllElements()
    updateSelectionInfo()
}

function _____________(){}

function initiateCharacterBubbles(characterName = "ALL"){

    collectCharacters(characterName)

    //$id("allDialogFor").selectedIndex = 0

    showCharacterBubbles(characterName)

}

function unShowCharacterBubbles(){

    $$(".sceneChunk").forEach( chunk => { chunk.remove() }) 
    $$(".connectorcontainer").forEach( connector => { connector.remove() })
    $$(".displayNumberOf").forEach( numberof => { numberof.remove() })

    if(!$id("dialogsearch")?.value) {deselectAllCharacters()} //avoid blinkage: don't remove "dimmedScene" if filtering underway

    $$(".scene .orphan").forEach(element => {
        element.removeEventListener("mouseenter", function(){
            selectSceneChunk($id("dialogIn" + element.id)?.closest(".sceneChunk"))
            scrollNicelyIntoView($id("dialogIn" + element.id), $id("dialogpanelcontent"))
        })
    })

}

function selectSceneChunk(sceneChunk){

    if(!sceneChunk) return

    $$(".selectedSceneChunk").forEach(sceneChunk => {sceneChunk.classList.remove("selectedSceneChunk")})
    sceneChunk.classList.add("selectedSceneChunk")

}


function cycleBubbles(direction){ //send here: -1 or +1

    if(!$("#notepanel.expanded .dialogtab.selectedtab")){cycleTabs($(".dialogtab"))}

    let allChunks = Array.from($$(".dialogChunk"))
    if(!allChunks || allChunks.length == 0) {
        initiateCharacterBubbles()
        return
    }
    
    let selectedNumber = allChunks.indexOf($(".dialogChunk.selectedDialog"))
    if(selectedNumber < 0) return //no, make it current?
    
    selectedNumber += Number(direction)
    
    if (selectedNumber > allChunks.length - 1) selectedNumber = 0
    if (selectedNumber < 0) selectedNumber = allChunks.length - 1

    selectThisDialog(allChunks[selectedNumber].id, true) //if not true, no scroll

}

function selectThisDialog(dlgId, andScroll = false){

    let currentChunk = $(".hoveredSceneChunk")

    $$(".selectedDialog")?.forEach(element => {element.classList.remove("selectedDialog")})
    $$(".isHovered")?.forEach(element => {element.classList.remove("isHovered")})
    $$(".hoveredSceneChunk")?.forEach(chunk =>{chunk.classList.remove("hoveredSceneChunk")})

    $id(dlgId)?.classList.add("selectedDialog")
    $id(dlgId)?.closest(".sceneChunk").classList.add("isHovered")
    $id(dlgId)?.closest(".sceneChunk").classList.add("hoveredSceneChunk")
    
    $id($id(dlgId)?.closest(".sceneChunk").dataset.parentId)?.classList.add("isHovered")

    if($(".hoveredSceneChunk") != currentChunk) {
        createOrUpdateConnectorFor($(".hoveredSceneChunk"))
    }

    if(andScroll) { scrollNicelyIntoView($id(dlgId) || $(".hasCursor"), $id("dialogpanelcontent")) }

}



function updateDialogPanel(scenesWithDialog){

    if (!($id("notepanel").classList.contains("expanded") && $(".selectedtab")?.classList.contains("dialogtab"))){ return }

    let alreadySelected = $id("allDialogFor").selectedOptions[0]?.innerText.trim() || "ALL"

    collectCharacters()
    showCharacterBubbles(alreadySelected, true)

}

function showCharacterBubbles(characterName, redraw){

    mylog()

    console.time("bubbles")

    // re-select already selected character!
        if(characterName){
            $id("allDialogFor").selectedIndex = ([...$id("allDialogFor").options].map(option => option.value.toUpperCase())).indexOf(characterName) || 0
        }else{
            characterName = $id("allDialogFor").selectedOptions[0]?.innerText.trim() || "ALL"
        }
    
    let scrolledAmountBeforeRedraw = $id("dialogpanelcontent").scrollTop
    let allChunks = $$(".sceneChunk")
    
    //when chunks already present, clean up before doing anything else:
        if(allChunks.length > 0){  
            unShowCharacterBubbles()
        }

    //if no character is selected, loop all dialog, otherwise only loop dialog for selected character
        let selectedScenesWithDialog = characterName == "ALL" ? globalScenesWithDialog : globalScenesWithDialog.map(scene => scene.filter(line => line.character == characterName))
    
    for (let scene of selectedScenesWithDialog){

        let theId = selectedScenesWithDialog.indexOf(scene)
            
        // This PROBABLY helps against a bug PROBABLY caused by the scenes being updated from the plugin while this loop is running
            if(!$id(theId)) break 

        let orphanId
            if($id(theId)?.classList.contains("section")){
                orphanId = $id(theId).querySelector(".orphanText")?.id
            }

        if (scene.length == 0) continue

        let chunk = document.createElement("div")
            
            chunk.id = "dialogIn" + theId
            chunk.dataset.orphanId = orphanId
            chunk.dataset.parentId = theId
            chunk.style.color = $id(theId).querySelector(".sceneheading").style.color
            chunk.style.marginBottom = "3px"
            chunk.dataset.charactername = characterName
                chunk.onmouseenter = function(){
                    $id(chunk.dataset.parentId).classList.add('isHovered')
                    createOrUpdateConnectorFor(chunk) 
                }
                chunk.onmouseleave = function(){
                    $id(chunk.dataset.parentId).classList.remove('isHovered')
                    $$(".connector").forEach(connector => {connector.remove()})
                }
            chunk.classList.add("sceneChunk")
            chunk.style.width = "100%"
            if (outline[theId].omitted) chunk.classList.add("omitted")

            chunk.innerHTML = `<p class="chunkHeading"><span style="opacity: 0.4;">${(outline[theId].sceneNumber || "")} </span>&nbsp;${outline[theId].stringForDisplay}</p>`

            let createdChunks = []
            let chunkNumber = -1

            for (line of scene){

                
                if (line.typeAsString == "Character"){

                    chunkNumber ++

                    createdChunks[chunkNumber] = document.createElement("div")
                    createdChunks[chunkNumber].classList.add("dialogChunk")
                    createdChunks[chunkNumber].id = "dialog" + line.position
                    createdChunks[chunkNumber].dataset.line = line.position
                    createdChunks[chunkNumber].onclick = function(){selectThisDialog("dialog" + line.position)}

                    //continue
                }

                let omittedString = ""
                if(line.omitted) omittedString = " omitted"

                createdChunks[chunkNumber].innerHTML += `<p class="${line.typeAsString.toLowerCase()} ${omittedString}" data-line="${line.position}" data-end-pos="${line.position + line.string.length}" data-length="${line.string.length}"><span class="debug">${line.position}-${line.position + line.string.length}</span>${line.string}</p>`

                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\/\*(.*)\*\//g, "<span class='omitted'>$1</span>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\*\*\*(.*)\*\*\*/g, "<b><i>$1</i></b>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\*\*(.*)\*\*/g, "<b>$1</b>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\*(.*)\*/g, "<i>$1</i>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\_(.*)\_/g, "<u>$1</u>")

                //hack to update the endPos of the chunk for as long as we keep adding to it
                    createdChunks[chunkNumber].dataset.endPos = line.position + line.string.length
                    createdChunks[chunkNumber].querySelector(".debug").innerText = createdChunks[chunkNumber].dataset.line + "-" + createdChunks[chunkNumber].dataset.endPos
                
            }

            for (createdChunk of createdChunks){

                chunk.appendChild(createdChunk)

            }

            chunk.dataset.startPos = chunk.firstChild.data-line
            chunk.dataset.endPos = chunk.lastChild.data-line + chunk.lastChild.innerText.length

            //and the sceneChunk to the sidepanel:          
                $id("dialogpanelcontent").appendChild(chunk)

            if($id("dialogsearch").value) chunk.classList.add("displayNone")
                //chunkSizes = chunk.getBoundingClientRect()

        //add number of dialogs to corresponding scene

            let displayNumberOf = document.createElement("div")

            $id(orphanId || theId).appendChild(displayNumberOf)

                displayNumberOf.id = "displayNumberOf" + theId //chunk.id
                displayNumberOf.dataset.parentId = theId
                displayNumberOf.classList.add("displayNumberOf")
                displayNumberOf.classList.add("dontDim")
                displayNumberOf.style.position = "absolute"
                displayNumberOf.style.top = "50%"
                displayNumberOf.style.left = "50%"
                
                displayNumberOf.textContent = chunk.querySelectorAll(".dialogChunk").length

                displayNumberOf.onmouseenter = onmouseenterForDNO                
                    function onmouseenterForDNO(){
                        $id("dialogIn" + theId).classList.add("hoveredSceneChunk") 
                    }

                displayNumberOf.onmouseleave = onmouseleaveForDNO                
                    function onmouseleaveForDNO(){
                        $id("dialogIn" + theId).classList.remove("hoveredSceneChunk") 
                    }
                displayNumberOf.onclick = onclickForDNO                
                    function onclickForDNO(){
                        selectSceneChunk(chunk)
                        scrollNicelyIntoView(chunk.querySelector(".dialogChunk") || chunk, $id("dialogpanelcontent"))
                    }

        //must set color after "displaynumberof", or else getcomputedstyle delivers blank    
            chunk.style.setProperty("--localColor", window.getComputedStyle($id(theId)).backgroundColor)
            chunk.style.backgroundColor = "var(--localColor)"


        //set listeners to the chunks of the scene

            // $$(".dialogChunk").forEach(element => {

            //     element.onclick = function(){
            //         $$(".hasCursor").forEach(otherElement => {otherElement.classList.remove("hasCursor")});
            //         $$(".selectedDialog").forEach(otherElement => {otherElement.classList.remove("selectedDialog")});
            //         element.classList.add("hasCursor")
            //         element.classList.add("selectedDialog")
            //     }
            // })
    }

    $id("dialogpanelcontent").scrollTo({
        top: scrolledAmountBeforeRedraw,
        left: 0,
        behavior: 'instant'
        });

    $id("dialogpanelcontent").onscroll = function(){ updateDialogPanelOnScroll() }
    if($id("dialogsearch").value) onlyShowMatchingDialogs(true)

    console.timeEnd("bubbles")

}

function updateDialogPanelSelection(){

    if (!($id("notepanel").classList.contains("expanded") && $(".selectedtab")?.classList.contains("dialogtab"))){ return }

    let cursorPosition = Number($id("youAreHere").dataset.location)

    $$(".selectedDialog")?.forEach(element => {element.classList.remove("selectedDialog")})
    $$(".dialogChunk")?.forEach(element => {element.classList.remove("hasCursor")})

    let bestMatch = Array.from($$(".dialogChunk")).find(element => Number(element.dataset.line) <= cursorPosition && Number(element.dataset.endPos) >= cursorPosition)
    let bestMatchClosestChunk = bestMatch?.closest(".dialogChunk")
        //console.log(cursorPosition, bestMatch?.dataset.line, bestMatch?.dataset.endPos, bestMatchClosestChunk?.textContent)
        bestMatchClosestChunk?.classList.add("selectedDialog", "hasCursor")

    scrollNicelyIntoView($(".hasCursor"), $id("dialogpanelcontent"))

}

function updateDialogPanelOnScroll(){

    let hoveredChunk = $(".sceneChunk.hoveredSceneChunk, .sceneChunk:hover")

    let elementSizes = hoveredChunk?.querySelector(".chunkHeading").getBoundingClientRect()
        if(elementSizes && $id("connector")){
            let chunkCorner = Math.min(Math.max((elementSizes.top + elementSizes.height/2), $id("dialogpanelcontent").getBoundingClientRect().top), $id("dialogpanelcontent").getBoundingClientRect().bottom)

            $id("connector")?.style.setProperty("--chunkCorner", chunkCorner + "px")
            $id("connector")?.style.setProperty("--containerHeight", ($id("connectorcontainer").getBoundingClientRect().height) + "px")
        }

        if((elementSizes?.top < 0 || elementSizes?.top > $id("dialogpanelcontent").getBoundingClientRect().height) && $id("connector")) $id("connector").remove()

    $$(".chunkHeading").forEach(head =>{ head.classList.toggle("isStuck", head.offsetTop > 0) })

}

function createOrUpdateConnectorFor(element){

    if(!element) return

    let delay = ($id(element.closest(".sceneChunk").dataset.parentId).classList.contains("isOmitted")) ? 250 : 0

    setTimeout(() => {

        if(!$(".connectorcontainer")){

            let connectorcontainer = document.createElement("div")
                connectorcontainer.id = "connectorcontainer"
                connectorcontainer.classList.add("connectorcontainer")
                connectorcontainer.style.position = "absolute"
                connectorcontainer.style.top = "0px"
                connectorcontainer.style.left = "0px"
                connectorcontainer.style.right = "0px"
                connectorcontainer.style.bottom = "0px"
                connectorcontainer.style.pointerEvents = "none"
                connectorcontainer.style.zIndex = "99999"
            document.body.appendChild(connectorcontainer)
        }

        let connector = $id("connector") || document.createElement("div")
            
            // let elementSizes = element.getBoundingClientRect()
            let elementSizes = element.querySelector(".chunkHeading").getBoundingClientRect()
            let connectedScene = $id(element.closest(".sceneChunk").dataset.parentId)
                if (connectedScene.classList.contains("section")) connectedScene = connectedScene.querySelector(".section-heading")
            let connectedSceneSizes = /*connectedScene.querySelector(".sceneheading")?.getBoundingClientRect() ||*/ connectedScene.getBoundingClientRect()
            let nextSceneSizes = {top: 0}
            let nextVisibleScene
                if (window.getComputedStyle(connectedScene).display == "none"){
                    nextVisibleScene = connectedScene
                    while ($id(Number(nextVisibleScene.id) + 1) && window.getComputedStyle(nextVisibleScene).display == "none") {
                        nextVisibleScene = $id(Number(nextVisibleScene.id) + 1)
                    }
                    nextSceneSizes = nextVisibleScene?.getBoundingClientRect()
                }
                connectedScene.classList.add("isHovered")

                connector.id = "connector"
                connector.classList.add("connector")
                connector.dataset.parentId = element.closest(".sceneChunk").dataset.parentId
                
                connector.style.position = "absolute"
                connector.style.left = (elementSizes.right) + 3 + "px" //was 18
                connector.style.width = ((connectedSceneSizes.left || nextSceneSizes.left) - flexiContainer.getBoundingClientRect().left + 14) + "px"
                connector.style.setProperty("--maxHeightOfDot", Math.max(Math.min(connectedSceneSizes.height - 2, 8), 0.1) + "px")

                // let chunkCorner = (elementSizes.top + elementSizes.height/2)
                let chunkCorner = Math.min(Math.max((elementSizes.top + elementSizes.height/2), $id("dialogpanelcontent").getBoundingClientRect().top), $id("dialogpanelcontent").getBoundingClientRect().bottom)
                
                connector.style.setProperty("--chunkCorner", chunkCorner + "px")
                connector.style.setProperty("--sceneCorner", ((connectedSceneSizes.top + connectedSceneSizes.height/2) || nextSceneSizes.top) + 0 + "px")
                connector.style.setProperty("--containerHeight", (connectorcontainer.getBoundingClientRect().height) + "px")
                connector.style.setProperty("--localColor", connectedScene.style.getPropertyValue("--localColor") || window.getComputedStyle(connectedScene).backgroundColor)
                
                connector.setAttribute("viewBox", "-100 -100 1100 1100")

                connector.innerHTML = `<svg height="100%" width="100%" viewBox="0 0 1000 1000" preserveAspectRatio="none" vector-effect="non-scaling-stroke">
                    <g>
                        <!--circle class="bottomdot" cx="0" cy="0" r="8px" vector-effect="non-scaling-stroke" /-->
                        <path class="bottomstroke" stroke-dasharray="1,4" stroke-linecap="round" d="M0,0 C900,0 100,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                        <path class="topstroke" stroke-dasharray="1,4" stroke-linecap="round" d="M0,0 C900,0 100,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                    </g></svg>`

                if(!$id("connector")) connectorcontainer.appendChild(connector)

    }, delay)

}

function searchboxlisten(){

    mylog(event)

    let keypress = event.key

    if(keypress == "Escape"){
        event.preventDefault()
        event.stopPropagation()
        clearSearchBox()
    }

}

function clearSearchBox(){

    $id("dialogsearch").value = ""
    $id("allDialogFor").focus()
    onlyShowMatchingDialogs(true)
}

function onlyShowMatchingDialogs(nodelay){

    let delay = nodelay ? 0 : 500

    if(searchBoxDelay)clearTimeout(searchBoxDelay)
    searchBoxDelay = setTimeout(() => {

        let searchstring = $id("dialogsearch").value

        $$("#dialogpanelcontent :is(.sceneChunk, .dialogChunk)").forEach(dialog => {
            dialog.classList.toggle("displayNone", !dialog.innerText.toLowerCase().includes(searchstring.toLowerCase())) 
            $id(dialog.closest(".sceneChunk").dataset.parentId).classList.toggle("dimmedScene", dialog.closest(".sceneChunk").classList.contains("displayNone"))
        })

        $$("#dialogpanelcontent :is(.dialogChunk:not(.displayNone)) p").forEach(dialog => {
            
            dialog.innerHTML = dialog.innerHTML.replace(/\<span class\=\"searchFound\"\>(.*?)\<\/span\>/g, "$1")

                if(searchstring.length > 0) {

                    const text = dialog.textContent;
                    const regex = new RegExp(`(${searchstring})`, 'gi');
                    const matches = text.match(regex) || [];

                    if (matches.length) {
                        const newHTML = text.replace(regex, `<span class="searchFound">$1</span>`);
                        dialog.innerHTML = newHTML;
                    }
                }
        })

        let provokeRedraw = $id("dialogpanelcontent").getBoundingClientRect()
            
    }, delay);

}

function __________HELPERS__________(){} 

function toCamelCase(string){

    let words = string.split(" ")
    let camelCase = words[0].toLowerCase()

    for (let i = 1; i < words.length; i++){
        camelCase += words[i].charAt(0).toUpperCase() + words[i].slice(1).toLowerCase()
    }

    return camelCase
}

function toInitialsCase(string){

    let words = string.split(" ")
    let output = ""

    for (word of words){
        output += " " + word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    }

    return output.trim()
}

</script>

<style>

    .searchFound{

        background: yellow;
        border: 0px solid yellow;
        border-top-width: 3px;
        border-bottom-width: 1px;
        box-shadow: 0px 0px 0px 1px hsl(60, 100%, 40%);

        white-space: inherit;
        z-index: -99;

    }

    .displayNone{

        display: none !important;

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .section:not(.dontDim, .level1, .special) > .section-heading{     */
    body:has(.displayNumberOf) .section:not(:has(.orphanText > .dontDim), .level1, .special) > .section-heading{    
        /* background: hsl(var(--paperBehindInk), 0.05) !important; */
        background: hsl(0, 0%, 100%, 0.05) !important;
    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .section:not(.dontDim) > .section-heading{ */
        body:has(.displayNumberOf) .section:not(:has(.orphanText > .dontDim)) > .section-heading{
        color: transparent !important; /*hsl(var(--paperBehindInk), 0.05) !important;*/
        border: none;
    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .dimmedSection,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .section{ */
    body:has(.displayNumberOf) .dimmedSection,
    body:has(.displayNumberOf) .section{

        /* border-color: hsl(var(--paperBehindInk), 0.05) !important; */
        border-color: hsl(0, 0%, 100%, 0.05) !important;
        color: transparent !important;

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene:has(.dontDim){ */
        body:has(.displayNumberOf) .scene:has(.dontDim){

        outline: 2px transparent solid
        /*THIS IS THE WEIRDEST HACK: without this, the :has(:not(.dontDim)) on next line will affect stuff WITH .dontDim too */

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene:not(:has(.dontDim)),
    body:has(#notepanel.expanded .dialogtab.selectedtab) .scene:not(:has(.dontDim)) > .sceneheading,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.dimmedScene,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.dimmedScene > .sceneheading,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .dimmedSection > .section-heading{ */
    body:has(.displayNumberOf) .scene:not(:has(.dontDim)),
    body:has(.displayNumberOf) .scene:not(:has(.dontDim)) > .sceneheading,
    body:has(.displayNumberOf) .scene.dimmedScene,
    body:has(.displayNumberOf) .scene.dimmedScene > .sceneheading,
    body:has(.displayNumberOf) .dimmedSection > .section-heading{

        /* --localColor: hsl(var(--paperBehindInk)) !important; */
        --localColor: hsl(var(0, 0%, 100%)) !important;
        
        border: 1px solid transparent !important;
        color: transparent !important;
        opacity: 0.05 !important;

        box-shadow: none !important;

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.isHovered{ */
    body:has(.displayNumberOf) .section:is(.isSelected, .isHovered) > .section-heading,
    body:has(.displayNumberOf) .scene:is(.isSelected, .isHovered){
        
        border-color: black;
        /* border: 1px solid hsl(var(--inkOnPaper)); */
        box-shadow: /*inset 0 calc(12px * var(--fontSizeFactor)) 0 2px hsl(var(--inkOnPaper)),*/
        /* inset 0 0 0 2px hsl(var(--inkOnPaper)); */
        inset 0 0 0 1.5px hsl(0, 0%, 0%),
        /*inset*/ 0 0 0 0.5px hsl(0, 0%, 0%);
        /* background-image: -webkit-linear-gradient(top, rgba(20,20,20,0.60), rgba(20,20,20,0.60) 100%) !important; */
        /* color: white; */
        
    }
    
    body:has(.displayNumberOf):not(:has(.nonProportionalMode, .indexcards)) .scene.isOmitted{
    
        display: block !important;

        opacity: 0 !important;
        height: 0px !important;
        margin-top: 0px !important;

        transition: 200ms !important;
    }

    body:has(.displayNumberOf):not(:has(.nonProportionalMode, .indexcards)) .scene.isOmitted:is(.isSelected, .isHovered){
        
        opacity: 1 !important;
        margin-top: 1px !important;
        height: calc(14px * var(--fontSizeFactor)) !important;

    }
    /* body:has(.displayNumberOf):has(.scene.isHovered) .scene:not(.isHovered){

        opacity: 0.7

    } */

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.isHovered > .sceneheading{ */
    body:has(.displayNumberOf) .scene.isHovered > .sceneheading{

        /* color: white !important;
        background: hsl(var(--inkOnPaper)); */

    }
    
    .sceneChunk{

        font-family: 'Courier Prime', 'Courier New', Courier, monospace;
    
        background: var(--menu-background);
        /* border: 1px solid hsla(var(--inkOnPaper), 0.4); */
        border: 1px solid hsla(0, 0%, 0%, 0.4);
        border-radius: 3px;

        padding: 4px;
        margin-bottom: 1px;
        
        z-index: 9996; 

        position: relative !important;
        display: block;
        opacity: 1 !important;
        visibility: visible !important;

        left: 0px !important;
        width: auto !important;

    }

    .sceneChunk.omitted{

        background-image:
			repeating-linear-gradient(
			-45deg,
			/* hsl(var(--paperBehindInk),0.4) 0px, */
			hsl(0, 0%, 100%,0.4) 0px,
			/* hsl(var(--paperBehindInk),0.4) 3px,  */
			hsl(0, 0%, 100%,0.4) 3px, 
			/* rgba(0,0,0,.3) 0px,
			rgba(0,0,0,.3) 3px,  */
			transparent 3px,
			transparent 6px
            )
            /* , linear-gradient(hsl(var(--paperBehindInk), .4), hsl(var(--paperBehindInk), .4)) */
            , linear-gradient(hsl(0, 0%, 100%, .4), hsl(0, 0%, 100%, .4))
            , linear-gradient(var(--localColor), var(--localColor))
            !important;

    }

    .sceneChunk > .chunkHeading {


        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: calc(11px * var(--fontSizeFactor)) !important;
        font-weight: bold;

        max-height: calc(18px * var(--fontSizeFactor));
        overflow: hidden !important;
        text-overflow: ellipsis;

        white-space: nowrap !important;
        word-wrap: none;

        width: calc(100% + 8px);

        margin-left: -4px;
        margin-top: -4px;
        padding: 3px 8px 1px 8px;
        margin-bottom: -1px;

        /*}*/

        position: sticky;
        top: 0;
        background: var(--localColor);
        /* background: linear-gradient(to bottom, var(--localColor) calc(100% - 5px), transparent 100%); */
        
    }
    
    .sceneChunk > .chunkHeading.isStuck{
        
        box-shadow: 0 2px 8px #333;

    }

    #dialogpanelcontent .sceneChunk:hover,
    #dialogpanelcontent .hoveredSceneChunk{

        /* box-shadow: 0 0 0 2px inset hsla(var(--inkOnPaper), 1); */
        box-shadow: 0 0 0 2px inset hsla(0, 0%, 0%, 1);
        /* border-color: hsl(var(--inkOnPaper)) */
        border-color: hsl(0, 0%, 0%)
        /* background-image: -webkit-linear-gradient(top, hsla(var(--inkOnPaper), 1), hsla(var(--inkOnPaper), 1) 100%) !important; */
    }

    #dialogpanelcontent .sceneChunk:hover > .chunkHeading,
    #dialogpanelcontent .hoveredSceneChunk > .chunkHeading{

        /* background-image: -webkit-linear-gradient(top, hsla(var(--inkOnPaper), 1), hsla(var(--inkOnPaper), 1) 100%) !important; */
        background-image: -webkit-linear-gradient(top, hsla(0, 0%, 0%, 1), hsla(0, 0%, 0%, 1) 100%) !important;
        /* color: hsl(var(--paperBehindInk)); */
        color: hsl(0, 0%, 100%);

    }

    #dialogpanelcontent .selectedSceneChunk{

        /* box-shadow: 0 0 0 3px inset hsl(var(--inkOnPaper)); */
        box-shadow: 0 0 0 3px inset hsl(0, 0%, 100%);

    }

    #dialogpanelcontent .selectedSceneChunk > .chunkHeading{

        /* background-image: -webkit-linear-gradient(top, hsl(var(--inkOnPaper)), hsl(var(--inkOnPaper)) 100%) !important; */
        background-image: -webkit-linear-gradient(top, hsl(0, 0%, 0%), hsl(0, 0%, 0%) 100%) !important;
        color: hsl(0, 0%, 100%);

    }

    .displayNumberOf {

        position: absolute;
        height: 18px;
        width: auto;
        min-width: 28px;
        padding: 0px 4px 2.5px 4px;
        
        opacity: 0.8;
        
        background: hsl(var(--inkOnPaper));
        border: 2px solid hsl(var(--paperBehindInk));
        border-radius: 15px;
        
        color: hsl(var(--paperBehindInk));
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-weight: bold;
        font-size: 9px;
        line-height: 14px;
        text-align: center;

        z-index: 9997;

        translate: -50% calc(-50% - 16px);
        overflow: visible;
    }

    .displayNumberOf::before,
    .displayNumberOf::after{

        content: "";
        position: absolute;
        bottom: 0px;
        left: 30%;
        width: 0px;
        height: 0px;
        border: 3px solid transparent;
        border-top-color: hsl(var(--inkOnPaper));
        border-left-color: hsl(var(--inkOnPaper));

        translate: 0 5.5px;
        rotate: 5deg;
        
        z-index: 10000;
    }

    .displayNumberOf::after{

        border-width: 4px;
        border-top-color: hsl(var(--paperBehindInk));
        border-left-color: hsl(var(--paperBehindInk));
        translate: -2px 9.5px;

        z-index: -9998

    }

    .scene:is(:hover, .isSelected) > .displayNumberOf{

        scale: 1.2;
        opacity: 1;

    }

    .parentIndicator{
        
        display: none;
    
    }

    .connector{

        z-index: 9997;
        overflow: visible !important;
        min-height: 0 !important;

        top: min(var(--sceneCorner), var(--chunkCorner));
        height: abs(calc(var(--sceneCorner) - var(--chunkCorner)));

        outline: 5px solid transparent; 

        transform: scaleY(sign(var(--sceneCorner) - calc(var(--chunkCorner))));
        transform-origin: center center;

        /* transition: 0.1s; */

        pointer-events: none !important;
        /* filter: drop-shadow(-3px -1px 3px rgba(0,0,0,0.3)) */


    }

    .connector svg {

        display: block;

        overflow: visible !important;
        stroke-width: 2px;
        /* stroke: hsl(var(--inkOnPaper)); */
        stroke: hsl(0, 0%, 0%);

        fill: none;

        margin: 0 !important;
        padding: 0 !important;

        top: inherit !important;
        bottom:inherit !important;
        min-height: 0 !important;


        height: 100%;

        z-index: -999;

        clip-path: polygon(0% -10%, 0% -10%, 0% 110%, 0 110%);
        animation: offset 0.2s linear forwards;

    } 

    @keyframes offset {
      to { clip-path: polygon(0% -10px, 100% -10px, 100% calc(100% + 10px), 0 calc(100% + 10px)); }
    }
    @keyframes offset-half {
      to { clip-path: polygon(0% -10px, 75% -10px, 75% calc(100% + 10px), 0 calc(100% + 10px)); }
    }

    .connector::before, 
    .connector::after{

        content: "";
        position: absolute;
        
        background: var(--localColor);
        /* border: 2px solid hsl(var(--inkOnPaper)); */
        border: 2px solid hsl(0, 0%, 0%);
        width: 8px;
        height: 8px;
        border-radius: 50%;

        z-index: -99 !important;
        
    }

    .connector::before{

        top: -6px;
        left: -10px;

    }

    .connector::after{

        /* bottom: -6px; */
        /* bottom: calc(-6px); */
        bottom: calc(var(--maxHeightOfDot) / -2 - 2px);
        right: -10px;
        max-height: var(--maxHeightOfDot);

        clip-path: polygon(75% -10%, 75% -10%, 75% 110%, 75% 110%);
        animation: offset-half 0.1s linear forwards;
        animation-delay: 0.1s;


    }

    svg .bottomstroke{
        stroke-width: 4px;
    }
    svg .topstroke{
        stroke: var(--localColor);
    }

    /* .sceneChunk:hover,
    .sceneChunk:has(.selectedDialog){

        transition: scale 0.2s;

    }

    #dialogpanelcontent:has(.sceneChunk:hover) .sceneChunk:not(:hover, .selectedDialog){

        opacity: 0.8 !important

    } */

    #flexiContainer:has(.sceneChunk:hover) .sceneChunk:not(:hover){

    }

    /* .sceneChunk .chunkHeading{


        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: calc(11px * var(--fontSizeFactor)) !important;
        font-weight: bold;

        max-height: calc(18px * var(--fontSizeFactor));
        overflow: hidden !important;
        text-overflow: ellipsis;

        white-space: nowrap !important;
        word-wrap: none;

        width: calc(100% + 8px);

        margin-left: -4px;
        margin-top: -4px;
        padding: 3px 8px 2px 8px;
        margin-bottom: -2px;

    } */

    .dialogChunk {

        white-space: normal !important;
        word-wrap: break-word !important;

        /* background: linear-gradient(hsla(var(--paperBehindInk), 0.60), hsla(var(--paperBehindInk), 0.60)), var(--localColor); */
        background: linear-gradient(hsla(0, 0%, 100%, 0.60), hsla(0, 0%, 100%, 0.60)), var(--localColor);
        /* border: 1px solid hsla(var(--inkOnPaper), 0.3); */
        border: 1px solid hsla(0, 0%, 0%, 0.3);
        /* color: hsl(var(--inkOnPaper)); */
        color: hsl(0, 0%, 0%);
        border-radius: 3px;
        width: 100%;
        
        padding: calc(5px * var(--fontSizeFactor));
        padding-top: calc(7px * var(--fontSizeFactor));
        padding-bottom: calc(4px * var(--fontSizeFactor));

        z-index: 2 !important

    }

    .dialogChunk:not(:first-child){
        
        margin-top: 3px !important; 

    }

    .dialogChunk:hover,
    .dialogChunk.selectedDialog{
        background-color: inherit;
        /* background-image: linear-gradient(hsla(var(--paperBehindInk), 1), hsla(var(--paperBehindInk), 1)) ; */
        background-image: linear-gradient(hsla(0, 0%, 100%, 1), hsla(0, 0%, 100%, 1)) ;
        /* color: hsl(var(--inkOnPaper)) !important; */
        color: hsl(0, 0, 0%) !important;

        transition: scale 0.2s;

        z-index: 9999 !important;

    }

    .dialogChunk.hasCursor{

        box-shadow: 0px 0px 0px 2px red ;

    }

    .sceneChunk p{

        font-family: 'Courier Prime', 'Courier New', Courier, monospace;
        color: inherit;

        white-space: normal !important;
        word-wrap: break-word;

    }

    #dialogpanelcontent .dialogChunk p{

        font-size: calc(10px * var(--fontSizeFactor)) !important;

    }

    .dialogChunk p.character{

        padding-left: 9ch !important;

    }

    body:not(:has(#allDialogFor option:checked[value="ALL"])) .dialogChunk p.character{

        display: none;
        outline: 3px solid orange

    }

    .dialogChunk p.parenthetical{
        
        padding-left: 6ch !important;

    }

    .dialogChunk i{

        white-space: normal;
        word-wrap: break-word;
        font-style: italic;

    }

    .dialogChunk b{

        white-space: normal;
        word-wrap: break-word;
        font-weight: bold;

    }

    .dialogChunk:has(:not(.omitted)) :is(p, span).omitted,
    .dialogChunk:not(:has(:not(.omitted)))
    {

        text-decoration: line-through;
        white-space: normal;
        word-wrap: break-word;

        z-index: -1 !important;

        /* color: hsla(var(--inkOnPaper), 0.5); */
        color: hsla(0, 0%, 0%, 0.5);

        background-image:
			repeating-linear-gradient(
			-45deg,
			/* hsl(var(--paperBehindInk),0.4) 0px,
			hsl(var(--paperBehindInk),0.4) 3px,  */
			hsl(0, 0%, 100%, 0.4) 0px,
			hsl(0, 0%, 100%, 0.4) 3px, 
			/* rgba(0,0,0,.3) 0px,
			rgba(0,0,0,.3) 3px,  */
			transparent 3px,
			transparent 6px
            )
            /* , linear-gradient(hsl(var(--paperBehindInk), .4), hsl(var(--paperBehindInk), .4))
            , linear-gradient(var(--localColor), var(--localColor)) */
            , linear-gradient(hsl(0, 0%, 100%, .4), hsl(0, 0%, 100%, .4))
            , linear-gradient(var(--localColor), var(--localColor))
            !important;
            
        background-color:inherit

    }

    .scene.isEnlarged{

        transform-origin: center top;
        scale: 1.1 !important;

        transition: all 0.2s !important;

    }
    
</style>

<style>

:root {
    --note-bottom: rgba(255, 255, 0, 1);
    --note-border: rgba(70, 70, 0, 1);
    --note-border-light: rgb(191, 191, 2);
}

.alwaysOnTop{
    z-index: 11000 !important;
}

.noteContainer {
    position: absolute !important;
    float: right !important;
    /* height: 1px !important;  */
    margin-bottom: -1px !important;
    width: auto !important;
    pointer-events: none;
    z-index: 9996 !important;
    overflow: visible;

    opacity: 1;

    /*testing new absolute note container*/
    position: absolute !important;
    /* top: 0 !important; */
    right: 2px !important;

    min-height: 15px !important;
    /* height: 100% !important; */

}

.indexcards .level1::after > .noteContainer { 
    /* see outline.css*/
}

.scene:has(.review) .noteContainer{
    right: 10px !important
}

.scene:has(.marker) .noteContainer{
    right: 20px !important
}

.marker {
    background-color: var(--mycolor);
    color: white;

    position: absolute;
    right: -2px;
    top: min(var(--percentage), calc(100% - 12px));

    height: 12px;
    min-width: 20px;
    width: auto; /* to fit marker name */
    max-width: 80%;

    pointer-events: all;

    padding-left: 8px;
    padding-right: 2px;
    
    z-index: 998;
    
    font-weight: bold;
    font-size: 10px;
    line-height: 11px;
    
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;

    border: 1px rgba(0,0,0,0.6) solid;

    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%, 6px 50%);

    transition: max-width 0.2s;

}

.marker::after{

    content: "";
    position: absolute;
    top: -3.44px;
    left: -2px;

    border-left: 8px rgba(0,0,0,0.6) solid;
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
    border-right: 8px solid transparent;

    height: 1px;
    width: 100%;
    display: block;

}

.marker:hover {

    background-image: linear-gradient(rgba(0,0,0,0.6) 0%,rgba(0,0,0,0.6) 100%) !important;
    opacity: 1;
    color: white !important;
}

#------INDEXCARD STYLES------{}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .marker,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker {
    position: absolute;

    top: 1px !important;
    right: 2px; 
    
    height: 10px;
    width: 15px !important;
    max-width: none !important;
    min-width: 0px !important;
    padding: none;

    transform: rotate(-90deg);

    pointer-events: all !important;

    color: rgba(0,0,0,0) !important;
}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .marker::after,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker::after {

    left: -2px;
    top: -3.44px !important;

    border-top-width: 7px;
    border-bottom-width: 7px;

}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .section>.marker,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .section>.marker {

    z-index: 9999 !important;
}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(2 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(2 of .marker){
    right: 14px;
}
#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(3 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(3 of .marker){
    right: 26px !important;
}
#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(4 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(4 of .marker){
    right: 38px !important;
}
#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(5 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(5 of .marker){
    right: 50px !important;
}

#flexiContainer .faux .marker .markertext,
#flexiContainer.unShowMarkerText .marker .markertext,
#flexiContainer.indexcard:not(.allowMarkerTextInAllViews) .marker .markertext,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker .markertext {

    width: 0px;
    opacity: 0;
    text-overflow: clip;
    transition-delay: 0.2s

}

#flexiContainer.unShowMarkerText .marker {

    max-width: 20px
}


#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .marker:hover,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker:hover {
    transform: translateY(2px) scaleY(1.3) scaleX(0.8) rotate(-90deg) !important;
    transition: 0.1s;
}


.beat{
    position: absolute;

    /* top: calc(var(--percentage) - (var(--percentage) / 100% * 14px)); */
    bottom: max(calc(100% - 14px - var(--percentage)), 0px);

    padding: 0.5px 3px;
    height: 14px; 
    font-size: 10px;
    line-height: 11px;
    font-weight: bold;
    
    background-color: var(--myColor);
    color: white;
    opacity: 1;

    border: 1px rgba(255,255,255,1) solid;
    border-radius: 4px;
    box-shadow: 1px 1px 6px rgba(0,0,0,0.7);

    pointer-events: all !important;
    overflow: visible;

    left: 50%;
    translate: -50% 0; 
    transform-origin: 50% 100%;
}

.largerBeat{
    
    /* height: 20px;
    font-size: 14px;
    line-height: 14px !important;
    margin-top: -3px;

    padding: 1px 4px !important;
    border-width: 2px; */

    transform: scale(1.4);
    
    translate: 0 0; 
    transform-origin: 50% 50%;
    pointer-events: none !important;

    transition: all 0.2s;
    z-index: 99999;

}

.hoveredBeat{

    color: var(--myColor) !important;
    background: white !important;
    border-color: var(--myColor);


}

.hoveredBeat:not(.largerBeat)::after{

    content: "";

    /* background-color: rgba(255,255,255,0.9); */
    border: 10px solid transparent;
    border-left-width: 6px;
    border-right-width: 6px;
    border-top-color: color-mix(in oklab, var(--myColor) 30%, white 70%);

    position: absolute;
    bottom: calc(100% - 2px);
    left: 50%;
    transform: translateX(-50%);
    width: 0px;
    height: 0px;

    /* box-shadow: 1px 2px 3px rgba(0,0,0,0.6),
        inset 0 -1px 0 2px var(--myColor)
        ; */

    /* filter: drop-shadow(1px 4px 3px rgba(0,0,0,0.8)); */

    z-index: 9999;

}
.hoveredBeat:not(.largerBeat)::before{

    content: attr(data-beat-description);
    font-size: 12px;
    line-height: 14px;
    font-weight: normal;
    padding: 8px;
    white-space: normal !important;
    line-break: unset;

    /* width: auto !important; */
    min-width: calc(var(--myWidth) / 2) !important;
    max-width: var(--myWidth) !important;

    position: absolute;
    bottom: calc(100% + 18px);
    left: 50%;
    transform: translateX(-50%);

    /* background-color: rgba(255,255,255,0.9); */
    background-color: color-mix(in oklab, var(--myColor) 30%, white 70%);

    color: black;
    border-radius: 4px;

    transition: all 0.2s;

    z-index: 9998;

    box-shadow: 1px 5px 8px rgba(0,0,0,0.8),
        0 0 0 1px var(--myColor)
        ;
}

.hiddenBeat{
    display: none;
}

/* .largerBeat{

    height: 20px;
    font-size: 14px;
    line-height: 14px !important;
    margin-top: -2px;
    padding: 1px 4px !important;
    border-width: 2px;

} */

.path, .allpaths, .svgForBeats {
    /* stroke-width: 5px;
    stroke-dasharray: 4 2;
    stroke: white !important; */

    pointer-events: none;
    filter: drop-shadow(1px 1px 3px rgba(0,0,0,0.6))
}

.path .bottomstroke{

    stroke-width: 7px;
    stroke: white

}
.path .topstroke{

    stroke-width: 5px;
    stroke: var(--myColor)

}

/* 3D-hack for beats

#flexiContainer.beatsAreDisplayed .scene {
    perspective: 1000px;
    transform-style: flat;
} 

#flexiContainer.beatsAreDisplayed .beat{
  transform-style: preserve-3d;
}

.path{

    transform:translate3d(0, 0, 1px);

} */



/* .pathOf1{
    stroke: purple;
}
.pathOf2{
    stroke: midnightblue;

}
.pathOf3{
    stroke: forestgreen;
}
.pathOf4{
    stroke: firebrick;
}
.pathOf5{
    stroke: deeppink;
}
.pathOf6{
    stroke: black;
}

.hiddenPath{
    display: none;
} */

.sluglineIsHidden > .noteContainer {
    height: 15px !important;
}

.developing-a-new-note {

    opacity: 0.8 !important;

    position: relative !important;
    float: left !important;
    padding: 0 !important;
    margin: 0 0px 0px 2px !important;

    height: 15px !important;
    width: 15px !important;
    border-left: 10px var(--note-bottom) solid; 
    border-top: 15px var(--note-bottom) solid; 
    border-right: 15px transparent solid;

    z-index: 999 !important;
    white-space: normal;
    
    pointer-events: all;

    overflow: hidden;

}

.note {

    opacity: 0.8 !important;

    position: relative !important;
    float: left !important;
    padding: 0 !important;
    margin: 0 0px 0px 2px !important;
    background-color: var(--note-bottom);

    border: 1px solid rgba(0,0,0,0.75);
    height: 15px !important;
    width: 15px !important;
    color: rgba(0,0,0,0);

    z-index: 999 !important;
    white-space: normal;
    
    pointer-events: all;

    overflow: hidden;

    clip-path: polygon(0 0, 100% 0, 100% calc(100% - 4.1px), calc(100% - 4.1px) 100%, 0 100%);
    overflow: hidden;

}

.note {

    top: var(--percentage)

}

.note::before{
    position: absolute;
    border-radius: 0;
    content: " ";
    width: 4px;
    height: 4px;
    border-top: 1px solid  rgba(0,0,0,0.0); /*var(--note-border);*/
    border-left: 1px solid  rgba(0,0,0,0.0); /*var(--note-border);*/
    background: linear-gradient(to bottom right, transparent 0%, transparent 1.5px, rgba(0,0,0,0.7) 1.5px, rgba(0,0,0,0.7) 99%, transparent 100%);
    left: 9px;
    top: 9px;

}

#expandedNote .showSectionPageNumber{
    font-size: 8px !important;
    line-height: 8px !important;
    margin-top: 2px !important;
    padding-right: 10px !important;
}

.selectedNote:not(.review) {
    
    background-image: 

    linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.7) 100%);
    border-color: black !important; 
}

.selectedNote:not(.review):before {
  border-color: black !important; /* var(--note-border) !important; */
  background: linear-gradient(to bottom right, transparent, transparent 1.5px, black 1.5px, black 2.5px, transparent 2.5px);

}

#expandedNote{

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font-weight: normal !important;
    text-align: left !important;
    line-height: 12px !important;

    opacity: 1 !important;

    position: absolute;

    min-height: 50px;
    
    background-color: rgb(255,255,128);
    color: rgba(0,0,0,0.7);
    border:1px solid rgba(0,0,0,0.7);
    border-radius: 5px !important;
    
    white-space: normal;
    padding: 0px 8px 8px 8px !important;

    background-image: repeating-linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 16px, rgba(0,0,0,0.2) 16px, rgba(0,0,0,0.2) 17px) !important;

    box-shadow: 2px 2px 10px rgba(0,0,0,0.6);
    overflow: hidden;

    z-index: 9997 !important;
}

#expandedNote.omittedNote {

    background-image: 	
        repeating-linear-gradient(
            180deg, 
            rgba(0,0,0,0) 0%, 
            rgba(0,0,0,0) 16px, 
            var(--note-border-light) 16px, 
            var(--note-border-light) 17px),
        repeating-linear-gradient(
			-45deg,
			rgba(0,0,0,0.1) 0px,
			rgba(0,0,0,0.1) 3px,
			rgba(255,255,255,0.2) 3px,
			rgba(255,255,255,0.2) 6px)
            
    !important; 
}

#expandedNote text{
    font-size: 14px !important;
    line-height: 17px !important;
    margin-top: -1px !important; 
    padding-top: 17px;
    padding-bottom: 6px;
    font-family: 'Courier Prime', 'Courier New', Courier, monospace;
    white-space: normal;
    text-decoration: underline dotted var(--note-border);
    display: block;
}

#expandedNote b{
    font-size: 12px !important;
    padding: 5px 9px 0px 9px;
    margin: 0px -9px 2px -9px; 
    line-height: 12px !important;
    background-color: rgba(0,0,0,0.2);
    color:  rgba(0,0,0,0.75);
    display: block;
    text-align: left;

    font-weight: 700;

    overflow: hidden;
    text-overflow: ellipsis;
}

#expandedNote strong{

    font-weight: bold;


}
#expandedNote em,
#expandedNote i{

    font-style: italic !important;

}

.trashNote {
    height: 12px !important;
    width: 12px !important;
    line-height: 12px !important;
    float: right !important;
    overflow: visible !important;
    margin-top: -3px !important;
    pointer-events: all;

}

.trashbutton{
    fill:  rgba(0,0,0,0.75);
    pointer-events: none;
    /* opacity: 0.6 !important; */

}
#trashNote:hover > .trashbutton,
.trashNote:hover{
    fill: rgb(192,0,0) !important;
    opacity: 1 !important;
    
    overflow: visible !important;
    transition: all 0s !important;
    transition-delay: 0ms !important;
}

.notepanelNote > .trashNote {
    
    position: absolute;
    right: 2px;
    top: calc(5px - 2 * var(--fontSizeFactor));

    scale: calc(var(--fontSizeFactor) * 0.8) !important;
    transform-origin: top right;
    
    visibility: hidden;
    transition: all 0s !important;
    transition-delay: all 0s !important;

}

.notpanelNote .trashNote > svg,
.notpanelNote svg
/*, svg.trashbutton */
{
    visibility: hidden;
    transition: all 0s !important;
    transition-delay: all 0s !important;
}

.notepanelNote:hover > .trashNote,
.notepanelNote:hover svg {

    color: white !important;
    fill: white !important;
    visibility: visible;
    z-index: 9999;

    opacity: 1 !important;
    transition: all 0s !important;
    transition-delay: all 0s !important;
    /* outline: 2px solid white */

}

.notepanelNote > .trashNote:hover,
.notepanelNote > .trashNote:hover > svg {

    fill: rgb(255, 64, 64) !important;

}

</style>

<script>

var trashIcon = `
<svg class="trashbutton" width="100%" height="100%" viewBox="0 0 166 208" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-326.426,-1615.59)">
        <path d="M485.852,1661.14C485.605,1661.17 485.355,1661.18 485.101,1661.18L335.155,1661.18L348.262,1815.91C348.581,1819.68 351.739,1822.59 355.527,1822.59L465.477,1822.59C469.266,1822.59 472.423,1819.68 472.743,1815.91L485.852,1661.14ZM450.143,1704.86L442.106,1795.83C441.803,1799.26 444.346,1802.3 447.782,1802.6C451.218,1802.9 454.254,1800.36 454.558,1796.92L462.595,1705.96C462.898,1702.52 460.355,1699.49 456.919,1699.18C453.483,1698.88 450.447,1701.42 450.143,1704.86ZM358.017,1705.96L366.054,1796.92C366.358,1800.36 369.394,1802.9 372.83,1802.6C376.266,1802.3 378.809,1799.26 378.506,1795.83L370.469,1704.86C370.165,1701.42 367.129,1698.88 363.693,1699.18C360.257,1699.49 357.714,1702.52 358.017,1705.96ZM389.597,1705.59L392.276,1796.56C392.378,1800.01 395.26,1802.72 398.708,1802.62C402.156,1802.52 404.873,1799.64 404.771,1796.19L402.092,1705.22C401.991,1701.78 399.109,1699.06 395.661,1699.16C392.213,1699.26 389.496,1702.14 389.597,1705.59ZM418.52,1705.22L415.841,1796.19C415.74,1799.64 418.456,1802.52 421.904,1802.62C425.352,1802.72 428.234,1800.01 428.336,1796.56L431.015,1705.59C431.116,1702.14 428.399,1699.26 424.951,1699.16C421.503,1699.06 418.622,1701.78 418.52,1705.22ZM384.347,1628.53L339.471,1628.53C336.877,1628.53 334.477,1629.91 333.171,1632.15L327.417,1642.03C326.103,1644.29 326.095,1647.07 327.396,1649.33C328.696,1651.6 331.107,1652.99 333.718,1652.99L485.101,1652.99C487.711,1652.99 490.122,1651.6 491.423,1649.33C492.724,1647.07 492.715,1644.29 491.401,1642.03L485.648,1632.15C484.341,1629.91 481.942,1628.53 479.347,1628.53L436.657,1628.53C435.606,1625.84 433.63,1623.32 430.704,1621.22C426.134,1617.93 418.817,1615.59 410.502,1615.59C402.188,1615.59 394.871,1617.93 390.3,1621.22C387.375,1623.32 385.399,1625.84 384.347,1628.53Z"/>
    </g>
</svg>
`

var hiddenIcon = `
    <svg class="eyeWithCrossIcon" width="100%" height="100%" viewBox="0 0 191 163" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
       <g transform="matrix(1,0,0,1,-833.494,-1274.88)">
            <path d="M958.327,1311.65L993.025,1277.01C995.873,1274.17 1000.49,1274.17 1003.34,1277.02C1006.18,1279.87 1006.18,1284.49 1003.33,1287.33L855.049,1435.38C852.201,1438.23 847.58,1438.22 844.737,1435.37C841.894,1432.53 841.897,1427.91 844.745,1425.06L872.284,1397.57C856.288,1388.88 843.263,1376.61 834.803,1362.1C833.977,1360.66 833.978,1358.88 834.806,1357.44C851.863,1328.17 887.485,1308.03 928.625,1308.03C938.942,1308.03 948.911,1309.29 958.327,1311.65ZM983.688,1321.29C1000.27,1330.01 1013.76,1342.54 1022.45,1357.44C1023.27,1358.88 1023.27,1360.66 1022.45,1362.1C1005.39,1391.37 969.765,1411.51 928.625,1411.51C917.74,1411.51 907.241,1410.1 897.364,1407.48L910.869,1394C916.185,1396.77 922.224,1398.33 928.625,1398.33C949.907,1398.33 967.184,1381.05 967.184,1359.77C967.184,1353.39 965.632,1347.37 962.882,1342.07L983.688,1321.29ZM954.311,1350.62C955.33,1353.48 955.885,1356.56 955.885,1359.77C955.885,1374.82 943.67,1387.03 928.625,1387.03C925.404,1387.03 922.313,1386.47 919.441,1385.44L954.311,1350.62ZM945.071,1324.89L936.331,1333.62C933.887,1332.9 931.301,1332.51 928.625,1332.51C913.58,1332.51 901.365,1344.73 901.365,1359.77C901.365,1362.43 901.747,1365 902.46,1367.44L893.719,1376.16C891.376,1371.19 890.066,1365.63 890.066,1359.77C890.066,1338.49 907.344,1321.21 928.625,1321.21C934.506,1321.21 940.082,1322.53 945.071,1324.89Z"/>
        </g>
    </svg>
    `
var showIcon = `
    <svg class= "eyeIcon" width="100%" height="100%" viewBox="0 0 191 104" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
        <g transform="matrix(1,0,0,1,-833.494,-1154.68)">
            <g transform="matrix(1,0,0,1,0,-153.352)">
                <path d="M834.884,1362.24C834.004,1360.71 834.004,1358.83 834.884,1357.3C851.975,1328.11 887.549,1308.03 928.625,1308.03C969.627,1308.03 1005.15,1328.04 1022.27,1357.14C1023.21,1358.77 1023.21,1360.77 1022.27,1362.4C1005.15,1391.5 969.627,1411.51 928.625,1411.51C887.549,1411.51 851.975,1391.43 834.884,1362.24ZM928.625,1321.21C949.907,1321.21 967.184,1338.49 967.184,1359.77C967.184,1381.05 949.907,1398.33 928.625,1398.33C907.344,1398.33 890.066,1381.05 890.066,1359.77C890.066,1338.49 907.344,1321.21 928.625,1321.21ZM928.625,1332.51C943.67,1332.51 955.885,1344.73 955.885,1359.77C955.885,1374.82 943.67,1387.03 928.625,1387.03C913.58,1387.03 901.365,1374.82 901.365,1359.77C901.365,1344.73 913.58,1332.51 928.625,1332.51Z"/>
            </g>
        </g>
</svg>
    `

let notesDivStart
let notesDivEnd = "</div>"

function __________NOTES(){}

function collectNotes(wherefrom){

    //TODO: Rename to collectNotesMarkersAndMore
   
    mylog(" from " + JSON.stringify(collectNotes.caller.name)) 
    
    if (!notesAreDisplayed && !markersAreDisplayed && !beatsAreDisplayed && !$("#notepanel.expanded .selectedtab.notetab"))return
    if(!outline || outline.length < 1) return

        let startTime = Date.now()
        let allNotesRaw = []

            let copyOfLines = JSON.parse(JSON.stringify(lines)) //needed because we're going to modify the lines array

            copyOfLines.forEach(line => {

                if (!["Heading", "Section", "Synopse"].includes(line.typeAsString)){
                    
                    line.notes.forEach(note => {
                        note.range.location += line.range.location
                        let startRedux = 0
                            if(note.type == "marker") { startRedux = 7 }
                            if(note.type == "beat") { startRedux = 5 }
                            if(note.type == "storyline") { startRedux = 10 }

                        let noteText = note.content
                            noteText = noteText.replace(/\/\*(.*)\*\//g, "<span class='omitted'>$1</span>")
                            noteText = noteText.replace(/\*\*\*(.*)\*\*\*/g, "<strong><em>$1</em></strong>")
                            noteText = noteText.replace(/\*\*(.*)\*\*/g, "<strong>$1</strong>")
                            noteText = noteText.replace(/\*(.*)\*/g, "<em>$1</em>")
                            noteText = noteText.replace(/\_(.*)\_/g, "<u>$1</u>")
                            noteText = noteText.replace(/\~(.*)\~/g, "<strike>$1</strike>")
                            noteText = noteText.replace(/\n/g, "<br>")
                            note.formattedContent = note.type == "note" ? noteText : noteText.toUpperCase()

                        //FTOutliner-exclusive color handling: 
                            if(!note.color && note.content.substr(startRedux).match(/^(#*\w+):*/)){
                                let colorValue = note.content.substr(startRedux).match(/^(#*\w+):*/)[1].toLowerCase()
                                if (CSS.supports("color: " + colorValue)) {
                                    note.color = colorValue
                                    startRedux += colorValue.length + 1
                                }
                            }
                            //this is notes-only, so absolute values and not additive
                            if(note.content.startsWith("!")) { note.color = "red"; startRedux = 1}
                            if(note.content.startsWith("!!")) { note.color = "magenta"; startRedux = 2}
                            if(note.content.startsWith("!!!")) { note.color = "#8000FF"; startRedux = 3}
                            if(note.content.startsWith("?")) { note.color = "lime"; startRedux = 1}
                            
                            note.formattedContent = note.formattedContent.substr(startRedux)

                        //#region hack
                        //Beat-specific hacks to fix quirks that may or may not change in the future:
                            //1. hack to fix notes starting at top of line
                                // if(note.range.location !== line.range.location){
                                //     note.range.length ++
                                // }
                            //2. hack to make multiline notes work
                                if(note.content.includes("\n")){
                                    let numberOfExtraLines = 0
                                    while (!copyOfLines[copyOfLines.indexOf(line) + numberOfExtraLines].string.includes("\]\]")){

                                        numberOfExtraLines ++
                                        note.range.length += copyOfLines[copyOfLines.indexOf(line) + numberOfExtraLines].notes[0].range.length + 1 //+1 for the newline character

                                    }
                                }
                        //#endregion

                        if(note.content) allNotesRaw.push(note)
                    })
                }
            })
            
            let endTime = Date.now() - startTime

        let allNotes = []
        // let allNotesBeforeStart = allNotesRaw.filter(note => note.range.location < outline[0].sceneStart) || []
        let allMarkers = []
        let allBeats = []

        for (outlineElementNumber = 0; outlineElementNumber < outline.length; outlineElementNumber ++){

            let allEntriesInScene = []
                allEntriesInScene = allNotesRaw.filter(note => note.range.location >= outline[outlineElementNumber].sceneStart && note.range.location < (outline[outlineElementNumber + 1]?.sceneStart || outline[outlineElementNumber].sceneEnd))
            
            //TODO: Perhaps also add beats and/or storyline data category
            let notesInScene = []
                notesInScene =   allEntriesInScene.filter(note => note.type == "note")
            let markersInScene = []
                markersInScene = allEntriesInScene.filter(note => note.type == "marker")
            let beatsInScene = []
                beatsInScene = allEntriesInScene.filter(note => note.type == "beat")

            let headline = "Note in " + ((outline[outlineElementNumber].typeAsString == "Heading") ? "scene " : "section ")
                headline += (outline[outlineElementNumber].typeAsString == "Heading") ? outline[outlineElementNumber].sceneNumber : outline[outlineElementNumber].stringForDisplay

                notesInScene.forEach(note => note.headline = headline)

            allNotes[outlineElementNumber] = notesInScene
            allMarkers[outlineElementNumber] = markersInScene
            allBeats[outlineElementNumber] = beatsInScene
        }

        //allNotes[0] = allNotesBeforeStart.concat(allNotes[0])

        //Done collecting notes and stuff, now send their respective data to the display function && update the notepanel

            globalAllNotes = allNotes //need to call updateNotepanel from outside this function, hence a global notes array

            if(notesAreDisplayed) displayNotes(allNotes, "note")
            if($id("notepanel")?.classList.contains("expanded")) updateNotepanel()

            if(markersAreDisplayed) displayNotes(allMarkers, "marker")
            if(beatsAreDisplayed) displayNotes(allBeats, "beat")

}

function collectReviews(){
        
        if(!documentSetting.reviewsAreDisplayed) return
        
        Beat.callAndWait(() => {
    
            let reviewsObject = Beat.getRawDocumentSetting("Review Ranges")
            return(reviewsObject)
    
        })
        .then(response => { 
    
            reviews = response
            if (reviews.length == 0) return
    
            let reviewNumber = 0
    
            for (element of outline){
    
                if (reviews[reviewNumber]?.range[0] >= element.position) continue
        
                while (reviewNumber < (reviews.length - 0) && reviews[reviewNumber]?.range[0] < element.position){
            
                    reviews[reviewNumber].outlineElementNumber = outline.indexOf(element) - 1
    
                    if(allText.substr(reviews[reviewNumber].range[0] + reviews[reviewNumber].range[1], 1) == "\n"){
                        reviews[reviewNumber].range[1] --
                    }
    
                    reviewNumber ++
    
                }
            }
    
            if (!reviews[reviews.length - 1].outlineElementNumber){
                x = 1
                while (outline[outline.length - x].typeAsString != "Heading") x ++
                reviews[reviews.length - 1].outlineElementNumber = outline.length - x
            }
    
            for (review of reviews){
                review.position = review.range[0]
            }
                    
            displayReviews(reviews)
    
        },error => { 
    
            console.log("Error retrieving reviews") 
    
        })   
}

function displayNotes(allNotes, typeOfNote){

    mylog()

    if(!outline || !allNotes) return

    let beatCategories = []
    let existingNotes = document.querySelectorAll(typeOfNote == "note" ? ".noteContainer" : `.${typeOfNote}`)
        existingNotes.forEach(note => note.remove())

    allNotes.forEach(sceneWithNotes => {

        if (sceneWithNotes.length){

            let element = $id(`${allNotes.indexOf(sceneWithNotes)}`) || $(".faux")
                if (element.classList.contains("section") && element.querySelector(":scope > .orphanText")) {
                    element = element.querySelector(":scope > .orphanText")
                }
            let currentContainer

            if (typeOfNote == "note"){

                currentContainer = document.createElement("div")
                currentContainer.id = "noteContainer" + allNotes.indexOf(sceneWithNotes)
                currentContainer.classList = "noteContainer clickThru"
                currentContainer.style.bottom = "15px" // corresponds to the height of a note. TODO: Make this dynamic
                currentContainer.style.height = "calc(100% - 15px)" //previously, this was 15px, but this will center notes at the edge
                if (element.classList.contains("section")) {
                    currentContainer.style.bottom = ""
                    currentContainer.style.top = "0px"
                    currentContainer.style.height = element.querySelector(".section-heading").getBoundingClientRect().height + "px"
                }

                if (element.classList.contains("section")) element.insertBefore(currentContainer, element.querySelector(".section-heading"))
                else element?.appendChild(currentContainer)
            
            }else{

                currentContainer = element

            }

            sceneWithNotes.forEach(note => {
                
                let noteElement = document.createElement("div")
                    noteElement.classList.add(typeOfNote)
                    noteElement.classList.add("collapsed")
                    noteElement.dataset.line = note.range.location
                    noteElement.dataset.length = note.range.length
                    noteElement.dataset.headline = note.headline

                    noteElement.style.backgroundColor = note.color || ""
                    noteElement.style.setProperty("--mycolor", note.color || "red")

                let noteNumber = allNotes.flat().indexOf(note)
                    noteElement.dataset.noteNumber = noteNumber
                    // noteElement.id = "noteNumber" + noteNumber
                    noteElement.id = typeOfNote + "Number" + noteNumber

                if(typeOfNote == "note"){
                    if (userDefault.oldNoteBehavior == true){
                        noteElement.onmouseenter = (event) => {expandNote(false, false, event)}
                        noteElement.onmouseleave = (event) => {collapseNote()}
                    } else {
                        noteElement.onclick = (event) => {expandNote(false, false, event)}
                        noteElement.onmouseenter = (event) => {noteElement.classList.toggle("selectedNote", true)
                                                                $id("notepanelNote" + noteNumber)?.classList.toggle("isSelected", true)}
                        noteElement.onmouseleave = (event) => {noteElement.classList.toggle("selectedNote", false)
                                                                $id("notepanelNote" + noteNumber)?.classList.toggle("isSelected", false)}
                    }
                }

                let percentage = 100 * ((note.range.location - outline[allNotes.indexOf(sceneWithNotes)].sceneStart) / outline[allNotes.indexOf(sceneWithNotes)].range.length) // + "%" // * (element.getBoundingClientRect().height - (15 * currentZoomLevel) - 0)
            
                    noteElement.style.setProperty("--percentage", percentage + "%")
                    noteElement.dataset.content = note.content
                    noteElement.dataset.formattedText = note.formattedContent
                    noteElement.innerHTML = note.formattedContent
                
                    currentContainer.appendChild(noteElement)
                    noteElement.dataset.color = colorsArray.includes(note.color.charAt(0).toUpperCase() + note.color.slice(1)) ? note.color : (rgbToHex(window.getComputedStyle(noteElement).backgroundColor) || "#FFFF00")

                    if(typeOfNote == "marker"){
                        noteElement.style.color = blackOrWhite(window.getComputedStyle(noteElement).backgroundColor)
                        if (currentContainer.classList.contains("section")) noteElement.style.setProperty("--percentage", "2px")
                    }
                    if(typeOfNote == "beat"){

                        //on first occurance of a beat, check all existing categories (storylines)
                        if(beatCategories.length == 0){
                            allNotes.flat().forEach(beat => {
                                let beatCategory = beat.formattedContent.replace(/:.*$/, "").toUpperCase()
                                if(!beatCategories.includes(beatCategory)) beatCategories.push(beatCategory)
                            })
                        }

                        let titleToDisplay = note.formattedContent.replace(/:.*$/, "").toUpperCase()

                        noteElement.style.setProperty("--myColor", storyColors[beatCategories.indexOf(titleToDisplay)] || "black")

                        noteElement.innerHTML = titleToDisplay
                        noteElement.dataset.title = titleToDisplay
                        noteElement.dataset.beatDescription = note.content.replace(/^.*?:/, "").trim()

                        noteElement.onclick = (event) => {
                            $$(`[data-title = "${event.target.dataset.title}"]`).forEach(beat =>{
                                beat.classList.toggle("hoveredBeat", true)
                            })
                        }
                    }
            })
        }
    })
}

function expandNote(tabWasPressed, shiftWasHeld, event){

    mylog()

    if(!$(".note, .review")) return
    if($("#editBox")) return
    exitEdit() //this caused a crash recently, check what this is about 2023-07-19

    let allNoteElements = Array.from($$(".note, .review")) // use for cycling if tab
        allNoteElements.sort((a, b) => { return a.dataset.line - b.dataset.line })

    if(event?.target && !tabWasPressed) {        
        $$(".note.selectedNote").forEach(note => { note.classList.remove("selectedNote") })
        event.target.classList.add("selectedNote")
    }

    if(tabWasPressed){
        let closestNote
        if(!$(".selectedNote")) {
            if($id("youAreHere")) {
                closestNote = allNoteElements.filter(note => Number(note.dataset.line) > Number($id("youAreHere").dataset.location))[0]
            }
        }

        let noteNumberToExpand = closestNote ? allNoteElements.indexOf(closestNote) - !shiftWasHeld : allNoteElements.indexOf($(".selectedNote"))
        if (noteNumberToExpand == -1) { noteNumberToExpand = (shiftWasHeld ? 0 : allNoteElements.length - 1) }
            noteNumberToExpand += (shiftWasHeld ? -1 : 1) 
        if (noteNumberToExpand < 0){ noteNumberToExpand = allNoteElements.length - 1 }
        if(noteNumberToExpand > allNoteElements.length - 1){ noteNumberToExpand = 0 }
            
        noteToExpand = allNoteElements[noteNumberToExpand]
        
        $(".selectedNote")?.classList.remove("selectedNote")
        noteToExpand.classList.add("selectedNote")
    }

    let theNote = $(".note.selectedNote, .review.selectedNote")
        if(!theNote) return
        if(isThisOffScreen(theNote)){
            scrollNicelyIntoView(theNote) 
        }

    $id("expandedNote")?.remove()
    collapseReviews()

    if (theNote.classList.contains("review")) {
        expandReview(theNote)
        return
    }

    //all below is for notes only, reviews are handled elsewhere

    let theExpandedNote = document.createElement("div")
        theExpandedNote.id = "expandedNote"
        theExpandedNote.classList.add("expandedNote")
        theExpandedNote.style.backgroundColor = theNote.dataset.color 
        theExpandedNote.style.backgroundColor = lightenColor(window.getComputedStyle(theNote).backgroundColor, 50)

        theExpandedNote.innerHTML = /*html*/ `<b class='clickThru padRight'>
                                            <div id='placeholder'></div>
                                            ${theNote.dataset.headline}</b>
                                            <text class='clickThru' id='expandedNoteText'>${theNote.dataset.formattedText}</text>`
        theExpandedNote.dataset.line = theNote.dataset.line
        theExpandedNote.dataset.position = theNote.dataset.position
        theExpandedNote.dataset.length = theNote.dataset.length
        theExpandedNote.dataset.color = theNote.dataset.color
        theExpandedNote.style.position = "absolute"
        theExpandedNote.style.top = "50%"
        theExpandedNote.style.left = "50%"

        let expandedWidth = Math.min($(".faux, .section, .scene").getBoundingClientRect().width, window.innerWidth/2)
            theExpandedNote.style.width = expandedWidth + "px"


    flexiContainer.appendChild(theExpandedNote)
    
    //SET POSITION FOR THE EXPANDED NOTE:
        let sizeOfFlexi = $id("flexiContainer").getBoundingClientRect()
        let sizeOfExpandedNote = theExpandedNote.getBoundingClientRect()
        let position = theNote.getBoundingClientRect()

        if (position.top == 0 && position.left == 0) { //this is a note in an omitted scene
            position = theNote.closest(".section").getBoundingClientRect()
            theExpandedNote.classList.add("omittedNote")
        }
        let y = parseInt(JSON.stringify(position.top - sizeOfFlexi.top))
        let x = parseInt(JSON.stringify(position.left - sizeOfFlexi.left))
        let yOrigo = document.getElementById('flexiContainer').scrollTop

        let xPos = Math.min((x + 7.5 - expandedWidth/2), (sizeOfFlexi.width - expandedWidth - 40))
        let yPos = yOrigo + y + 25
            xPos = Math.max(xPos, 20)
            yPos = Math.max(yPos, 20)
        if (xPos + sizeOfExpandedNote.width > sizeOfFlexi.width - 40) {xPos = sizeOfFlexi.width - sizeOfExpandedNote.height - 40}
        if (yPos + sizeOfExpandedNote.height > document.getElementById('flexiContainer').scrollHeight - 40) {yPos = yOrigo + y - 10 - sizeOfExpandedNote.height}

        theExpandedNote.style.top = yPos + "px"
        theExpandedNote.style.left = xPos + "px"

        if (tabWasPressed){
            let trashDiv = document.createElement("div")
                trashDiv.id = "trashNote"
                trashDiv.classList.add("trashNote")
                trashDiv.innerHTML = trashIcon
                trashDiv.onclick = () => {deleteNote()}

            $id("placeholder").replaceWith(trashDiv)
        }
        $id("placeholder")?.remove()

        theExpandedNote.ondblclick = (event) => {
            editContent(event)}

}


function collapseNote(){

mylog(event?.type)

    //remove .isSelected from notePanel, to show hovered note in panel if open
    if($("#notepanel")){
        $id("notepanelNote" + selectedNote)?.classList.remove("isSelected")
        $id("notepanelNote" + selectedNote)?.firstChild.classList.remove("isSelected")
    }

if (event && event.type == "mouseleave" && (document.getElementById('trashNote'))) { //allow hover others when in tab-cycling
    return
}

if (document.getElementById('expandedNote')){
document.getElementById('expandedNote').remove()

let makeRehoverable = document.querySelectorAll('.noHover')
for (i = makeRehoverable.length -1; i > -1; i-- ){
    makeRehoverable[i].classList.remove('noHover')
}

let noteToUnselect = document.querySelector('.selectedNote')
if (noteToUnselect) {noteToUnselect.classList.remove('selectedNote')}
}
}

function deleteNote(){

theClickedThing = event.target

let length = Number(theClickedThing.closest(".expandedNote, .notepanelNote, .note").dataset.length) 
let location = Number(theClickedThing.closest(".expandedNote, .notepanelNote, .note").dataset.line)

goto(location, theClickedThing, length, "#bb8888")

let replaceString = ""
// //condition to find out if a note ends on the final index of a line, if so decrease range by one character so as to leave the linebreak.
//     let currentLine = lines.filter(line => line.range.location <= location + length && line.range.location + line.range.length >= location + length)[0]
//     if (location > currentLine.range.location && location + length == currentLine.range.location + currentLine.range.length){            
//         length --
//     }

setTimeout(() => {
    
    Beat.call((location, length, replaceString)=>{
        Beat.replaceRange(location, length, replaceString)
    }, location, length, replaceString)

}, 1750)

}

function collectReviewsAndThenCreateDoc(){

    alertThis("This feature is currently disabled")

    return

    //here, we should collect reviews if not collected already, then do as much as possible in here before sending to a new doc

}

function createDocFromReviews(reviewsData){

    let newDocumentContents = ">Below is a summary of all REVIEW items in the script<\n\n"
        newDocumentContents += ">**" + (documentSetting.documentName?.toUpperCase() || "UNTITLED") +"**<\n"
    let review = 0

    for (element of outline){

        mylog("in da loop!:" + element.line.string)

        if(review >= reviewsData.length) break

        if (outline.indexOf(element) == reviewsData[review].outlineElementNumber){

            let nearestHeading = element
            let nearestHeadingNumber = outline.indexOf(nearestHeading)
                while(nearestHeading.typeAsString != "Heading" && nearestHeading.typeAsString != "Section" && nearestHeadingNumber > 0){nearestHeading = outline[nearestHeadingNumber - 1]}


            newDocumentContents += `\n**-----------------------------------------------------------**\n`
            newDocumentContents += `\n${nearestHeading.line.string} ${(nearestHeading.sceneNumber ? ("#" + nearestHeading.sceneNumber + "#") : "")}\n\n`
        }

        while (outline[reviewsData[review].outlineElementNumber] == element){

            mylog("in da while" + reviewsData[review].string)

            newDocumentContents += "!_*REVIEW #" + review + "*_\n"
            newDocumentContents += "!*(re: " + entireScreenplay.substr(reviewsData[review].range[0], reviewsData[review].range[1]).trim().replaceAll("\n\n", "\n").replaceAll("\n", "*\n*") + ")*\n\n"
            newDocumentContents += `${reviewsData[review].string.trim()}\n`
            
            review++

            if(review >= reviewsData.length) break

            if(reviewsData[review].outlineElementNumber == reviewsData[review - 1].outlineElementNumber){
                newDocumentContents += `\n>------------------------------<\n\n`
            }

        }

        mylog("DONE")
    }


    Beat.call("Beat.newDocument(`" + newDocumentContents + "`)")

}

function displayReviews(reviewsData){

    if(!outline || !reviewsData) return

    if(!$id("notepanel").classList.contains("expanded") && !documentSetting.reviewsAreDisplayed) return

    //first loop to put parent on each review
    for (review of reviewsData){

        let parent = outline.filter(scene => scene.range.location <= review.range[0] && scene.range.location + scene.range.length >= review.range[0])[0]
            review.outlineElementNumber = outline.indexOf(parent)

    }
        
    globalReviewsData = reviewsData

    $$(".review").forEach(review => review.remove())

    if($id("notepanel").classList.contains("expanded")) updateNotepanel()
    if(!documentSetting.reviewsAreDisplayed) return

    for (review of reviewsData){

        let text = review.string
        let position = review.range[0]
        let element = review.outlineElementNumber
        
        let revdiv = document.createElement("div")
            revdiv.id = "review" + reviewsData.indexOf(review)
            revdiv.classList = "review"
            revdiv.style.position = "absolute"
            revdiv.dataset.line = position
            revdiv.dataset.length = review.range[1]
            revdiv.innerHTML = "✓"

            mylog(revdiv.id)
            
        let parentElement = $id(element).closest(".scene, .section")
            if (outline[parentElement.id].typeAsString == "Heading"){
                distance = 100 * (position - outline[parentElement.id].sceneStart) / (outline[parentElement.id].sceneEnd - outline[parentElement.id].sceneStart)
                revdiv.style.top = `calc(${distance}% - 14px)` //the 14px is to align note with speech bubble pointer!
            }else{
                revdiv.style.top = "0%"
            }

        parentElement.appendChild(revdiv)
    }

    mylog("and were done")

}

function highlightReviewInPanel(element){

    if(!element){
        elementsToUnselect = $$(".notepanelReview.isSelected")
        for (el of elementsToUnselect){
            el.classList.remove("isSelected")
        }
        return
    }

    if(!flexiContainer.classList.contains("notepanelIsExpanded"))return

    let elementInPanel = "notepanelR" + element.id.substr(1)
    
    $id(elementInPanel)?.classList.add("isSelected")

}

function createDocFromNotes(){

    if(!globalNotesData)collectNotes()

    let newDocumentContents = ">Below is a summary of all NOTES in the script<\n\n"
        newDocumentContents += ">**" + (documentSetting.documentName?.toUpperCase() || "UNTITLED") +"**<\n"
    let note = 0

    for (element of outline){

        mylog("in da loop!:" + element.line.string)

        if(note >= globalNotesData.length) break

        if (outline.indexOf(element) == globalNotesData[note].outlineElementNumber){

            let nearestHeading = element
            let nearestHeadingNumber = outline.indexOf(nearestHeading)
                while(nearestHeading.typeAsString != "Heading" && nearestHeading.typeAsString != "Section" && nearestHeadingNumber > 0){nearestHeading = outline[nearestHeadingNumber - 1]}

            newDocumentContents += `\n**-----------------------------------------------------------**\n`
            newDocumentContents += `\n${nearestHeading.line.string} ${(nearestHeading.sceneNumber ? ("#" + nearestHeading.sceneNumber + "#") : "")}\n\n`
        }

        while (outline[globalNotesData[note].outlineElementNumber] == element){

            mylog("in da while" + globalNotesData[note].string)

            newDocumentContents += `${globalNotesData[note].string.replace("[[", "").replace("]]", "").replace("<br/>", "\n").replace(/^!+|^\?+/, "").trim()}\n`
            
            note++

            if(note >= globalNotesData.length) break

            if(globalNotesData[note].outlineElementNumber == globalNotesData[note - 1].outlineElementNumber){
                newDocumentContents += `\n>------------------------------<\n\n`
            }

        }

        mylog("DONE")
    }

    Beat.call("Beat.newDocument(`" + newDocumentContents + "`)")

}

function displayBeats(){

    return
   
    if (globalBeatData.length < 1 && !$(".beat")) return
    mylog()

    let currentBeats = $$(".beat")
        for (currentBeat of currentBeats){currentBeat.remove()}
    let currentPaths = $$(".svgForBeats")
        for (currentPath of currentPaths){currentPath.remove()}
    let widthOfColumns = $(".section").getBoundingClientRect().width || $(".sceneheading").getBoundingClientRect().width

    //first lets make one SVG "canvas" the size of the flexiContainer
        let canvasSize = $id("flexiContainer").getBoundingClientRect()
        $id("flexiContainer").innerHTML += "<svg id='theCanvas' class='svgForBeats'></svg>"
        $id("theCanvas").style.position = "absolute"
        $id("theCanvas").style.left = canvasSize.left + "px"
        $id("theCanvas").style.top = canvasSize.top + "px"
        $id("theCanvas").style.width = canvasSize.width + "px"
        $id("theCanvas").style.height = canvasSize.height + "px"

        mylog("there is now an SVG canvas")

    for (let im = 0; im < globalBeatData.length; im++){

        //set element to parent where we will put the beat
        let element = $id(globalBeatData[im].outlineElementNumber) || $(".faux")
        if(!element)return

        theBeatToAddAsCode = "<div id = 'beat" + im + "' class='beat' data-storyline='" + globalBeatData[im].storyline + "' data-line='" + globalBeatData[im].position + "'>" + globalBeatData[im].story + "</div>" 
        element.innerHTML += theBeatToAddAsCode

        theBeatToAdd = $id("beat" +  im)

        theBeatToAdd.style.background = storyColors[globalBeatData[im].storyline - 1]
        theBeatToAdd.style.left = (5 + (globalBeatData[im].storyline - 1) * 15) + "%"
    
        let beatVerticalPosition = -2

        if((outline[globalBeatData[im].outlineElementNumber]?.typeAsString != "Section" 
            ||
            outline[globalBeatData[im].outlineElementNumber]?.numberOfPages > 0)
            && documentSetting.scenesAreProportional){
            beatVerticalPosition = globalBeatData[im].position - outline[globalBeatData[im].outlineElementNumber]?.line.position
            let percentageIntoScene = beatVerticalPosition / outline[globalBeatData[im].outlineElementNumber]?.sceneLength

            if(outline[globalBeatData[im].outlineElementNumber]?.typeAsString == "Section"){
                element = element.querySelector(".orphanText")
            }

            beatVerticalPosition = percentageIntoScene * (Number(element.getBoundingClientRect().height) - 12) //-14 is to fit entire beat inside
        
        }
    
        theBeatToAdd.style.top = beatVerticalPosition + "px"

        mylog("done adding beat #" + im)
    
        //add the connecting lines


        //first let's find the previous beat of this storyline (if present)
        let prev
        for(prev = im - 1; prev > -1; prev --){
            if (globalBeatData[prev].storyline == globalBeatData[im].storyline){
                break
            }
        }
        // now if such previous beat is indeed present, then draw the line
        if (prev > -1){

            mylog(prev + " " + im)
  
            let start = $id("beat" + prev).getBoundingClientRect()
            let end = $id("beat" + im).getBoundingClientRect()

            let theWidth = start.right - start.left 
            let theHeight = start.bottom - start.top
            let midX = start.left + (end.left - start.left)/2 + theWidth/2
            let midY = start.top + (end.top - start.top)/2 + theHeight/2
            
            let xCorrector = widthOfColumns/2
            let yCorrector = 50 //widthOfColumns 
            
            let currentStoryline = globalBeatData[im].storyline
            let thePathID = "path" + im
            let thePathToAdd = `<path class="allpaths hiddenPath pathOf` + currentStoryline + `" id='` + thePathID + `' D='
            M ` + (start.left + theWidth/2) + ` ` + 
                  (start.top + theHeight/2) + `
            C ` + (start.left + theWidth/2 + xCorrector) + ` ` + 
                  (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (end.left + theWidth/2 - xCorrector) + ` ` + (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2) + ` ` + (end.top + theHeight/2) + 
            ` ' fill = "none"/>`

            $id("theCanvas").innerHTML += thePathToAdd
        }

        //now actually make a duplicate of the last beat, and put it on top!
            let copyOf = theBeatToAdd.cloneNode(true)
            let rect = theBeatToAdd.getBoundingClientRect()
            copyOf.style.position = "absolute"
            copyOf.style.left = rect.left + "px"
            copyOf.style.top = rect.top + "px"
            copyOf.style.opacity = "1"
            copyOf.id = copyOf.id + "(copy)"
            copyOf.borderColor = storyColors[globalBeatData[im].storyline - 1] + " !important"
            copyOf.classList.add("copy", "hiddenBeat")
            copyOf.style.transformOrigin = "center center"
            copyOf.style.translate = "150% 0"
            $("#flexiContainer").appendChild(copyOf)
        
    }
    mylog("exiting")
}

function beatIsHovered(element){

    mylog()

    $$(".path").forEach(path => path.remove())
    $$(".largerBeat").forEach(beat => beat.remove())
    $$(".hoveredBeat").forEach(beat => beat.classList.remove("hoveredBeat"))

    element.classList.add("hoveredBeat")
    let category = element.getAttribute("data-title")
    let allAffectedBeats = Array.from($$(".beat[data-title='" + category + "']"))

    for (let beat of allAffectedBeats){

        beat.style.setProperty("--myWidth", beat.closest(".level1, .faux").getBoundingClientRect().width + "px")
        
        if(beat == allAffectedBeats[0]) continue //skip the first one

        let prevBeat = allAffectedBeats[allAffectedBeats.indexOf(beat) - 1]

        let thisRect = beat.getBoundingClientRect()
        let prevRect = prevBeat.getBoundingClientRect()

        let path = document.createElement("div")
            path.id = "path" + allAffectedBeats.indexOf(beat)
            path.classList.add("path")

            path.style.position = "absolute"
            let pathHeight = thisRect.top - prevRect.top
            let pathWidth = thisRect.left - prevRect.left
            path.style.bottom = "50%"
            path.style.right = "50%"
            path.style.width = Math.abs(pathWidth) + "px"     // 1.1 is to make up for extra bounding box area, to allow margin for overflow
            path.style.height = Math.abs(pathHeight) + "px"   // 1.1 is to make up for extra bounding box area, to allow margin for overflow

            path.innerHTML = /*html*/`<svg height="100%" width="100%" viewBox="0 0 1000 1000" preserveAspectRatio="none" vector-effect="non-scaling-stroke" style="overflow:visible" >
                                    <g>
                                        <path class="bottomstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M0,0 C1000,0 0,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                                        <path class="topstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M0,0 C1000,0 0,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                                    </g>
                            </svg>`

            if (beat.closest(".level1") == prevBeat.closest(".level1")) {

                pathWidth = beat.closest(".level1")?.getBoundingClientRect().width
                path.style.width = pathWidth + "px"
                path.style.left = (thisRect.width / 2) - (pathWidth / 2) + "px"
                path.innerHTML = /*html*/`<svg height="100%" width="100%" viewBox="0 0 1000 1000" preserveAspectRatio="none" vector-effect="non-scaling-stroke" style="overflow:visible" >
                                <g>
                                    <path class="bottomstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M500,0 C1200,0 -200,1000 500,1000" vector-effect="non-scaling-stroke"/>
                                    <path class="topstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M500,0 C1200,0 -200,1000 500,1000" vector-effect="non-scaling-stroke"/>
                                </g>
                        </svg>`
            }

            if (pathHeight < 0) {
                path.style.translate = "0 100%"
                path.style.transform = "scaleX(-1)"
                path.style.transformOrigin = "center bottom"
            }

            beat.appendChild(path)

            // now also let's copies of the beats on top!
            // first, if this is the first, then add a clone of the one we skipped
                if(!$(".largerBeat")){
                    cloneTheBeat(prevBeat)
                }
            //then, the rest of them
                cloneTheBeat(beat)

                function cloneTheBeat(beat) {

                    let notepanelWidth = $("#notepanel.expanded")?.getBoundingClientRect().width || 0

                    let copyOf = beat.cloneNode(false)
                    let rect = beat.getBoundingClientRect()
                        copyOf.innerText = beat.innerText
                        copyOf.dataset.title = "" //important, otherwise it will be a duplicate
                        copyOf.style.position = "absolute"
                        copyOf.style.left = rect.left - notepanelWidth + "px"
                        copyOf.style.top = rect.top + "px"
                        copyOf.style.opacity = "1"
                        copyOf.id = copyOf.id + "(copy)"
                        copyOf.classList.add("copy")
                        copyOf.style.pointerEvents = "none"
                        copyOf.style.translate = "0 0"
                        copyOf.style.transformOrigin = "center center"
                    $("#flexiContainer").appendChild(copyOf)
        
                    let redraw = copyOf.getBoundingClientRect()
                        copyOf.classList.add("largerBeat")
                }

    }

    return

    //first make sure the canvas is the same size as the flexiContainer!
    let flexiSize = $id("flexiContainer").getBoundingClientRect()
        $id("theCanvas").style.width = flexiSize.width
        $id("theCanvas").style.left = flexiSize.left

    let theHoveredStoryline = element.getAttribute("data-storyline")
    aBeatIsHovered = true

    let allpaths = $$(".allpaths")
    let thePathsToShow = $$(".pathOf" + theHoveredStoryline)
    let beatsOnTop = $$(".beat.copy")

    for (let path of allpaths){
        path.classList.add("hiddenPath")
    }
    for (let path of thePathsToShow){
        path.classList.remove("hiddenPath")
    }
    for (let beat of beatsOnTop){
        if(beat.getAttribute("data-storyline") == theHoveredStoryline){ 
            beat.classList.remove("hiddenBeat")
            beat.classList.add("largerBeat")
        }else{
            beat.classList.add("hiddenBeat")
            beat.classList.remove("largerBeat")
        }
    }
}

function unhoverAllBeats() {

    $$(".path").forEach(path => path.remove())
    $$(".largerBeat").forEach(beat => beat.remove())
    $$(".hoveredBeat").forEach(beat => beat.classList.remove("hoveredBeat"))

}

function lightenColor(color, percent){
  const validColor = /^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$|^rgb\(\s*(\d{1,3}\s*,\s*){2}\d{1,3}\s*\)$|^rgba\(\s*(\d{1,3}\s*,\s*){3}(\d?\.?\d+)\s*\)$|^hsl\(\s*\d{1,3}\s*,\s*\d{1,3}%\s*,\s*\d{1,3}%\s*\)$/;
  
  if (!validColor.test(color)) {
    throw new Error('Invalid color format');
  }

  let colorModel = '';
  let colorValues = [];

  if (color.startsWith('#')) {
    const hex = color.replace('#', '');
    if (hex.length === 3) {
      colorModel = 'hex3';
      colorValues = hex.split('').map(c => parseInt(c + c, 16));
    } else if (hex.length === 6) {
      colorModel = 'hex6';
      colorValues = hex.match(/.{2}/g).map(c => parseInt(c, 16));
    }
  } else if (color.startsWith('rgb')) {
    if (color.startsWith('rgba')) {
      colorModel = 'rgba';
      colorValues = color.match(/\d+\.?\d*/g).map(Number);
    } else {
      colorModel = 'rgb';
      colorValues = color.match(/\d+/g).map(Number);
    }
  } else if (color.startsWith('hsl')) {
    colorModel = 'hsl';
    colorValues = color.match(/\d+/g).map(Number);
  }

  const lightenValues = colorValues.map((value, index) => {
    if (colorModel === 'rgba' && index === 3) {
      return Math.min(1, value + (1 - value) * (percent / 100));
    }
    return Math.min(255, value + (255 - value) * (percent / 100));
  });
  
  switch (colorModel) {
    case 'hex3':
      return '#' + lightenValues.map(value => Math.floor(value / 16).toString(16)).join('');
    case 'hex6':
      return '#' + lightenValues.map(value => value.toString(16).padStart(2, '0')).join('');
    case 'rgb':
      return `rgb(${lightenValues.join(', ')})`;
    case 'rgba':
      return `rgba(${lightenValues.slice(0, 3).join(', ')}, ${lightenValues[3]})`;
    case 'hsl':
      return `hsl(${lightenValues[0]}, ${lightenValues[1]}%, ${lightenValues[2]}%)`;
    default:
      throw new Error('Invalid color format');
  }
};

function __________REVIEWS(){}

function expandReview(theClickedThing){

    if(!theClickedThing)return

    collapseReviews()
    
    reviewNumber = theClickedThing?.id.replace("review", "")

    

    expandedReview = $id("review"+reviewNumber)

    theClickedThing.classList.add("expandedReview")
    theClickedThing.classList.add("selectedNote")

    theClickedThing.innerHTML = "<div class='reviewHeadline'>REVIEW #" + reviewNumber + "</div>"
    theClickedThing.innerHTML += globalReviewsData[reviewNumber].string

    $id("notepanelReview" + reviewNumber)?.classList.add("isSelected")

}

function collapseReviews(){

    let expandedReviews = $$(".expandedReview")
    for (expandedReview of expandedReviews){
        expandedReview.classList.remove("expandedReview")
        expandedReview.innerHTML = "✓"
    }
    
    $(".notepanelReview.isSelected")?.classList.remove("isSelected")
}

function cycleNotes(shift){

    mylog("cycleNotes")
      
    if(!notesAreDisplayed && !reviewsAreDisplayed){
        toggleDisplayNotes()
        return
    }

    expandNote(true, shift)

    return
    
}

function AlternateWayToCalculateCurve(){

    let currentStoryline = globalBeatData[im].storyline
            let thePathID = "path" + im
            let thePathToAdd = `<path class="allpaths hiddenPath pathOf` + currentStoryline + `" id='` + thePathID + `' D='
            M ` + (start.left + theWidth/2) + ` ` + 
                  (start.top + theHeight/2) + `
            C ` + (start.left + theWidth/2 + xCorrector) + ` ` + 
                  (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (midX) + ` ` + (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (midX) + ` ` + (midY) + `  
            C ` + (midX) + ` `+ (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2 - xCorrector) + ` ` + (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2) + ` ` + (end.top + theHeight/2) + 
            ` ' fill = "none"/>`

            $id("theCanvas").innerHTML += thePathToAdd

}

function collectRevisionIndices(){

    if (!documentSetting.showRevisions)return
    mylog()

    Beat.call(`Beat.custom.collectRevisionsInPlugin()`)

}

function paintRevisions(changedAsJSON, reviewAsJSON){

    if(!outline) return

    mylog()

    let changedObject = JSON.parse(changedAsJSON)
    let reviewObject = JSON.parse(reviewAsJSON)

    // let currentDivs = $$(".revision")
    // if(currentDivs.length > 0){
    //     currentDivs.forEach(element => {
    //         element.remove()
    //     });
    // }

    $$(".revision").forEach(element => element.remove())

    for (line of reviewObject.Addition){
        
        // mylog(line)
    
        let changeStart = line[0]
        let changeLength = line[1]
        let changeColor = line[2]

        let outlineNumber

        for (let i = 0; i < outline.length - 1; i++) {
            outlineNumber = -1000
            if (outline[i]?.sceneStart > changeStart) {
                    outlineNumber = i - 1
                    while(outline[outlineNumber]?.typeAsString == "Synopse"){outlineNumber --}
                break}
        }

        if(outlineNumber < -999){
            mylog("no outline")
            outlineNumber = outline.length - 1}

        let revisionDiv = document.createElement("div")
            revisionDiv.id = "revisionAtIndex" + changeStart

        let changeStartPercent = 100 * (changeStart - outline[outlineNumber]?.sceneStart) / (outline[outlineNumber]?.range.length)
        let changeEndPercent = 100 * changeLength / (outline[outlineNumber]?.range.length)

        // now no more reading values, so lets rename outlineNumber
        if(outline[outlineNumber]?.typeAsString == "Section"){
                outlineNumber = "orphanInside" + outlineNumber
            }
            
            revisionDiv.style.position = "absolute"
            revisionDiv.style.top = changeStartPercent + "%"
            revisionDiv.style.height = changeEndPercent + "%"

            revisionDiv.classList.add("revision")
            revisionDiv.classList.add(changeColor)
            revisionDiv.dataset.line = changeStart
            revisionDiv.dataset.length = changeLength

            if($id(outlineNumber))$id(outlineNumber).appendChild(revisionDiv)
    
    }
}


</script>

<style>
    
    .revision{
                
        border-width: .5px;
        border-style: none;
        border-radius: 0.5px;

        /* width: calc(100% + 20px);
        left: -10px; */
        
        width: calc(6px);
        right: -9px;

        /* opacity: 0.8; */

        /* mix-blend-mode: multiply; */

        --background-opacity: 1

    }
    
    .revision.blue{
        background-color: rgba(51, 129, 239, var(--background-opacity));
        border-color: rgba(51, 129, 239, 1);
    }
    .revision.orange{
        background-color: rgba(250, 161, 15, var(--background-opacity));
        border-color: rgba(250, 161, 15, 1)
    }
    .revision.purple{
        background-color: rgba(181, 33, 218, var(--background-opacity));
        border-color: rgba(181, 33, 218, 1)
    }
    .revision.green{
        background-color: rgba(32, 223, 121, var(--background-opacity));
        border-color: rgba(32, 223, 121, 1)
    }

    .revision:hover{
        opacity: 1;
    }

    .review{

        height: 12px;
        width: 18px;
        background-color: #ffe575;
        border: 1px solid hsl(49, 37%, 16%);
        border-radius: 4px;
        color: #7f723a;

        right: -12px; 

        text-align: center;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: 8px;
        font-weight: bold;
        line-height: 10px;

        z-index: 9996;

        pointer-events: all;
    }

    .review.expandedReview{

        white-space: pre-wrap !important;
        word-wrap: break-word;

        right: 8px;

        height: auto !important;
        width: auto !important;
        max-width: 80% !important;
        min-width: 50% !important;
        padding: 18px 12px 40px 12px; 

        font-size: 11px;
        line-height: 14px;
        font-weight: normal;
        text-align: left;
        color: black;

        border-radius: 10px;
        border-color: #7f723a;

        z-index: 9999;
        box-shadow: 3px 3px 12px rgba(0,0,0,0.4);

        translate: 0 -6px;

    }

    .review > .reviewHeadline{

        position: absolute;
        top: 0;
        left: -1px;
        padding: 0px 12px 0px 12px;
        background-color: #7f723a;
        color: #ffe575;

        border-radius: 10px 10px 0 0 ;

        font-weight: bold;
        font-size: 8px;
        width: calc(100% + 2px);

    }

    .review::after{

        position: absolute;
        bottom: -3px;
        left: 3px;

        content: " ";
        
        border: 4px solid transparent;
        border-top: 0px solid transparent;
        border-left: 4px solid #ffe575;

    }

    .review.expandedReview::after{

        width: 0px;
        height: 0px;

        border-right: 0px;
        border-top: 4px transparent solid;
        border-bottom: 4px transparent solid;
        border-left: 8px solid #ffe575;

        top: 16px;
        left: unset;
        right: -6.44px !important;

    }

    .review::before{

        position: absolute;
        bottom: -5.44px;
        left: 2px;

        content: " ";

        border: 5.44px solid transparent;
        border-top: 0px solid transparent;
        border-left: 5.44px solid hsl(49, 37%, 16%);

    }

    .review.expandedReview::before{

        width: 0px;
        height: 0px;

        border-right: 0px;
        border-top: 5px transparent solid;
        border-bottom: 5px transparent solid;
        border-left: 8px solid #7f723a;

        top: 15px; 
        left: unset;
        right: -8px !important;

    }

    .review:not(.expandedReview).selectedNote,
    .review:hover {

        /* background: hsl(49, 37%, 16%) !important;
        color: #ffe575 !important; */
        border-color: black;

    }

    .review:not(.expandedReview).selectedNote > .reviewHeadline,
    .review:hover > .reviewHeadline {

        background: black;

    }

    .review:hover::before,
    .review:not(.expandedReview).selectedNote::before {
        border-color: transparent !important;
        border-left-color: black !important;
        background: transparent !important;
    }

    .review:hover::after,
    .review:not(.expandedReview).selectedNote::after {
        border-color: transparent !important;
        border-left-color: hsl(49, 37%, 16%) !important;
        background: transparent !important;
    }

</style>
<style>

#__________CONTEXTMENU{}

.contextMenu{

    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-size: 0.8rem;
    line-height: 0.8rem;

    --menuBackground: hsla(8, 17%, 91%, 0.8);
    --menuBorder: hsla(0, 0%, 0%, 0.2);
    --menuHover: #4C9AFD;

    background: var(--menuBackground);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);

    padding: 4px 4px;
    width: fit-content;
    border-radius: 6px;
    border: 1px solid var(--menuBorder) ;

    cursor: pointer;

    box-shadow: 2px 2px 15px rgba(0,0,0,0.3);

    z-index: 999999;

}

.contextMenu:focus{

    outline: none;

}

.contextMenu ul {

    padding: 0;
    margin: 0 !important

}

.contextMenu li{

    position: relative;

    display: block;
    padding: 3px 10px 3px 10px !important;
    margin: 0 !important;
    font-size: 13px;
    line-height: 18px !important;
    height: auto;

    list-style-type: none;
    border-radius: 4px;

}

.contextMenu li:not(.greyedOut):hover,
.contextMenu li:not(.greyedOut).keySelected {

    background: var(--menuHover);
    color: white;

}

.contextMenu li.greyedOut{

    opacity: 0.4;

}

.contextMenu hr{

    margin: 6px 8px;
    color: hsla(8, 17%, 91%, 0.6);
    opacity: 0.6;
}

.contextMenu .shortcut {

    float: right;
    padding-left: 20px;
    opacity: 0.3;
    letter-spacing: calc(0.1rem);

}

.contextmenuicon {

    float: left;
    margin-right: 8px;
    height: 14px;
    left: -2px;
    margin-top: 2px !important;
    width: 14px;
    color: hsla(var(--mycolor)) !important;
    fill: hsla(var(--mycolor)) !important;

    overflow: visible !important;

}

.checkedIcon::after {

    content: "✓";

    font-weight: bold;
    font-size: 10px;

    position: absolute;
    width: 100%;
    height: 100%;
    top: 3px;
    left: 12px;
    transform: -50% -50%;

    color: black;
    z-index: 99999;

}

.contextMenu svg{

    transition: none !important;
    fill: hsla(var(--mycolor)) !important;


}

.contextMenu li:not(.greyedOut):hover svg:not(.svgCircle), 
.contextMenu li:not(.greyedOut):hover .contextmenuicon {

        --mycolor: 0, 0%, 100%, 1;
        /* fill: white; */
        
}

</style>

<script>

    let replacableKeys = ["Shift", "Alt", "Meta", "Control", "Tab", "Enter", "Backspace", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "LeftClick"]
    let keystToReplace = ["⇧", "⌥", "⌘", "⌃", "⇥", "↩", "⌫", "↑", "↓", "←", "→", leftClickIcon]
    let svgCircle = "<svg class='svgCircle' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50'/></svg>"
    
    //First create the colors menu
    const availableColors = colorsArray    
    let colorMenuItems = []
        colorsArray.forEach (color => {
            colorMenuItems.push({
                menuItem: color,
                shortcut: [""],
                icon: svgCircle,
                iconColor: color,
                showFor: ["synopsis", "scene", "section"],
                command: (item) => { setItemColor(item, color) },
            })
        })
        colorMenuItems.find(item => item.menuItem === "Remove Color").icon = "<p style ='font-size: 22px !important; transform: translateY(-6px); line-height: 24px !important;'>&#xd7;</p>"
        colorMenuItems.find(item => item.menuItem === "Special").icon = ""
        colorMenuItems.find(item => item.menuItem === "Special").showFor = ["section"]

    //then add all the other menuitems
    let contextMenuContents = colorMenuItems.concat([
        {   
            //NOTE: this entry is a template for the available/used keys in the menu object
            menuItem: "template",
            menuName: function(item) {return "Menu Name"},
            shortcut: ["Meta", "Control", "Alt", "t"],
            icon: svgCircle,
            iconColor: "red",
            iconSpecialColor: function(item) {return "red"},
            hoverColor: "blue",
            showFor: ["nothing"],
            butNotFor: ["omitted"],
            greyOutIf: () => { return !document.querySelector(".selected") }, 
            checkedIf: (item) => { return item.classList.contains("checked") },
            command: (item) => { zoomTo("all", item) },
        },
        {
            menuItem: "divider",
            showFor: ["synopsis", "scene", "section"],
        },
        {   
            menuItem: "Highlight color",
            menuName: function(item) {
                let col = availableColors.find(col => item.classList.contains(col.toLowerCase()))
                if (!col) return "Can't Highlight Custom Colors"
                return this.invisiblyChecked(item) ? `Un-highlight ${col} Scenes`: `Highlight ${col} Scenes`},
            shortcut: ["Alt", "LeftClick"],
            icon: funnelIcon,
            iconColor: "",
            hoverColor: "",
            iconSpecialColor: function(item) {return (this.invisiblyChecked(item)) ? availableColors.find(col => item?.classList?.contains(col.toLowerCase())) : "" }, 
            showFor: ["scene"],
            // butNotFor: ["holiday"],
            invisiblyChecked: (item) => { return (!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase())) },
            //checkedIf: (item) => { return (!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase())) },
            greyOutIf: (item) => { return !availableColors.find(col => item.classList.contains(col.toLowerCase())) }, 
            command: (item) => { muteColors(item) },
        },
        {   
            menuItem: "Un-highlight all colors",
            // menuName: function(item) {
            //     let col = availableColors.find(col => item.classList.contains(col.toLowerCase()))
            //     if (!col) return "Can Only Highlight Standard Colors"
            //     return this.checkedIf(item) ? `Un-highlight ${col} Scenes`: `Highlight ${col} Scenes`},
            shortcut: ["Alt", "LeftClick"],
            icon: funnelIcon,
            iconColor: "",
            hoverColor: "",
            iconSpecialColor: function(item) {return ((!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase()))) ? 
                availableColors.find(col => item.classList.contains(col.toLowerCase())) : "" }, 
            showFor: ["flexiContainer"],
            // butNotFor: ["holiday"],
            //checkedIf: (item) => { return (!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase())) },
            greyOutIf: (item) => { return !availableColors.find(col => item.classList.contains(col.toLowerCase())) }, 
            command: (item) => { muteColors(null) },
        },
        {   
            menuItem: "Selection to new Doc",
            shortcut: [""],
            icon: toNewIcon,
            iconColor: "",
            showFor: ["scene"],
            command: (item) => { copyContentsToClipboard() },
        },
        {
            menuItem: "divider",
            showFor: ["scene"],
        },
        //  OMIT AND UN-OMIT ARE CURRENTLY NOT AVAILABLE because wonky
        //  Must be be fixed in order to be used
        // {   
        //     menuItem: "Omit Scene",
        //     shortcut: [""],
        //     icon: hiddenIcon,
        //     iconColor: "",
        //     showFor: ["scene"],
        //     butNotFor: ["isOmitted"],
        //     command: (item) => { omitScene(item) },
        // },
        // {   
        //     menuItem: "Un-omit Scene",
        //     shortcut: [""],
        //     icon: showIcon,
        //     iconColor: "",
        //     showFor: ["isOmitted"],
        //     butNotFor: ["section", "synopsis"],
        //     command: (item) => { unOmitScene(item) },
        // },
        {   
            menuItem: "Rename Scene",
            menuName: (item) => {return "Rename " + (item.classList.contains("scene") ? "Scene" : item.classList.contains("section") ? "Section Header" : item.classList.contains("synopsis") ? "Synopsis" : "")},
            shortcut: ["Alt","Enter"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: (item) => { return $$(".isSelected").length > 1 },
            command: (item) => { editContent(false, $id("youAreHere").closest(".scene, .section")) }, //false is instead of sending an event
        },
        {   
            menuItem: "Delete Scene",
            menuName: (item) => {return "Delete " + (item.classList.contains("scene") ? "Scene" : item.classList.contains("section") ? "Section Header" : item.classList.contains("synopsis") ? "Synopsis" : "")},
            shortcut: ["Meta","Backspace"],
            icon: trashIcon,
            iconColor: "",
            hoverColor: "#880000",
            showFor: ["synopsis", "scene", "section"],
            command: (item) => { deleteScene() }, //send no element, finds selected element in function instead
        },
        {
            menuItem: "divider",
            showFor: ["scene", "section"],
        },
        {   
            menuItem: "Demote Section Level",
            shortcut: ["Control", "Alt", "ArrowRight"],
            icon: "",
            iconColor: "",
            showFor: ["section"],
            // butNotFor: ["level5", "level6", "level7", "level8", "level9"],
            greyOutIf: (item) => { return ["level5", "level6", "level7", "level8", "level9"].includes(item.classList) }, 
            command: (item) => { promoteSection(item) },
        },
        {   
            menuItem: "Promote Section Level",
            shortcut: ["Control", "Alt", "ArrowLeft"],
            icon: "",
            iconColor: "",
            showFor: ["section"],
            // butNotFor: ["level1"],
            greyOutIf: (item) => { return item.classList.contains("level1") }, 
            command: (item) => { demoteSection(item) },
        },
        {
            menuItem: "divider",
            showFor: ["section"],
        },
        {   
            menuItem: "Add Section Before",
            shortcut: ["Control", "Alt", "Shift", "ArrowUp"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 }, 
            command: (item) => { addElement(item, "section", true) }, //true means beforeInsteadOfAfter
        },
        {   
            menuItem: "Add Section After",
            shortcut: ["Control", "Alt", "Shift", "ArrowDown"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 },  
            command: (item) => { addElement(item, "section") },
        },
        {
            menuItem: "divider",
            showFor: ["scene", "section"],
        },
        {   
            menuItem: "Add Scene Before",
            shortcut: ["Control", "Alt", "ArrowUp"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 }, 
            command: (item) => { addElement(item, "scene", true) }, //true means beforeInsteadOfAfter
        },
        {   
            menuItem: "Add Scene After",
            shortcut: ["Control", "Alt", "ArrowDown"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 },  
            command: (item) => { addElement(item, "scene") },
        },
        // {   
        //     menuItem: "Unlocked scenes to A-scenes",
        //     shortcut: ["!"],
        //     icon: "",
        //     iconColor: "",
        //     showFor: ["flexiContainer"],
        //     greyOutIf: () => { return !outline.find(scene => (/(?:#)(.+)(?:#){1}\s*$/.test(scene.string))) },  
        //     command: (item) => { addLetteredScenesWhenLocked() },
        // },
        //------------------------------SCENE PANEL
        {
            menuItem: "Change THIS occurrence to:",
            menuName: (item) => {let singleText = "THIS occurence "; //default, when not merged lines
                if (Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2) singleText = "THIS LONE occurence "; //when only occurence, regardless of merged or not
                if ($id("mergeSimilarLocations").checked && item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0) singleText = "occurence IN SCENE " + item.closest('.line').querySelector('.sceneNum')?.textContent + " "; //when merged lines and hidden locations on line
                return "Change " + singleText + "to:"},
            spanText: (item) => {
                let hiddenOnLine = item.closest(".line").querySelectorAll(".duplicateSceneNum").length
                return ($id("mergeSimilarLocations").checked && hiddenOnLine > 0) ? hiddenOnLine + " hidden on line will not change" : ""
                },
            nonSelectable: true,
            icon: "",
            iconColor: "",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
            // greyOutIf: (item) => { return $id("mergeSimilarLocations").checked && item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { alertThis("not implemented") },
        },
        {
            menuItem: "replaceSingleLocation",
            showFor: ["special case for similarLocation"],
        },
        {
            menuItem: "New name for THIS occurence...",
            menuName: (item) => {
                if (item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation")) { return "Custom..." }
                let singleText = "THIS occurence of " + item.textContent; //default, when not merged lines
                if (Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2) singleText = "THIS LONE occurence"; //when only occurence, regardless of merged or not
                if ($id("mergeSimilarLocations").checked && item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0) singleText = "occurence IN SCENE " + item.closest('.line').querySelector('.sceneNum')?.textContent + ""; //when merged lines and hidden locations on line
                return "Change " + singleText + " to custom..."},
            spanText: (item) => {                
                let hiddenOnLine = item.closest(".line").querySelectorAll(".duplicateSceneNum").length
                return ($id("mergeSimilarLocations").checked && hiddenOnLine > 0) ? hiddenOnLine + " hidden on line will not change" : ""
                },
            indent: (item) => { return item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation") }, // returns true or false
            whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            whenUnHovering: (item) => { 
                if($id("contextMenu")) {$$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) }
                },
            icon: "",
            iconColor: "",
            showFor: ["location", "similarLocation"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { newNameDialog(Array.of(item)) },
        },
        {
            menuItem: "divider",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
        },
        {
            menuItem: "Change ALL occurrences to:",
            menuName: (item) => {
                return "Change ALL " +
                Array.from($$(".location")).filter(location => location.textContent == item.textContent).length
                + " occurrences to:"
                },
            spanText: (item) => {
                let hiddenItems = Array.from($$(":has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .location")).filter(location => location.textContent == item.textContent)
                return hiddenItems.length ? "including " + hiddenItems.length + " currently hidden)" : ""
                },
            nonSelectable: true,
            icon: "",
            iconColor: "",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
            butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
            command: (item) => { },
            },
        {
            menuItem: "replaceAllLocations",
            showFor: ["special case for similarLocation"],
            },
        {
            menuItem: "New name for all occurences...",
            menuName: (item) => {
                if (item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation")) { return "Custom..." }
                return "Change ALL " +
                Array.from($$(".location")).filter(location => location.textContent == item.textContent).length
                + " occurrences of " + item.textContent + " to custom..."
                },
            spanText: (item) => {
                let hiddenItems = Array.from($$(":has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .location")).filter(location => location.textContent == item.textContent)
                return hiddenItems.length ? "including " + hiddenItems.length + " currently hidden" : ""
                },
            indent: (item) => { return item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation") }, // returns true or false
            whenHovering: (item) => { 
                itemsToColor = Array.from($$(".location")).filter(location => location.textContent == item.textContent) 
                itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
                },
            whenUnHovering: (item) => { 
                if($id("contextMenu")) {$$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) }
                },
            icon: "",
            iconColor: "",
            showFor: ["location", "similarLocation"],
            butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
            //greyOutIf: () => { return !outline.find(scene => (/(?:#)(.+)(?:#){1}\s*$/.test(scene.string))) },  
            command: (item) => { newNameDialog(Array.from($$(".highlighted"))) },
        },
        // {
        //     menuItem: "divider",
        //     showFor: ["similarLocation"],
        //     butNotFor: ["excludedLocation"],
        //     butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
            // },
        {
            menuItem: "divider",
            showFor: ["location"],
            butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
        },
        {
            menuItem: "Exclude this location name from being checked",
            menuName: (item) => {
                return "Exclude " + item.textContent + " from spellcheck"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.excludedLocations) documentSetting.excludedLocations = []
                documentSetting.excludedLocations.push(item.textContent)
                saveCurrentState()
                $$(".location").forEach(element => {if (element.textContent == item.textContent) element.classList.add("excludedLocation")})             
            },
        },
        {
            menuItem: "Remove from excluded location names",
            menuName: (item) => {
                return "Stop excluding " + item.textContent + " from spellcheck"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["excludedLocation"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.excludedLocations) documentSetting.excludedLocations = []
                documentSetting.excludedLocations.splice(documentSetting.excludedLocations.indexOf(item.textContent), 1)
                saveCurrentState()
                $$(".location").forEach(element => {if (element.textContent == item.textContent) element.classList.remove("excludedLocation")})
            },
        },
        {
            menuItem: "Empty list of locations exluded from spellcheck",
            icon: "",
            iconColor: "",
            showFor: ["location", "line", "scenespanelgroup", "scenespanelcontent"],
            greyOutIf: (item) => { return documentSetting.excludedLocations?.length < 1 },  
            command: (item) => { 

                documentSetting.excludedLocations = []
                saveCurrentState()
                $$(".excludedLocation").forEach(element => element.classList.remove("excludedLocation"))
            },
        },
        {
            menuItem: "divider",
            showFor: ["location"],
        },
        {
            menuItem: "Disregard when sorting",
            menuName: (item) => {
                return "Disregard " + item.textContent + " when sorting/grouping"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["location"],
            butNotFor: ["dontCompare"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.groupExclusions) documentSetting.groupExclusions = []
                documentSetting.groupExclusions.push(item.textContent)
                saveCurrentState()
                parseSceneHeadings()
            },
        },
        {
            menuItem: "Stop disregarding when sorting",
            menuName: (item) => {
                return "Stop disregarding " + item.textContent + " when sorting/grouping"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["dontCompare"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.groupExclusions) documentSetting.groupExclusions = []
                documentSetting.groupExclusions.splice(documentSetting.groupExclusions.indexOf(item.textContent), 1)
                saveCurrentState()
                parseSceneHeadings()
            },
        },
        {
            menuItem: "Empty list of locations disregarded when sorting",
            icon: "",
            iconColor: "",
            showFor: ["location", "line", "scenespanelgroup", "scenespanelcontent"],
            greyOutIf: (item) => { return documentSetting.groupExclusions?.length < 1 },  
            command: (item) => { 

                documentSetting.groupExclusions = []
                saveCurrentState()
                parseSceneHeadings()
            },
        },
    //make location into ToD
        {
            menuItem: "divider",
            showFor: ["location"],
            butDontShowIf: (item) => { 
                locationsOnLine = Array.from(item.closest(".line").querySelectorAll(".location:not(.addon)"))
                return !(item == locationsOnLine.at(-1) && item != locationsOnLine.at(0))},        },
        {
            menuItem: "Make this location a Time of Day",
            menuName: (item) => {
                return "Make " + item.textContent + " a Time of Day..."
                },
            icon: "",
            iconColor: "",
            showFor: ["location"],
            butDontShowIf: (item) => { 
                locationsOnLine = Array.from(item.closest(".line").querySelectorAll(".location:not(.addon)"))
                return !(item == locationsOnLine.at(-1) && item != locationsOnLine.at(0))},
            whenHovering: (item) => { 
                itemsToColor = Array.from($$(".location")).filter(location => location.textContent == item.textContent) 
                itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
                },
            whenUnHovering: (item) => { 
                // if($id("contextMenu")) {
                    $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) 
                // }
            },
            command: (item) => { makeLocationToD(item) },
        },
        //make ToD into Location
        {
            menuItem: "Make this location a Time of Day",
            menuName: (item) => {
                return "Remove " + item.textContent + " from list of Times-of-Day..."
                },
            icon: "",
            iconColor: "",
            showFor: ["timeOfDay"],
            butDontShowIf: (item) => { return item.textContent == "UNKNOWN"},
            whenHovering: (item) => { 
                itemsToColor = Array.from($$(".timeOfDay")).filter(location => location.textContent == item.textContent) 
                itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
                },
            whenUnHovering: (item) => { 
                // if($id("contextMenu")) {
                    $$(".timeOfDay.highlighted").forEach(item => item.classList.toggle("highlighted", false)) 
                // }
            },
            command: (item) => { makeTodLocation(item) },
        },
        // {
        //     menuItem: "divider",
        //     showFor: ["timeOfDay"],
        //     butDontShowIf: (item) => { return item.textContent == "UNKNOWN"},      
        // },
    ])

function __________END_OF_MENU_OBJECT(){}

function newNameDialog(itemArray){

    itemArray.forEach(item => item.classList.add("highlighted"))

    let oldName = itemArray[0].textContent
    let newName = ""

	Beat.callAndWait((oldName, itemArray) => {
        result = Beat.prompt(
            `Location Name Change for ${itemArray.length} scene(s)`,
            `Change the current location name ${oldName} into:`, 
            `${oldName}`
        )    	
        return result
    }, oldName, itemArray)
    .then(
        response => { 
            newName = response
            if (newName == "") return
            if (newName == oldName) return
            if (newName == false) return

            itemArray.forEach(item => item.classList.remove("highlighted"))
            itemArray.sort((a,b) => b.dataset.startIndex - a.dataset.startIndex).forEach(highlighted => swapLocationParts(highlighted.dataset.startIndex, highlighted.dataset.endIndex, `${newName}`))
            return 
        },
        error => { 
            itemArray.forEach(item => item.classList.remove("highlighted"))
            console.log("Error waiting for new name dialog") 
        }
    )
}

function displayContextMenu(event, element){

    event?.preventDefault()
    event?.stopPropagation()
    closeNewMenu()

    element = element || event.target //the element is sent when triggering menu with keys
    let item = element.closest(".synopsis, .scene, .section, .flexiContainer, .location, .timeOfDay, #scenespanelcontent, #scenepanelSettingsButton, #notepanel")
        if (!item) return
        console.log("right clicked " + item.id + ": " + item.classList)

    if (!event?.shiftKey && !event?.metaKey && !item.classList.contains('isSelected')) {deselectAllElements()}
        item.classList.add("isSelected")

    document.querySelectorAll(".contextMenu").forEach( menu => {menu.remove()})
        if (!item) return


    //dynamically add the menu items for similar locations
        contextMenuContents = contextMenuContents.filter(entry => entry.removeAfterUse !== true);
        if (item.classList.contains("similarLocation")){
            let indexToReplace = contextMenuContents.indexOf(contextMenuContents.find(item => item.menuItem == "replaceSingleLocation"))
                contextMenuContents.splice(indexToReplace, 0, ...createReplacementMenuItems(item))
                indexToReplace = contextMenuContents.indexOf(contextMenuContents.find(item => item.menuItem == "replaceAllLocations"))
                contextMenuContents.splice(indexToReplace, 0, ...createReplacementMenuItems(item, true)) //true means all
        }

    let contextMenu = document.createElement("div")
        contextMenu.id = "contextMenu"
        contextMenu.tabIndex = "1"
        contextMenu.classList.add("contextMenu")
        contextMenu.style.position = "absolute"
        let ypos = (event?.clientY || element.getBoundingClientRect().top) + 10
        let xpos = (event?.clientX || element.getBoundingClientRect().left) + 10
        contextMenu.style.top = ypos + "px"
        contextMenu.style.left = xpos + "px"
        contextMenu.onmouseenter = function(){ $$(".keySelected").forEach(item => item.classList.remove("keySelected")) }
        contextMenu.addEventListener("keydown", function(event){
            event.preventDefault()
            event.stopPropagation()
            let items = Array.from(contextMenu.querySelectorAll("li:not(.greyedOut)"))
                if(!items.length) return
            let currentlySelected = items.indexOf(contextMenu.querySelector(".keySelected"))
            if (event.key == "Escape") contextMenu.remove()
            if (event.key == "ArrowDown") {
                    if (currentlySelected === undefined || currentlySelected == items.length -1) currentlySelected = -1
                    items.forEach(item => item.classList.toggle("keySelected", false))
                    items[currentlySelected + 1]?.classList.toggle("keySelected", true)
            }
            if (event.key == "ArrowUp") {
                if (currentlySelected === undefined || currentlySelected == -1) currentlySelected = items.length
                    items.forEach(item => item.classList.toggle("keySelected", false))
                    items[currentlySelected - 1]?.classList.toggle("keySelected", true)
            }
            if (event.key == "Enter") {
                items[currentlySelected]?.click()
                $$(".isSelected").forEach(item => item.classList.remove("isSelected"))
            }
        })
    
    document.body.appendChild(contextMenu)

        contextMenu.focus()
        contextMenu.onblur = function(){ contextMenu.remove() }

    let list = document.createElement("ul")
    for (contentLine of contextMenuContents){

        if (!contentLine.showFor.some(classname => {return item.classList.contains(classname)})) continue
        if (contentLine.butDontShowIf && contentLine.butDontShowIf(item)) continue
        if (contentLine.butNotFor && contentLine.butNotFor.some(classname => {return item.classList.contains(classname)})) continue

        if (contentLine.menuItem == "divider"){
            let listItem = document.createElement("hr")
                list.appendChild(listItem)
                continue
        }

        let shortcutKeysInObj = contentLine.shortcut || ""
        let shortcutKeys = []
            for(shortcutKey of shortcutKeysInObj){
                if (replacableKeys.includes(shortcutKey)){
                    shortcutKey = keystToReplace[replacableKeys.indexOf(shortcutKey)]
                }
            shortcutKeys.push(shortcutKey.toUpperCase())
            }

        let listItem = document.createElement("li")
            if(contentLine.class) listItem.classList.add(contentLine.class) //for special cases
         
        if(contentLine.hoverColor) listItem.style.setProperty("--menuHover", contentLine.hoverColor)
        if(contentLine.greyOutIf) listItem.classList.toggle("greyedOut", contentLine.greyOutIf(item))
        if(contentLine.nonSelectable) listItem.style.pointerEvents = "none"
        if(contentLine.fontWeight) listItem.style.fontWeight = contentLine.fontWeight

        if(contentLine.whenHovering){
            listItem.onmouseenter = (function(command) {
                return function(event) {
                    event.stopImmediatePropagation()
                    event.stopPropagation()
                    event.preventDefault()
                    command(item);
                }
            })(contentLine.whenHovering)
        }
        if(contentLine.whenUnHovering){
            listItem.onmouseleave = (function(command) {
                return function(event) {
                    event.stopImmediatePropagation()
                    event.stopPropagation()
                    event.preventDefault()
                    command(item);
                }
            })(contentLine.whenUnHovering)
        }

        if(!listItem.classList.contains("greyedOut")){
                listItem.onclick = (function(command) {
                return function(event) {
                    event.stopImmediatePropagation()
                    event.stopPropagation()
                    event.preventDefault()
                    command(item);
                    contextMenu.remove()
                }
            })(contentLine.command);
            listItem.oncontextmenu = listItem.onclick
        }

            let iconChecked = false
                if(contentLine.checkedIf && contentLine.checkedIf(item)) iconChecked = true
            
            let iconColor = contentLine.iconColor.toLowerCase()
                if (contentLine.iconSpecialColor) iconColor = contentLine.iconSpecialColor(item).toLowerCase()

                if(availableColors.some(col => contentLine.menuItem.toLowerCase() == col.toLowerCase()) && (item.classList.contains(contentLine.menuItem.toLowerCase()))){
                    iconChecked = true
                }
            let menuName = contentLine.menuItem
                if (contentLine.menuName) menuName = contentLine.menuName(item)
                if (contentLine.spanText) menuName += `<span style='float: right; font-size: 10px; opacity: 0.6; padding-left: 10px;'>${contentLine.spanText(item)}</span>`
            listItem.innerHTML = `<span class='contextmenuicon ${iconChecked ? "checkedIcon" : ""}' style='--mycolor: var(--${iconColor})'>${contentLine.icon || ""}</span>${menuName}<span class='shortcut'>${shortcutKeys.join("")}</span>`;
                if (contentLine.indent && contentLine.indent(item)) listItem.style.borderLeft = "15px solid transparent"

            if (contentLine.iconOutline) listItem.querySelector(".contextmenuicon").style.stroke = contentLine.iconOutline(item)

        list.appendChild(listItem)
    }
    contextMenu.appendChild(list)

    if (xpos + contextMenu.offsetWidth > window.innerWidth) contextMenu.style.left = window.innerWidth - contextMenu.offsetWidth + "px"
    if (ypos + contextMenu.offsetHeight > window.innerHeight) contextMenu.style.top = window.innerHeight - contextMenu.offsetHeight + "px"

    if (list.textContent == "") contextMenu.remove()

}

function setItemColor(item, color){

    toggleWaitState(true)
    $$(".contextMenu").forEach(menu => {menu.remove()})

    if (color.toLowerCase() == "remove color") {color = "none"}

    // if (!item.classList.contains("isSelected") && $$("isSelected").length) {deselectAllElements()} //deselect all other elements if a new one is selected
    if (item && !$$("isSelected").length) {item.classList.add("isSelected")} //select the item if it is not selected yet

    let elements = $$('.isSelected') ||[item]

    for (element of elements) {

        let elementId = element.id

        if (element.classList.contains("synopsis")){
			let parentId = element.closest(".scene, .section").id
			let synopsisNumber = Number(elementId.toString().replace(/^s.*_/, ""))

            Beat.call(([color, parentId, synopsisNumber])=>{
                Beat.setColorForScene(color, Beat.outline()[parentId]?.synopsis[synopsisNumber])
            }, [color, parentId, synopsisNumber])
        
        }else{

            Beat.call((color, elementId)=>{
                Beat.setColorForScene(color, Beat.outline()[elementId])
            }, color, elementId)
        
        } 
    }
}   

function deselectAllElements(){

    mylog()

    $$('.isSelected').forEach(item => item.classList.remove('isSelected'))
    updateSelectionInfo()

}

function createReplacementMenuItems(item, all = false){

    let arrayToReturn = []
    let addedSubstitutes = []
    let substitutes = item.dataset.similarTo.split(",") || []

    let hoverSingle = (item) => { item.classList.toggle("highlighted", true) }
    let hoverAll = (item) => { 
        itemsToColor = Array.from($$(".location")).filter(location => location.textContent == item.textContent) 
        itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
        }

    let hoverString = all ? hoverAll : hoverSingle
    let butDontShowIfString = all ? (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 } : ""
    let greyOutIfString = all ? "" : (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 }

    for (let substitute of substitutes){

        if (substitute == "" || addedSubstitutes.includes(substitute)) continue
        addedSubstitutes.push(substitute)

        let replaceSingleLocation = (item) => { swapLocationParts(item.dataset.startIndex, item.dataset.endIndex, `${substitute}`) }
        let replaceAllLocations = (item) => { Array.from($$(".highlighted")).sort((a,b) => b.dataset.startIndex - a.dataset.startIndex).forEach(highlighted => swapLocationParts(highlighted.dataset.startIndex, highlighted.dataset.endIndex, `${substitute}`) )}
        let commandString = all ? replaceAllLocations : replaceSingleLocation

        arrayToReturn.push(
            {
                menuItem: `${substitute}`,
                indent: () => {return true},
                whenHovering: hoverString,
                whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
                fontWeight: "bold",
                icon: "",
                iconColor: "",
                showFor: ["similarLocation"],
                butNotFor: ["excludedLocation"],
                butDontShowIf: butDontShowIfString,
                // greyOutIf: greyOutIfString,  
                command: commandString,

                removeAfterUse: true,
            }
        )

    }

    return arrayToReturn

}

</script>



<!-- OLD STUFF BELOW -->

<style>
#contextmenu {
    position: absolute;
    /* background-color: rgba(192,192,192,0.9); */
    background-color: rgba(232,232,232,0.9);
    border-radius: 6px;
    font-size: 13px !important; /*was 14*/
    line-height: 16px !important; /*was 20*/
    padding: 6px 10px !important;
    z-index: 99999;
    border: 1px rgb(192, 192, 192) solid;
    box-shadow: 5px 5px 10px rgba(0,0,0,0.3) !important;
    min-width: 200px;

    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;

    
}

#contextmenu .visible {
    display: block;
}

#contextmenu:not(.visible){
    display: none;
}

#contextmenu li {
    color: black;
    list-style-type: none;
    vertical-align: middle !important;
    /* padding-top: 0px !important; */
    padding: 3px 6px 3px 6px !important;
    margin: 0px -6px 0px -6px !important;
}

#contextmenu li:hover {
    background-color: rgb(15,110,212);
    color: white;
    border-radius: 4px !important;
    /* margin-left: -6px !important;
    margin-right: -6px !important;
    padding-left: 6px !important;
    padding-right: 6px !important;
    padding-top: 3px !important; */

    padding: 3px 6px 3px 6px !important;
    margin: 0px -6px 0px -6px !important;
}

#deleteSceneCommand:hover {
    background-color: rgb(128, 0, 0) !important;
    color: white;
    border-radius: 4px !important;
    /* margin-left: -6px !important;
    margin-right: -6px !important;
    padding-left: 6px !important;
    padding-right: 6px !important; */

    padding: 3px 6px 3px 6px !important;
    margin: 0px -6px 0px -6px !important;
}

.colorSquare {
    width: 14px !important; /*was 16*/
    height: 14px !important; /*was 16*/
    border-radius: 50% !important;
    display: inline-block !important;
    padding-top: 4px !important;
    transform: translateY(2.5px);
    overflow: hidden !important;
}

.trashCanMenuItem, .eyeWithCrossMenuItem, .eyeMenuItem, .clipboardMenuItem {
    height: 14px !important;
    width: 14px !important;
    display: inline-block !important;
    transform: translateY(2.5px);
}

.trashCanMenuItem > .trashbutton{
    fill: rgb(165, 0, 0);
    opacity: 0.8 !important;
    transition: fill 0ms !important;
}

.eyeWithCrossMenuItem > .eyeWithCrossIcon,
.eyeMenuItem > .eyeIcon,
.clipboardmenuItem > toNewIcon {
    fill: black;
    opacity: 0.8 !important;
    transition: fill 0ms !important;
}

.trashCanMenuItem:hover > .trashbutton, #deleteSceneCommand:hover > .trashCanMenuItem > .trashbutton, 
.eyeWithCrossMenuItem:hover > .eyeWithCrossIcon, #omitSceneCommand:hover > .eyeWithCrossMenuItem > .eyeWithCrossIcon
.eyeMenuItem:hover > .eyeIcon, #unOmitSceneCommand:hover > .eyeMenuItem > .eyeIcon,
.clipboardMenuItem:hover > #toNewIcon{
    fill: white !important;
    opacity: 1 !important;
    transition: fill 0ms !important;
}

.displayNone{
    display: none !important;
}

.shrinkingWhenOmitting, .shrinkingWhenOmitting > p, div.shrinkingWhenOmitting{
    background: 	repeating-linear-gradient(
			-45deg,
			rgba(0,0,0,0.1) 0px,
			rgba(0,0,0,0.1) 3px,
			rgba(255,255,255,0.05) 3px,
			rgba(255,255,255,0.05) 6px)
			,
	rgba(221, 221, 221, 1) !important;
    height: 0px !important;
    opacity: 0 !important;
    color: rgba(0,0,0,0) !important;
    margin-top: 0px !important;
    margin-bottom: -1px !important;
    
    /* transition: height 0.5s 1s, opacity 0.2s 1.3s, font-color 0.5s 1s, margin 0.5s 1s !important; */
    transition-delay: 2s !important;
    transition: all 1s !important;
}

</style>


<div id="contextmenu" onblur="self.classList.remove('visible')"></div>

<script>

function closeContextMenu(){

    mylog()

    $$(".contextMenu").forEach(menu => {menu.remove()})
    contextMenuIsOpen = false
    
    mylog("exiting")
}

function omitScene(){

    mylog()

    let elements = $$('.isSelected')

        if(documentSetting.scenesAreProportional){
            for(element of elements){
                //element.classList.add("dimmedScene")
                element.classList.add("shrinkingWhenOmitting")
            }
        }

    let elementsToOmit = []
    var sectionfound = false

        for (i = elements.length - 1; i > -1; i--) {
            if ([...elements[i].classList].includes("section")){
                sectionfound = true
                continue
            }
            if (![...elements[i].classList].includes("isOmitted")){
            elementsToOmit.push(elements[i].id)
            }
        }

    if (sectionfound){
        Beat.call(`Beat.alert('Ignoring section(s) when omitting', 'The range you selected to omit contains one or more SECTIONS.\\n\\nSince they already do not print with the script, omitting (essentially: "hiding")\\na section will only add an extra pair of omission marks without any other actual meaning.\\n\\nYou can go ahead and add them manually if you really want to (Beat will not protest) but all your sections will be visible in FTOutliner whether omitted or not.')`)
    }

    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    Beat.call("Beat.custom.omitScene(" + documentSetting.scenesAreProportional + ", [" + [...elementsToOmit] + "])")
    deselectAllElements()
}

function unOmitScene(){

    mylog()

    // Beat.call("Beat.onTextChangeDisabled = true")
    // Beat.call("Beat.onOutlineChangeDisabled = true")
	// Beat.call("Beat.onSelectionChangeDisabled = true")

    elements = $$('.isSelected')
    let elementsToUnOmit = []

        for (i = elements.length - 1; i > -1; i--) {
            if (elements[i].classList.contains("isOmitted")){
            elementsToUnOmit.push(elements[i].id)
            }
        }

    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    Beat.call("Beat.custom.unOmitScene([" + [...elementsToUnOmit] + "])")
    deselectAllElements()
}

function deleteScene(){

    //TODO: rewrite this locally!

    mylog()

    elements = $$('.isSelected')
    if (elements.length == 0) return

        for(element of elements){
            element.classList.add("toBeDeleted")
        }

    let elementsToDelete = []

        for (i = elements.length - 1; i > -1; i--) {
            elementsToDelete.push(elements[i].id)
        }
        
    if (elements[0].classList.contains("synopsis")){
        for (e of elementsToDelete) {
            elementsToDelete[elementsToDelete.indexOf(e)] = JSON.stringify(e)
        }
        let doThis = `Beat.custom.deleteSynopsis([${[...elementsToDelete]}], ${userDefault.warningsAreOn})`
        Beat.call(doThis)
    }else if (elements[0].classList.contains("section")){
        Beat.call("Beat.custom.deleteSection([" + [...elementsToDelete] + "], " + userDefault.warningsAreOn + ")")
    }else{
        Beat.call("Beat.custom.deleteScene([" + [...elementsToDelete] + "], " + userDefault.warningsAreOn + ")")
    }
    deselectAllElements()
    mylog("exiting")
}

function ifYesToDelete(){ //this is visually-related stuff only and does not alter any actual data 

    mylog("YES TO DELETE: Now shrinking the scenes.")

    let selectedScenes = document.querySelectorAll('.toBeDeleted')

    mylog("this many: " + selectedScenes.length)

    for (scene of selectedScenes){

        scene.classList.add("longerAnimation")

        let redraw = scene.getBoundingClientRect()

        scene.style.opacity = "1"
        scene.style.height = "0px"
        scene.style.minHeight = "0px"

        let syncons = scene.querySelectorAll(".synopsis, .synopsiscontainer") || false

        if (syncons.length > 0){
            for (syncon of syncons){
            syncon.style.scale = "0px 0px"
            syncon.style.height = "0px"
            syncon.style.minHeight = "0px"
            }
        }
    }    
}

function undimAllScenes(){

    mylog()

    actualChangesToScriptInProgress = false //this is for the errorhandler to know what was happening
    
    $$(".toBeDeleted").forEach(element => {element.classList.remove("toBeDeleted")})
    $$('.dimmedScene').forEach(item => item.classList.remove('dimmedScene'))

}

function copyContentsToClipboard(){

    mylog()

    let selectedElements = $$('.isSelected')

    let ranges = []

    for (let element of selectedElements){
        let obj = {}
        obj.start = outline[element.id].sceneStart 
        obj.end = outline[element.id].sceneEnd
        ranges.push(obj)        
    }
    
    Beat.call("Beat.custom.copyRangeToClipboard('" + JSON.stringify(ranges) + "')")


}

</script>
<script>

//This file contains the keyboard shortcuts for the app
//Shortcuts are defined below the keypress function
// BUT NOTE that any shortcut inside a menu will be added to the shortcut array too

function keypress(event){

    if(event.altKey) altIsBeingPressed = true
    
    const shortcut = shortcutKeys.find((shortcut) => {

        // Check if all the modifier keys are pressed
        const modifiersMatch =
            (shortcut.key.includes("Meta") === event.metaKey) &&
            (shortcut.key.includes("Control") === event.ctrlKey) &&
            (shortcut.key.includes("Alt") === event.altKey) &&
            (shortcut.key.includes("Shift") === event.shiftKey);

        // Check if the main key matches
        const keyMatch = shortcut.key.at(-1) == event.key;

        // Return true if both the modifier keys and main key match
        return modifiersMatch && keyMatch;
    })

    if (shortcut) {
        event.preventDefault()
        event.stopPropagation()
        shortcut.command(event);
    }

}

// Runtime code below:  

let shortcutKeys = [
    {
        key: ["Escape"],
        command: (event) => {escapeWasPressed(event)}
    },
    {
        key: ["Enter"],
        command: (event) => {
            if(errorHasFired){
                document.getElementById("errorClickButton").click()
			    return
            }
            let elements = Array.from($$(".section.isSelected, .section-heading.isSelected, .scene.isSelected, .synopsis.isSelected"))
		    let element = elements.at(-1)
		        if (element){
			        displayContextMenu(event, element)
		        }
        }
    },
    {
        key: ["Control", "Alt", "Meta","ä"],
        command: (event) => { Beat.call(`Beat.custom.reloadHTML()`) }
    },
    {
        key: ["Control", "Alt", "Meta","ö"],
        command: (event) => { forceRestart() }
    },
    
    // 1. LETTERS
    
    {
        key: ["Control", "a"],
        command: (event) => { selectAllElements(true) }
    },
    {
        key: ["Meta", "a"],
        command: (event) => { selectAllElements(false) }
    },
    {
        key: ["Meta", "b"],
        command: (event) => { addShowHideBoneyard() }
    },
    {
        key: ["b"],
        command: (event) => { toggleDisplayBeats() }
    },
    {
        key: ["Control", "c"],
        command: (event) => {		
            document.getElementById("flexiContainer").classList.toggle("greyonly")
		    if(userDefault.invertTextOnDark) reevaluateColorContrast()
		    setAllButtons()
		    updateDialogPanel()
        }
    },
    {
        key: ["c"],
        command: (event) => { toggleColorScheme() }
    },
    {
        key: ["Meta", "d"],
        command: (event) => { deselectAllElements(false) }
    },
    {
        key: ["d"],
        command: (event) => { expandOrCollapseSections() }
    },
    {
        key: ["Meta", "e"],
        command: (event) => { togglePrintMode(true) }
    },
    {
        key: ["e"],
        command: (event) => { anArrowWasClicked($(".arrowForIndexCards"), true) }
    },
    {
        key: ["f"],
        command: (event) => { toggleProportional() }
    },
    {
        key: ["h"],
        command: (event) => { outdoorMode() }
    },
    {
        key: ["Meta", "h"],
        command: (event) => { flexiContainer.classList.toggle("horizontal") }
    },
    {
        key: ["l"],
        command: (event) => { toggleShowSceneLength() }
    },
    {
        key: ["Meta", "Alt", "Control", "l"],
        command: (event) => { Beat.call(() => Beat.openConsole()) }
    },
    {
        key: ["m"],
        command: (event) => { toggleDisplayMarkers() }
    },
    {
        key: ["Control", "m"],
        command: (event) => { flexiContainer.classList.toggle("unShowMarkerText") }
    },
    {
        key: ["n"],
        command: (event) => {toggleDisplayNotes()}
    },
    {
        key: ["Meta", "n"],
        command: (event) => { return }
    },
    {
        key: ["o"],
        command: (event) => {toggleOneColumnOutline()}
    },
    {
        key: ["Control", "p"],
        command: (event) => {
            $id("buttonForPageDividers").click()
            setAllButtons()}
    },
    {
        key: ["Shift", "Meta", "p"],
        command: (event) => { newPrintBox() }
    },
    {
        key: ["Meta", "p"],
        command: (event) => { togglePrintMode() }
    },
    // {
    //     key: ["Meta", "Control", "Alt", "p"],
    //     command: (event) => { openPrintWindow() }
    // },
    {
        key: ["p"],
        command: (event) => { toggleShowPageNumbers() }
    },
    {
        key: ["q"],
        command: (event) => { makeWider(false, true, event.shiftKey) }
    },
    {
        key: ["r"],
        command: (event) => { toggleDisplayReviews() }
    },
    {
        key: ["s"],
        command: (event) => { toggleShowSceneNumbers() }
    },
    {
        key: ["Control", "s"],
        command: (event) => { toggleDocumentSetting("showMultipleSceneLines") }
    },
    {
        key: ["t"],
        command: (event) => { toggleTrackingContainer() }
    },
    {
        key: ["Control", "t"],
        command: (event) => { toggleDocumentSetting("showMultipleSectionLines") }
    },
    {
        key: ["Control", "u"],
        command: (event) => { toggleDocumentSetting("allowLowerCaseSections") }
    },
    {
        key: ["v"],
        command: (event) => { event.preventDefault(); $id('buttonForVerticals')?.click() }
    },
    {
        key: ["w"],
        command: (event) => { toggleWarnings() }
    },
    {
        key: ["Meta", "w"],
        command: (event) => { Beat.call("Beat.custom.reallyQuit(true)") }
    },
    {
        key: ["x"],
        command: (event) => { toggleIndexCardMode() }
    },
    {
        key: ["y"],
        command: (event) => { toggleDisplaySynopsis() }
    },
    {
        key: ["Control", "y"],
        command: (event) => { flexiContainer.classList.toggle("onlySynopsis") }
    },
    
    // 2. NON-LETTERS
    
    // {
    //     key: ["Shift", "!"],
    //     command: (event) => { throwError() }
    // },
    {
        key: ["Shift", "%"],
        command: (event) => { 
            documentSetting.colorByPercentage = !documentSetting.colorByPercentage
            firstRun()
        }
    },
    {
        key: ["Meta", ","],
        command: (event) => { openSettingsWindow() }
    },
    {
        key: ["Shift", "*"],
        command: (event) => { toggleShowRevisions() }
    },
    {
        key: ["*"],
        command: (event) => { toggleShowRevisions() }
    },
    {
        key: ["F1"],
        command: (event) => { cycleMenus() }
    },
    {
        key: ["Shift", "F1"],
        command: (event) => { cycleMenus(true) }
    },
    {
        key: ["?"],
        command: (event) => { toggleHelpContainer() }
    },
    {
        key: ["Shift", "?"],
        command: (event) => { toggleHelpContainer() }
    },
    {
        key: ["`"],
        command: (event) => { toggleNotepanel() }
    },
    {
        key: ["§"],
        command: (event) => { toggleNotepanel() }
    },
    {
        key: ["Shift", "§"],
        command: (event) => { toggleNotepanel() }
    },
    {
        key: ["Control", "§"],
        command: (event) => { cycleTabs() }
    },
    {
        key: ["Control", "`"],
        command: (event) => { cycleTabs() }
    },
    {
        key: ["Shift", "Control", "°"],
        command: (event) => { cycleTabs() }
    },
    {
        key: ["Shift", "Control", "±"],
        command: (event) => { cycleTabs() }
    },
    {
        key: ["Tab"],
        command: (event) => { cycleNotes(false) }
    },
    {
        key: ["Shift", "Tab"],
        command: (event) => { cycleNotes(true) }
    },
    {
        key: ["Control", "Tab"],
        command: (event) => { Beat.call("Beat.nextTab()") }
    },
    {
        key: ["Control", "Shift", "Tab"],
        command: (event) => { Beat.call("Beat.previousTab()") }
    },
    {
        key: ["ArrowUp"],
        command: (event) => {walkTheOutline(event)}
    },
    {
        key: ["Shift", "ArrowUp"],
        command: (event) => {walkTheOutline(event)}
    },
    {
        key: ["ArrowDown"],
        command: (event) => {walkTheOutline(event)}
    },
    {
        key: ["Shift", "ArrowDown"],
        command: (event) => {walkTheOutline(event)}
    },
    {
        key: ["ArrowLeft"],
        command: (event) => {walkTheOutlineSideWays(event)}
    },
    {
        key: ["Shift", "ArrowLeft"],
        command: (event) => {walkTheOutlineSideWays(event)}
    },
    {
        key: ["ArrowRight"],
        command: (event) => {walkTheOutlineSideWays(event)}
    },
    {
        key: ["Shift", "ArrowRight"],
        command: (event) => {walkTheOutlineSideWays(event)}
    },
    
    // 3. DIGITS

    {
        key: ["Meta", "+"],
        command: (event) => { zoomSizes("+") }
    },
    {
        key: ["Meta", "-"],
        command: (event) => { zoomSizes("-") }
    },
    {
        key: ["Meta", "0"],
        command: (event) => { zoomSizes("0") }
    },
    {
        key: ["Meta", "="],
        command: (event) => { zoomSizes("=") }
    },

    {
        key: ["Control", "+"],
        command: (event) => { changeIndexCardHeight("+") }
    },
    {
        key: ["Control", "-"],
        command: (event) => { changeIndexCardHeight("-") }
    },
    {
        key: ["Control", "0"],
        command: (event) => { changeIndexCardHeight("0") }
    },
    {
        key: ["Control", "="],
        command: (event) => { changeIndexCardHeight("=") }
    },

    {
        key: ["0"],
        command: (event) => { deselectAllCharacters() }
    },
    {
        key: ["1"],
        command: (event) => { toggleSoloCharacter("1") }
    },
    {
        key: ["2"],
        command: (event) => { toggleSoloCharacter("2") }
    },
    {
        key: ["3"],
        command: (event) => { toggleSoloCharacter("3") }
    },
    {
        key: ["4"],
        command: (event) => { toggleSoloCharacter("4") }
    },
    {
        key: ["5"],
        command: (event) => { toggleSoloCharacter("5") }
    },
    {
        key: ["6"],
        command: (event) => { toggleSoloCharacter("6") }
    },
    {
        key: ["7"],
        command: (event) => { toggleSoloCharacter("7") }
    },
    {
        key: ["8"],
        command: (event) => { toggleSoloCharacter("8") }
    },
    {
        key: ["9"],
        command: (event) => { toggleSoloCharacter("9") }
    },


]

//also add all shortcuts of contextmenu to global shortcutKeys variable
for (entry of contextMenuContents){

    if( !entry.shortcut ) continue
    shortcutKeys.push({
        key: entry.shortcut,
        command: //entry.command
            (function(command) {
                return function(event) {
                    command();
                }
            })(entry.command)
    })

}

</script><script>

function expandOrCollapseSections(){

	mylog()

	let trueOrFalse = !$(".section:not(.level1)")?.classList.contains("collapsedSection")
	
	$$(".section").forEach(section => {
		section.classList.toggle("collapsedSection", trueOrFalse)
	})

	$id("flexiContainer").scrollTo(0, 0)
	setButtonForExpandedSections()
	recalculateHeights() // in order to scroll back on screen if ending up outside

}

function anArrowWasClicked(theClickedThing, triggeredWithKey){

	mylog()

	if (!theClickedThing)return
	if (!documentSetting.indexCardMode && documentSetting.scenesAreProportional) return

	let closestSectionAbove = theClickedThing.closest(".section")

	if (theClickedThing.classList.contains("sectionArrow")){

		if(!event.altKey && !triggeredWithKey){
			closestSectionAbove.classList.toggle("collapsedSection")
		}else{

			let value = !closestSectionAbove.classList.contains("collapsedSection")
			let sections = $$(".section:not(.level1)")

			for (let section of sections){
				section.classList.toggle("collapsedSection", value)
			}
		}
		setAllButtons()
		rememberCardState()
		return
	}

	if(!event.altKey && !triggeredWithKey){	
			
		if([...closestSectionAbove.classList].includes("isExpanded")){
			closestSectionAbove.classList.remove("isExpanded")
			theClickedThing.classList.remove("expanded")
		}else{
			closestSectionAbove.classList.add("isExpanded")
			theClickedThing.classList.add("expanded")
		}
	}else{

		let doCollapse = closestSectionAbove.classList.contains("isExpanded")
			
		$$(".section").forEach(section => {
			section.classList.toggle("isExpanded", !doCollapse)
		})

		$$(".arrowForIndexCards").forEach(arrow => {
			arrow.classList.toggle("expanded", !doCollapse)
		})

		mylog("going to recalc now")
		$id("flexiContainer").scrollTo(0, 0)
		let timeToWait = doCollapse ? 0 : 300
		setTimeout(function(){
			recalculateHeights() // in order to scroll back on screen if ending up outside
		}, 300)
	}

	setAllButtons()
	rememberCardState()
}

function rememberCardState(){

	mylog()

	if(!outline || !$$(".section").length){
		return}

	cardState = []

	$$(".section").forEach(section => {
		let uuid = section.dataset.uuid
		cardState.push({
			uuid: uuid, 
			isExpanded: section.classList.contains("isExpanded"), 
			collapsedSection: section.classList.contains("collapsedSection")
		})
	})

}

var blurListener

function indexCardEditor(theElement, e){

	mylog()

	if($id("synEditBox"))return
	
	//position the cursor at the click first!
	let clickPosition = {}
		clickPosition.x = event?.pageX || e.pageX
		clickPosition.y = event?.pageY || e.pageY

	let synopsisContainer = theElement.closest(".synopsiscontainer")
		synopsisContainer.classList.remove("isSelected")
		synopsisContainer.parentElement.classList.remove("isSelected")
		synopsisContainer.classList.add("noHover")
		synopsisContainer.parentElement.classList.add("noHover")
	let theClickedId = theElement.id

	let scrollPosition = synopsisContainer.scrollTop

	//pass here: the containerObject with or without synopsis in it
	if(document.getElementById('editBox')) document.getElementById('editBox').remove()
    if(document.getElementById('youAreHere')) document.getElementById('youAreHere').remove()

	let synEditBox = document.createElement("div")
		synEditBox.id = "synEditBox"
	let attributes = window.getComputedStyle(synopsisContainer)
		if (attributes.backgroundColor == "rgba(0, 0, 0, 0)") attributes = window.getComputedStyle(synopsisContainer.closest(".scene, .section"))
					
	let measures = synopsisContainer.getBoundingClientRect()
		synEditBox.classList.add("synopsiscontainer")
		// synEditBox.classList.add("noHover")
		// synEditBox.classList.remove("isSelected")
		synEditBox.style.backgroundColor = attributes.backgroundColor
		synEditBox.style.backgroundImage = "none"
		synEditBox.style.color = "black"
		synEditBox.style.border = attributes.border
			if(documentSetting.indexCardMode) synEditBox.style.position = "absolute"
			if(!documentSetting.scenesAreProportional) synEditBox.style.position = "relative"
		synEditBox.style.top = 0 + "px"
		synEditBox.style.left = 0 + "px"
			if(documentSetting.indexCardMode 
					&& !synopsisContainer.closest(".scene, .section").classList.contains("level1")
					&& !synopsisContainer.closest(".scene, .section").classList.contains("special")){
				synEditBox.style.height = measures.height + "px"
			}else{
				synEditBox.style.height = "auto"
			}
		synEditBox.style.width = measures.width + "px"
		synEditBox.style.whiteSpace = "normal"
		synEditBox.style.overflowY = "auto"
		synEditBox.style.zIndex = "9999"

		synEditBox.contentEditable = true
		synEditBox.draggable = false

		
		let allCurrentSynopsis = synopsisContainer.querySelectorAll(".synopsis")
		for (synopse of allCurrentSynopsis){
			
			let synDiv = document.createElement("div")
				synDiv.id = synopse.id
				synDiv.dataset.theId = synopse.id
				synDiv.classList = synopse.classList
				synDiv.classList.remove("isSelected")
				synDiv.classList.add("clickThru")
				synDiv.dataset.classes = synDiv.classList
				synDiv.draggable = false
				synDiv.innerHTML = synopse.innerHTML
					if(synDiv.innerHTML == "")synDiv.innerHTML = " " //hack to avoid crash when synopsis is ony =[[note]]
				synDiv.dataset.beforeEdit = synopse.innerHTML
				synDiv.style.color = synopse.style.color
				synDiv.style.setProperty("--localSynopsisColor", getComputedStyle(synopse).getPropertyValue("--localSynopsisColor"))
				synDiv.style.opacity = "1"

			synEditBox.appendChild(synDiv)

		}

		if (allCurrentSynopsis.length == 0){

			let synDiv = document.createElement("div")
				synDiv.id = synopsisContainer.closest(".scene, .section").id + "_0"
				synDiv.classList.add("synopsis")
				synDiv.classList.add("clickThru")
				synDiv.dataset.classes = ""
				synDiv.innerHTML = " <br/>"
				synDiv.dataset.beforeEdit = ""

			synEditBox.appendChild(synDiv)
		}


	// synopsisContainer.appendChild(synEditBox)
	synopsisContainer.insertAdjacentElement("afterbegin", synEditBox)

	blurListener = new AbortController()

	addConfirmButtons(synopsisContainer, blurListener)
	
	$id("synEditBox").focus()
	$id("synEditBox").addEventListener("blur", function(){
		exitFromIndexCardEditor(true)},
		{ signal: blurListener.signal }
		)
	$id("synEditBox").addEventListener("paste", function(e){
		
		e.preventDefault()
		let text = (e.originalEvent || e).clipboardData.getData('text/plain'); //pastes manually
		let sel = window.getSelection()
		let range = sel.getRangeAt(0)

		if(!range.collapsed){
			range.deleteContents()
			fixContentEditableWeirdness()

			if (sel.anchorNode != sel.focusNode){
				//This is a fix for when entire div (or span across several) is selected!
				let node = document.createElement("div")
					node.classList.add("synopsis")
					node.classList.add("clickThru")
					node.dataset.beforeEdit = ""
					node.innerHTML = " "
				range.insertNode(node)
				range.setStart(node, 1)
				range.setEnd(node, 1)
			}
			range.collapse(false)
		}
		let node = document.createTextNode(text)
		range.insertNode(node)
		range.collapse(false)
		},
		{signal: blurListener.signal}
		)

	synEditBox.classList.add("noHover")
	let allSelected = $$(".isSelected")
	for (selected of allSelected) selected.classList.remove("isSelected")


	weAreCurrentlyEditingText = true
	let allDraggables = $$("[draggable=true]")
	for (draggable of allDraggables) {
		draggable.draggable = false
		draggable.classList.add("usedToBeDraggable")
	}
	
    // document.removeEventListener("keydown", checkWhatKeyGotPressed)
	toggleCaptureKeypresses(false)
    document.addEventListener('keydown', synEditBoxListen)
    document.addEventListener('selectionchange', fixContentEditableWeirdness)

	synEditBox.scrollTop = scrollPosition
	//clickPosition.y += scrollPosition

	//finally position 
	setInitialCaretPosition(theElement, clickPosition)
    
}

function addConfirmButtons(synopsisContainer, blurListener){

	mylog()

	let boxPos = synopsisContainer.getBoundingClientRect()
	let boxScroll = flexiContainer.scrollTop

	removeConfirmButtons()
	
	let cancelButton = document.createElement("div")
		cancelButton.id = "cancelButton"
		cancelButton.style.position = "absolute"
		cancelButton.style.left = boxPos.x - flexiContainer.getBoundingClientRect().left - 10 + "px"
		cancelButton.style.top = boxPos.y + boxScroll + boxPos.height - 10 + "px"
		cancelButton.classList.add("confirmButtons")
		cancelButton.innerHTML = "×"
		cancelButton.style.color = "#F33"
		
		flexiContainer.appendChild(cancelButton)
		
		let okButton = document.createElement("div")
			okButton.id = "okButton"
			okButton.style.position = "absolute"
			okButton.style.left = boxPos.x - flexiContainer.getBoundingClientRect().left - 10 + boxPos.width + "px"
			okButton.style.top = boxPos.y + boxScroll + boxPos.height - 10 + "px"
			okButton.classList.add("confirmButtons")
			okButton.innerHTML = "OK"

	flexiContainer.appendChild(okButton)

	editBoxResizeObserver = new ResizeObserver(entries => {
            for (entry of entries){
				boxPos = entry.target.getBoundingClientRect()
				boxScroll = flexiContainer.scrollTop
                okButton.style.top = boxPos.top + boxPos.height + boxScroll - 10 + "px"
                cancelButton.style.top = boxPos.top + boxPos.height + boxScroll - 10 + "px"
            }
        })
        editBoxResizeObserver.observe($("#synEditBox"))

	okButton.addEventListener("mousedown", okButtonCode, true)
	cancelButton.addEventListener("mousedown", cancelButtonCode, true)
	
}

function okButtonCode(){
	blurListener.abort();
	event.stopImmediatePropagation()
	exitFromIndexCardEditor(true)
}

function cancelButtonCode(){
	blurListener.abort();
	event.stopImmediatePropagation()
	exitFromIndexCardEditor(false)
}

function removeConfirmButtons(){

	editBoxResizeObserver?.disconnect()

	$id("okButton")?.removeEventListener("mousedown", okButtonCode, true)
	$id("cancelButton")?.removeEventListener("mousedown", cancelButtonCode, true)

	$id("cancelButton")?.remove()
	$id("okButton")?.remove()

}

function fixContentEditableWeirdness(){

	mylog()

	//1. FIX (-ish) for the caret falling outside of allowed divs when deleting all contents on a line

	let sel = window.getSelection()

	if (sel.anchorNode == $id("synEditBox")) {
		brs = synEditBox.getElementsByTagName("br");
		for (br of brs) br.parentNode.removeChild(br)

		range = sel.getRangeAt(0)
		newNode = document.createElement("div");
		newNode.id = ""
		newNode.classList.add("synopsis")
		newNode.classList.add("clickThru")
		newNode.innerHTML = " <br>"
		range.insertNode(newNode)

		let range2 = document.createRange();
			range2.setStart(newNode, 0);
			range2.collapse(false);
		sel.removeAllRanges();
		sel.addRange(range);

	}

	//2. FIX (I hope) for taking a colorclass distributed when hitting ENTER, and storing it in dataset until parsing time

	if (sel.anchorOffset == 0){
		let classes = new Set(Array.from(sel.anchorNode?.classList || sel.anchorNode?.parentElement?.classList || ""))
			classes.delete("synopsis")
			classes.delete("clickThru")
		let colClass = Array.from(classes.values())
			if(colClass.length > 0){
				let col = colClass[0].charAt(0).toUpperCase() + colClass[0].slice(1)
				if (sel.anchorNode.tagName == "DIV") {
					sel.anchorNode.dataset.color = col
				}else{
					sel.anchorNode.parentElement.dataset.color = col
				}
			}
	}

	//3. FIX for removing color-inside color when backspacing into a colored synopsis

	if (spans = synEditBox.querySelectorAll("span")){

		for (span of spans){

			let parentDiv = span.parentElement
			let range = document.createRange()
				range.selectNodeContents(parentDiv)

				text = document.createTextNode(range.cloneContents().textContent)
			
			let curpos = sel.anchorOffset
				range.deleteContents()
				range.insertNode(text)
			let curnode = sel.anchorNode
				range.setEnd(parentDiv.childNodes[0], curpos)
				range.collapse(false)

			sel.removeAllRanges();
			sel.addRange(range);

		}
	}
}

function synEditBoxListen(event){

	mylog()

	//NOTE: must catch ENTER, and add own new div -- or else .id will be repeated. Stupid contenteditable!
	//This is now done by checking for re-apperaing id:s when parsing result instead

	event.stopImmediatePropagation()

    if (event.key == "Escape"){event.preventDefault(); exitFromIndexCardEditor(false); return}
    if (event.key == "Enter" && event.metaKey){event.preventDefault(); exitFromIndexCardEditor(true); return}
    
	if (event.key == "z" && event.metaKey && !event.shiftKey){event.preventDefault(); document.execCommand("undo", false); return}
	if (event.key == "z" && event.metaKey && event.shiftKey){event.preventDefault(); document.execCommand("redo", false); return}

	if (["b", "u", "i", "k"].includes(event.key) && event.metaKey){event.preventDefault(); return}
    	
}

function exitFromIndexCardEditor(confirmed){

	mylog()

	if(event.relatedTarget?.classList.contains("confirmButtons"))return

	if ($$(".synopsiscontainer:has(#synEditBox) > .synopsis") == $$("#synEditBox > .synopsis")) confirmed = false


	// $id("synEditBox").removeEventListener("blur", function(){exitFromIndexCardEditor(true)})
	// the above should be handled by the AbortController
	document.removeEventListener('keydown', synEditBoxListen)
	document.removeEventListener('selectionchange', fixContentEditableWeirdness)

	toggleCaptureKeypresses(true)
	removeConfirmButtons()

	let allDraggables = $$(".usedToBeDraggable")
	for (draggable of allDraggables) {
		draggable.draggable = true
		draggable.classList.remove("usedToBeDraggable")
	}
	
	coverContainer.classList.remove("lessBlur")
    coverContainer.style.display = "none"
	
	if(confirmed){
		$id("synEditBox").classList.add("wait")
		let runUpdate = parseIndexCardPostEditing()
			if(runUpdate){
				firstRun() //to make sure the outline updates, since synopsis won't trigger updates by itself
			}
	}else{
		$id("synEditBox").remove()
	}

	weAreCurrentlyEditingText = false
}

function compareArrays(initial, changed) {

	mylog()

  	let result = [];

  	let initialIds = initial.map(function(item) {
    	return item.id;
  	});
  	let changedIds = changed.map(function(item) {
    	return item.id;
  	});


  	let deletedIds = initialIds.filter(function(id) {
    	return changedIds.indexOf(id) === -1;
  	});
  	let addedIds = changedIds.filter(function(id) {
    	return initialIds.indexOf(id) === -1;
  	});
	  let changedItems = initialIds.filter(function(id) {
    	return changedIds.indexOf(id) !== -1 && (changed[changedIds.indexOf(id)].innerText !== initial[initialIds.indexOf(id)].innerText);
  	});
  	let unchangedIds = initialIds.filter(function(id) {
    	return changedIds.indexOf(id) !== -1 && (changed[changedIds.indexOf(id)].innerText === initial[initialIds.indexOf(id)].innerText);
  	});

  	initial.forEach(function(item) {
    	if (deletedIds.indexOf(item.id) !== -1) {
      		item.dataset.result = 'deleted';
      		result.push(item);
    	} else if (unchangedIds.indexOf(item.id) !== -1) {
      		item.dataset.result = 'unchanged';
      		result.push(item);
    	} else if (changedItems.indexOf(item.id) !== -1) {
			item.dataset.result = 'changed';
			item.dataset.changeTo = changed[changedIds.indexOf(item.id)].innerText
			//if(col = window.getComputedStyle(item).backgroundColor) item.dataset.color = col
			result.push(item)
		}
  	});

	changed.forEach(function(item) {
    	if (addedIds.indexOf(item.id) !== -1) {
      		item.dataset.result = 'added';
			//if(col = window.getComputedStyle(item).backgroundColor) item.dataset.color = col
      		result.push(item);
    	}
  	});

  	return result;
}

function parseIndexCardPostEditing(){

	mylog()

	disableUpdating()

	
	let preEditDivs = Array.from($$(".synopsiscontainer:has(#synEditBox) > .synopsis"))
	let postEditDivs = Array.from($$("#synEditBox > .synopsis"))
	let resultDivs = []

	let previousIds = []

	for (post of postEditDivs){

		// if(post.innerText.trim() == ""){}
		if (post.id == "") post.id = previousIds[previousIds.length - 1] || "0"

		while (previousIds.indexOf(post.id) > -1) post.id += ".1"
		previousIds.push(post.id)
	}

	resultDivs = compareArrays(preEditDivs, postEditDivs)
		let changesWasMade = false
			for (let resultDiv of resultDivs){
				if (resultDiv.dataset.result != "unchanged") changesWasMade = true
			}

	if(!changesWasMade){
		synEditBox.remove()
		return false
	}

	resultDivs.sort((a,b) => (a.id > b.id) ? 1 : ((b.id > a.id) ? -1 : 0))

		//Now time to loop the result array BACKWARDS (so that INDEX/POSITIONS remains true) and take the decided actions
		resultDivs = resultDivs.reverse()
		let insertionPoint = Array.from($$(".synopsiscontainer:has(#synEditBox) > .synopsis"))?.at(-1)?.dataset.lineEnd || $(".synopsiscontainer:has(#synEditBox)").closest(".scene, .section").dataset.lineEnd
		
		for (result of resultDivs){

			if (result.dataset.result == "added" && result.innerText.trim() != ""){
				
				let colorstring = ""
					if (result.dataset.color) colorstring += " [[color " + result.dataset.color + "]]"

				let string = "`= " + result.innerText + colorstring+ "\n`"
				let doThis = `Beat.addString(${string}, ${insertionPoint})`.replaceAll("\n", "\\n")
					Beat.call(doThis)
			}

			if(result.dataset.result == "deleted"){
				
				insertionPoint = result.dataset.line
				let endPoint = result.dataset.lineEnd - insertionPoint
				let string = "`\n`"
				let doThis = `Beat.replaceRange(${insertionPoint}, ${endPoint}, ${string})`.replaceAll("\n", "\\n")
					Beat.call(doThis)
			}

			if(result.dataset.result == "changed"){

				let colorstring = ""
					if (result.dataset.color) colorstring += " [[color " + result.dataset.color + "]]"

				insertionPoint = result.dataset.line
				let endPoint = result.dataset.lineEnd - insertionPoint
				let string = `"\n"`
					if (result.dataset.changeTo.trim() > "") string = "`= " + result.dataset.changeTo + colorstring + "\n`"
				let doThis = `Beat.replaceRange(${insertionPoint}, ${endPoint}, ${string})`.replaceAll("\n", "\\n")
					Beat.call(doThis)

			}

			if(result.dataset.result == "unchanged"){
				insertionPoint = result.dataset.line
				//but do nothing
			}
		}

	return true

}

function setInitialCaretPosition(div, clickPosition) {

	mylog()

	const range = document.createRange();
	
	let child
	for (child of synEditBox.children){

		bottomY = child.getBoundingClientRect().top + child.getBoundingClientRect().height
		
		if (bottomY > clickPosition.y){
			break
		}
	}	
	//so now we know what synopsis to dig deeper into

	let pos
	let prevxpos = child.getBoundingClientRect().left // 0
	let prevypos = child.getBoundingClientRect().top // 0
	for (pos = 0; pos < child.childNodes[0].length + 1; pos++) {
		range.setStart(child.childNodes[0], 0)
		range.setEnd(child.childNodes[0], pos)
		let text = range.toString()
		range.collapse(false)
		
		xpos = range.getBoundingClientRect().right
		ypos = range.getBoundingClientRect().bottom
		if (ypos > prevypos && text.charCodeAt(text.length-1) == 32)continue //disregard line end or else it will stop there.

		if (prevypos > clickPosition.y && ypos > prevypos){ 
			//litteraly means we are on the NEXT line, AFTER the one we clicked
			//implicitly means we clicked to the right of the last character on a line
			range.setEnd(child.childNodes[0], Math.max(0, pos - 2))
			break
		}
		
		if (xpos > clickPosition.x && ypos > clickPosition.y){
			//means we've found the spot
			if(prevxpos + ((xpos-prevxpos) / 2) > clickPosition.x){
				range.setEnd(child.childNodes[0], Math.max(0, pos - 1))
			}
			break
		}
		prevxpos = xpos
		prevypos = ypos
	}

	range.collapse(false)

	let sel = window.getSelection();
		sel.removeAllRanges();
  		sel.addRange(range);

  	return
}

function enableUpdating(){

	return

// Beat.call(`
// 	Beat.onTextChangeDisabled = false
// 	Beat.onOutlineChangeDisabled = false
// 	Beat.onSelectionChangeDisabled = false
// 	`)

}

function disableUpdating(){

	return

// Beat.call(`
// Beat.onTextChangeDisabled = true
// Beat.onOutlineChangeDisabled = true
// Beat.onSelectionChangeDisabled = true
// `)

}

</script>

<style>

#synEditBox{

	scroll-behavior: auto !important;
	
}

#flexiContainer:not(.indexcards) #synEditBox .synopsis{

	color: white

}

.synopsiscontainer:has(#synEditBox) {

	pointer-events: none;

}

.synopsiscontainer:has(#synEditBox) > .synopsis{

	opacity: 0;
	display: none;

}

/*new behavior for act and special with hidden synopsiscontainer 1 of 2*/
.indexcards .level1 > .synopsiscontainer:not(:has(.synopsis)):not(:hover),
.indexcards .special > .synopsiscontainer:not(:has(.synopsis)):not(:hover),
.showSynopsisInScenes:not(.indexcards) .section > .synopsiscontainer:not(:has(.synopsis)):not(:hover){

	border: none !important;

	min-height: 0px !important;
	height: 0px !important;
	margin: 0px !important;
	padding: 0px !important;
	top: 0px !important;
	margin-top: -2px; 

}

.showSynopsisInScenes:not(.indexcards) .section:not(:has( .synopsis)) > .section-heading{

	margin-bottom: 0 !important;

}

.indexcards .section:is(.level1, .special) > #synEditBox,
.indexcards .section:is(.level1, .special) > .synopsiscontainer:has(#synEditBox) {

	height: auto !important;
	max-height: 100% !important;
	min-height: calc(14px * var(--fontSizeFactor)) !important;

	box-shadow: 0 0 0 3px black;

}

/* .showSynopsisInScenes:not(.indexcards) #synEditBox, */
.showSynopsisInScenes:not(.indexcards) .scene .synopsiscontainer:has(#synEditBox) {

	/* height: 100% !important; */
	height: auto !important;
	max-height: 100% !important;
	min-height: calc(14px * var(--fontSizeFactor)) !important;

	border-left: 4px solid black;
	border-right: 4px solid black;
	border-bottom: 1px solid black;
	box-shadow: inset 0 -3px 0 0 black;

}

.showSynopsisInScenes:not(.indexcards) .section > .synopsiscontainer:has(#synEditBox) {

	height: auto !important;
	max-height: 100% !important;
	min-height: calc(14px * var(--fontSizeFactor)) !important;

	box-shadow: inset 0 -4px 0 0 black, -3px 0 0 0 black, 3px 0 0 0 black, inset 1px 0 0 0 black, inset -1px 0 0 0 black !important;

}

.showSynopsisInScenes:not(.indexcards) .scene:has(#synEditBox) > .sceneheading{

	border: 4px solid black;
	border-bottom: 1px;

	padding-top: 0px !important;

	top: -10px !important;
	opacity: 1 !important;
	border-radius: 3px 3px 0px 0px;
	background-image: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.3));

}

.indexcards .section:is(.level1, .special):has(#synEditBox) > .section-heading,
.indexcards .section:is(.level1, .special) > #synEditBox,
.indexcards .section:is(.level1, .special) > .synopsiscontainer:has(#synEditBox){

	box-shadow: none !important;
	color: inherit !important;
}

.showSynopsisInScenes:not(.indexcards) .section:has( > .synopsiscontainer > #synEditBox) > .section-heading{

	background: black !important;
	color: white !important;

	box-shadow: 0 0 0 3px black;
}

/* .showSynopsisInScenes:not(.indexcards) .synopsiscontainer:has(#synEditBox)::before{

	opacity: 1;

} */

/*adding when dragging! */

#flexiContainer.drag:is(.indexcards, .nonProportionalMode):has(#ghost > .synopsis) .synopsiscontainer,

/*new behavior for act and special with hidden synopsiscontainer 2 of 2*/
.indexcards:not(:has(.editBox,#synEditBox)) .section:is(.level1, .special:has( > .synopsiscontainer:empty)):has( > .section-heading:hover) > .synopsiscontainer,
.indexcards:not(:has(.editBox,#synEditBox)) .section:is(.level1, .special:has( > .synopsiscontainer:empty)) > .synopsiscontainer:empty:hover,
.showSynopsisInScenes:not(.indexcards, :has(.editBox,#synEditBox)) .section:has( > .section-heading:hover) > .synopsiscontainer,
.showSynopsisInScenes:not(.indexcards, :has(.editBox,#synEditBox)) .scene:hover > .synopsiscontainer,
.showSynopsisInScenes:not(.indexcards, :has(.editBox,#synEditBox)) .synopsiscontainer:hover {

	min-height: calc(14px * var(--fontSizeFactor)) !important;
	transition: min-height 0.2s !important;

}

#flexiContainer.drag:is(.indexcards, .nonProportionalMode):has(#ghost > .synopsis) .synopsiscontainer:has(.synopsis){

	padding-bottom: calc(14px * var(--fontSizeFactor)) !important;
	transition: padding-bottom 0.2s !important;

}
/* #flexiContainer.drag:is(.indexcards, .nonProportionalMode):has(#ghost > .scene) .scene{

	margin-bottom: calc(14px * var(--fontSizeFactor)) !important;
	transition: margin-bottom 0.2s !important;

} */

/*new behavior for act and special with hidden synopsiscontainer 2 of 2*/
.indexcards:not(:has(.editBox, #synEditBox)) .section:is(.level1, .special:has( > .synopsiscontainer:empty)):has( > .section-heading:hover) > .synopsiscontainer:empty::after,
.indexcards:not(:has(.editBox, #synEditBox)) .section:is(.level1, .special:has( > .synopsiscontainer:empty)) > .synopsiscontainer:empty:hover::after,
.nonProportionalMode.showSynopsisInScenes:not(.indexcards, :has(.editBox, #synEditBox)) .section:has( > .section-heading:hover) > .synopsiscontainer:empty::after,
.nonProportionalMode.showSynopsisInScenes:not(.indexcards, :has(.editBox, #synEditBox)) .scene:hover > .synopsiscontainer:empty::after,
.nonProportionalMode.showSynopsisInScenes:not(.indexcards, :has(.editBox, #synEditBox)) .synopsiscontainer:empty:hover::after {

	content: "double click to add synopsis";
	text-align: center;
	font-size: calc(8px * var(--fontSizeFactor));
	font-weight: normal;
	font-style: normal;
	
	opacity: 0.6;
	
	position: absolute;
	height: calc(8px * var(--fontSizeFactor));
	top: calc(0px * var(--fontSizeFactor));
	left: 0;
	width: 100%;

	transition-delay: 0.5s;
	transition-property: min-height height;

}


.indexcards .level1:not(:has( > .section-heading:hover)) > .synopsiscontainer,
.indexcards .special:not(:has( > .section-heading:hover)) > .synopsiscontainer,
.showSynopsisInScenes:not(.indexcards) .section:not(:has( > .section-heading:hover)) > .synopsiscontainer,
.showSynopsisInScenes:not(.indexcards) .scene:not(:hover) > .synopsiscontainer {

	min-height: 0;
	/* transition-delay: min-height 0.2s; */
	transition: min-height 0.2s !important;

}


.indexcards .scene:has(#synEditBox){

	box-shadow: 0px 0px 0px 2px black/*,
				0px 0px 120px 120px rgba(0,0,0,0.4);*/
	;

	z-index: 990;

}

.indexcards .scene:has(#synEditBox)::before{

	/* display: none; */

}


#flexiContainer:has(#synEditBox) .scene:not(:has(#synEditBox)),
#flexiContainer:has(#synEditBox) .section:not(:has( > .synopsiscontainer > #synEditBox)) > .synopsiscontainer,
#flexiContainer:has(#synEditBox) .section:not(:has( > .synopsiscontainer > #synEditBox)) > .section-heading {

	opacity: 0.6;
	transition: 0.5s;

}

#flexiContainer:has(#synEditBox) .section:not(:has( > .synopsiscontainer > #synEditBox))::before {

	opacity: 0;
	border-width: 0;
	transition: 0.5s 

}


.indexcards .section:not(.level1):has( > .synopsiscontainer > #synEditBox) > .section-heading {

	z-index: 990;

	box-shadow: 0px 0px 0px 2px black;

	/* scale: 1.05 !important;
	translate: 0 5%;

	transition: 0.2s; */

}

.indexcards .section:not(.level1):has( > .synopsiscontainer > #synEditBox) > .synopsiscontainer {

	box-shadow: 0px 1px 0px 2px black;

}

.confirmButtons{

    margin: 0px !important;
    padding: 0px !important;

    position: absolute;

    border-radius: 50%;
    height: 20px !important;
    width: 20px !important;

    background: rgba(0,0,0,1);
    border: 2px white solid;
    color: white !important;

    text-align: center;
    font-size: 12px !important;
	line-height: 16px !important;
    font-weight: bold;
    font-style: normal;

    z-index: 9999;
    pointer-events: all !important;

    /* overflow:hidden; */

	box-shadow: 0px 0px 4px rgba(0,0,0,0.4);

    /* transform: translate(-110%, -110%); */

}

#okButton{

	font-size: 9px !important;

}

#okButton:hover{

	background: hsl(90, 100%, 25%);

}

#cancelButton:hover{

	background: hsl(0, 100%, 30%);

}

</style><style>

#_____INDEXCARDS_GENERAL{}

.indexcards .showActLength {
	display: none !important; 
}

.indexcards .special > .synopsiscontainer{
	transition: none !important;
}

.indexcards .level1 > .orphanText {
	height: auto !important;
	background: none !important;
}

.indexcards .level1.faux > .synopsiscontainer,
.indexcards .level1 > .orphanText > .synopsiscontainer{
	display: block !important;

	height: 100% !important; 
	max-height: 100% !important; 
	background: none !important;

	height: auto;
}


.indexcards .level1{

	/* box-sizing: content-box; */
		
	border-radius: 0px !important;
	margin-top: 0;
	margin-left: 0px !important;
	margin-right: 0px !important;

	padding: 0 10px 0 5px; 
	
	/* border: 1px red solid !important; */

	padding-right: 10px !important;
	padding-left: 10px !important;

	--localColor: var(--pageBackground);

}

.indexcards .level1:nth-of-type(even):not(.boneyard){

	padding: 0 10px var(--indexCardHeight) 0px; 
	padding-right: 10px !important;
	padding-left: 5px !important;
	margin-left: 0px !important;
	margin-right: 0px !important;


	margin-top: -18px;
	padding-top: 22px;

	border-left: 1px rgba(255,255,255,0.1) dotted !important;
	border-right: 1px rgba(255,255,255,0.1) dotted !important;
	/* outline: 1px rgba(255,255,255,0.2) solid; */
	
	background-image: linear-gradient(90deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.05) 100%) !important;
	
	background-position: static !important;

	height: var(--indexReferenceForHeight); 
	min-height: 120%;
	
}

.indexcards.oneColumnOutline .level1:nth-of-type(even){
	height: auto !important;
	padding: 5px 10px 0 5px !important; 
	min-height: unset;
	margin-top: unset;
	border-left: none !important;
	border-right: none !important;
	border-top: 2px rgba(255,255,255,0.3) dotted !important;
	border-bottom: 2px rgba(255,255,255,0.3) dotted !important;

}

.indexcards .level1:nth-of-type(even) > .noteContainer,
.indexcards .level1:nth-of-type(even) > .marker {
    margin-top: 20px !important;
}

#_____INDEXCARDS_ALL_OPEN{}

.indexcards .section {

	border: none;
	margin-top: 4px;
	text-align: left;

}

.indexcards.verticals .section:not(.level1)::before{

	content: "";

	position: absolute;
	top: 0px;
	left: -0px;
	height: calc(100%);
	width: 100%;

	border-left: 4px solid var(--localColor);
	border-radius: 5px !important;

	z-index: -99;
}

.greyonly.indexcards .section:not(.level1)::before{

	--localColor: #ccc;

}

html[data-outdoors='1'] .indexcards .section:not(.level1)::before{

	display: none

}

.indexcards .section:not(.level1):has(.scene):not(.isExpanded):not(:has(.scene ~ .section))::before{

	height: calc(100% - 20px);

}

.indexcards .section:not(.level1){

	white-space: normal !important;

}

.indexcards :not(.level1) > .section-heading {

	border-radius: 3px 3px 0px 0px;
	margin-bottom: 0px;
	background-image: linear-gradient(90deg, rgba(0, 0, 0, 0.2), rgba(0,0,0,0.2));
	border-bottom: black 1.5px double;

}

.indexcards .section-heading:hover,
.indexcards .section:has( > .synopsiscontainer:hover) > .section-heading{ 

	color: white !important;
	background-color: black;

}

.indexcards .level3 {

	margin-left: 15px;

}

.indexcards .level4 {

	margin-left: 15px;

}

.indexcards .level5 {

margin-left: 15px;

}

.indexcards .level6 {

margin-left: 40px;

}

.indexcards .scene {
	
	position: relative;

	/* height: var(--indexCardHeight) !important; */ /*changed to AUTO to accomodate multiple scene-heading lines*/
	height: auto !important;

	margin-top: 5px;
	margin-left: 20px;
	margin-right: 0px

}

.indexcards .isExpanded > .scene.isOmitted{

	margin-left: 20px !important;

}

.indexcards .orphanText {

	margin: 0;
	background: none;
	border-radius: 0 0 3px 3px;

	pointer-events: none;
	height: auto !important;

}

.indexcards .sceneheading {

	padding-bottom: calc(2px * var(--fontSizeFactor));
	border-bottom: 1px solid black;
	background: rgba(0, 0, 0, 0.2);
	border-radius: 3px 3px 0 0;

}

.indexcards .sceneheading {
	transition: font-size 0.1s, line-height 0.1s, height 0.1s
}

.indexcards .scene::before {

	content: " ";
	position: absolute;
	top: 0;
	left: -11px; /*10%*/
	border-left: 2px dotted rgba(255,255,255,0.4);
	border-bottom: 2px dotted rgba(255,255,255,0.4);
	width: 9px; /*15px*/
	height: calc(100% + 1px);
	transform: translateY(-50%);
	z-index: -11 !important;

	transition: none !important;

}

.indexcards #dropDiv + .scene::before {

	height: calc(100% + 1px + 40px);
	transform: translateY(calc(-50% - 20px));

}

.indexcards .scene:not(.scene + .scene)::before {

height: calc(50% + 3px);
transform: translateY(-3px);

}

/* .indexcards .synopsiscontainer:not(.level1 > .synopsiscontainer){ */
.indexcards .synopsiscontainer{

	display: block;
	
	position: relative; 
	margin: 0 0 0 0;
	padding-top: 1px;

	border-radius: 0 0 3px 3px;
	
	background-image: repeating-linear-gradient(180deg, transparent 0%, transparent calc(15px * var(--fontSizeFactor) - 1px), rgba(0,0,0,0.1) calc(15px * var(--fontSizeFactor) - 1px), rgba(0,0,0,0.1) calc(15px * var(--fontSizeFactor)));
	background-attachment: local;

	height: calc(var(--indexCardHeight) - calc(14px * var(--fontSizeFactor))); 
	min-height: calc(var(--indexCardHeight) - calc(14px * var(--fontSizeFactor))) /*!important*/; 
	width: 100%;
	overflow-x: hidden;
	overflow-y: scroll;

	pointer-events: all;

	transition:  min-height 0.2s, height 0.2s ;

}

.indexcards.widenedColumnsGetAutoHeight .wider .synopsiscontainer{

	height: auto !important;
	min-height: calc(var(--indexCardHeight) - calc(14px * var(--fontSizeFactor))) !important; 


}

.indexcards .scene{

	

	height: auto !important;

}

/* .indexcards:not(.greyonly):not(.uncolorAllScenesBut) .synopsis:not(.section.level1 > .synopsiscontainer .synopsis){ */
/* .indexcards:not(.greyonly):not(.uncolorAllScenesBut) div:not(:has(.dimmedScene)):not(:has(.dimmedSection)):not(:is(.level1)) > .synopsiscontainer .synopsis{ */
.indexcards:not(.greyonly, .uncolorAllScenesBut) :not(:has(.dimmedScene, .dimmedSection)) > .synopsiscontainer > .synopsis{

	box-shadow: 0 0 0 1px inset var(--localColor);

}

/*.indexcards .dimmedSection:not(.level1) > .synopsiscontainer,
.indexcards .dimmedSection:not(.level1) > .section-heading *,
.indexcards .dimmedSection:not(.level1) > .section-heading
{

	border: 1px solid rgba(255,255,255,0.3) !important;

	color: rgba(255,255,255,0.3) !important;
	background: none;
	box-shadow: none !important;

}

.indexcards .scene.dimmedScene{

	background: none;
	border: 1px solid rgba(255,255,255,0.3);
	box-shadow: none;

}

.indexcards .scene.dimmedScene > .synopsiscontainer .synopsis,
.indexcards .scene.dimmedScene > .synopsiscontainer,
.indexcards .scene.dimmedScene > .sceneheading,
.indexcards .dimmedSection > .synopsiscontainer .synopsis,
.indexcards .dimmedSection > .synopsiscontainer .synopsis::before
{

	color: rgba(255,255,255,0.3) !important;
	background: none;
	border: none !important;
	box-shadow: none !important;

}*/

.indexcards .level1 > .synopsiscontainer{

	height: auto !important;
	min-height: calc(14px * var(--fontSizeFactor)) !important;

}
    
.indexcards .section.special > .synopsiscontainer,
.indexcards .section.special > .orphanText,
.indexcards .section.special > .orphanText > .synopsiscontainer,
.indexcards .collapsedSection:not(.level1) > .synopsiscontainer,
.indexcards .collapsedSection:not(.level1) > .orphanText,
.indexcards .collapsedSection:not(.level1) > .orphanText > .synopsiscontainer {

	min-height: 0px !important;

}
    
/* .indexcards .isSelected > .synopsiscontainer:not(.level1 > .synopsiscontainer) > .synopsis:hover{

	background-image: linear-gradient(rgba(128,128,128,0.7),rgba(128,128,128,0.7)) !important;

} */
    
.indexcards .level1 > .orphanText,
.indexcards .level1 > .orphanText > .synopsiscontainer{

	background: none;
	min-height: 14px !important;

}

.indexcards .level1 > .orphanText:has( > .synopsiscontainer:empty){

	min-height: 0px !important;
	

}

.indexcards .special:not(.collapsedSection:not(.level1)) > .orphanText,
.indexcards .special:not(.collapsedSection:not(.level1)) > .orphanText > .synopsiscontainer,
.indexcards .special:not(.collapsedSection:not(.level1)) > .synopsiscontainer{

	height: auto;
	min-height: calc(14px * var(--fontSizeFactor)) !important;

}

.indexcards .section:not(.level1) > .synopsiscontainer{

	/* background-color: #bbb; */

}

.indexcards .scene:hover{

	background-image: yellow !important;

}

#_____INDEXCARDS_COLLAPSED{}
#_____1.SECTIONS{}


.indexcards .collapsedSection:not(.level1){

	padding: 0;
}

.indexcards .collapsedSection:not(.level1) > .section-heading{

	border-radius: 0;
	border-bottom: none;
	background-image: none;

}

.indexcards .collapsedSection:not(.level1) > .synopsiscontainer,
.indexcards .collapsedSection:not(.level1) > .orphanText > .synopsiscontainer,
.indexcards .collapsedSection:not(.level1) > .orphanText {

	height: 0px !important;
	min-height: 0px !important;
	padding: 0;
	opacity: 0;

}

#_____INDEXCARDS_COLLAPSED{}
#_____2.SCENES{}


.indexcards .section:not(.isExpanded){

	line-height: 11px !important;	

}

.indexcards .section:not(.isExpanded) > .scene,
.indexcards .section:not(.isExpanded) > .scene.isOmitted{

	position: relative;

	width: 8px !important;
	height: 8px !important;
	border-radius: 50%;

	display: inline-block;
	margin-left: 2px; 
	margin-right: 0px;

	margin-top: -30px !important; 
	margin-bottom: 0px !important;
	
	padding: 0px;
	line-height: 5px;

	transition: height 0s;

}

.indexcards .section:not(.isExpanded) > .scene:not(.scene + .scene){

	margin-left: 12px; 

}

.indexcards .section:not(.isExpanded) > .scene > *:not(.arrowForIndexCards){

	display: none;

}

.indexcards .section:not(.isExpanded) > .scene::before{	

	display: none;

}

#_____EXP_COL_ARROWS{}

.sectionArrow{

	display: none; 
	float: right;
	z-index: 9999;
	left: -10px;
	margin-left: 5px;
	margin-right: 5px;
	opacity: 0;

	
	margin-top: calc(4px * var(--fontSizeFactor));;
	height: calc(9px * var(--fontSizeFactor));
	width: calc(9px * var(--fontSizeFactor));
	border: calc(1.3px * var(--fontSizeFactor)) black solid; 
	border-top-width: calc(3.5px * var(--fontSizeFactor)); 
	border-radius: calc(2px * var(--fontSizeFactor)); 

}

.indexcards .sectionArrow{

	display: unset;

}

.indexcards .sectionArrow:hover,
.indexcards .section-heading:hover > .sectionArrow,
.indexcards .section:not(:has(.scene:hover)):hover > .section-heading > .sectionArrow{

	border-color: white;
	opacity: 0.8;

}

.indexcards .collapsedSection:not(.level1) > .section-heading > .sectionArrow{

	border-width: 3.5px 0 0 0 ; 
	border-radius: 0;

}

.arrowForIndexCards{

	display: none;

}

.indexcards .arrowForIndexCards {

	display: block;
	color: #888 !important;

}

.arrowForIndexCards::before{

	position: absolute;
	left: -13px;
	top: -1px;
	font-size: 12px !important; /*calc(12px * var(--fontSizeFactor)) !important; */
	line-height: 12px !important; 
	content: "\25BA";
	color: inherit !important;
	font-style: normal !important;

	transition: transform 0.2s !important;
	
}

.isExpanded > .scene > .arrowForIndexCards::before{
	content: "\25BA";
	transform: rotate(90deg) scale(1.1) !important;
	display: block !important;
	left: -24px !important; /*calc(-2px - 10%) !important;*/
	top: 0px  !important; /*was 11*/

	border: none !important
}

#_____CORRECTIONS{}

.indexcards .level1 > .synopsiscontainer{

	background-image: none;

}

DIABLED.indexcards .level1 > .synopsiscontainer > .synopsis {
	
	color: white; /* not important, because must be overridden by style attribute */
	
}

DISABLED.indexcards .level1 > .synopsiscontainer > .synopsis::before {

	color: white !important; /* important, because should NOT be overriden by style */

}

.indexcards .scene.isSelected {

	background-image: none !important;
	box-shadow: 0 0 0px 3px black;
	
}

.indexcards .section:not(.level1).isSelected > .section-heading,
.indexcards .section:not(.level1).isSelected > .synopsiscontainer {

	box-shadow: 0 0 0px 3px black;

}

.indexcards .scene.isSelected > .sceneheading {

	background-color: black !important;

}

</style><style>

:root{

    --note-panel-width: 200px /*25%; /*was 30*/
}

#notepanelOpener{

    position: absolute;
    top: 15px;
    left: 0px;
    height: calc(100vh - 65px);

    width: 10px;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;

    background: transparent;

    cursor: ew-resize !important ;

    z-index: 100;

    &::after{

        position: absolute;
        white-space: pre;
        top: 50%;
        left: -8.5px;
        /* width: 100%; */
        font-size: 8px;
        color: #444;
        
        content: "\25BC   \25BC   \25BC";
        opacity: 0;

        rotate: -90deg;
        transform-origin: 50% 50%;

        text-shadow: -0.5px 0px 0px white;

    }

    &:hover{

        border-radius: 0px 6px 6px 0px;
        background-color: rgba(255,255,255,0.3); /* #999; */
        
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
    
        box-shadow: 6px 0px 4px -4px rgba(0, 0, 0, 0.6);
	    height: calc(100vh - 65px);

        transition: background-color 0.2s;

        &::after{

            opacity: 1;
            transition: opacity 0.2s;

        }

    }

}

:has(#notepanel.expanded) #notepanelOpener{

    opacity: 0;
    z-index: 999999;
    /* box-shadow: none; */
    /* backdrop-filter: none; */
    /* -webkit-backdrop-filter: none; */
    border-right: 0.5px solid #999;
    border-top-right-radius: 0 !important;
    border-bottom-right-radius: 0 !important;

    &::after{
        /* color: #999; */
        rotate: 90deg;
        translate: -1.5px;
        /* text-shadow: -0.5px 0px 0px black; */

        transform-origin: 50% 50%;
    }

    &:hover{
        /* background-color: #555; */
        background-color: transparent;
        /* width: 30px; */
        /* background: linear-gradient(to right, #555, #555 20%, transparent 100%); */
        opacity: 1;
    }


}

#notepanel{

    position: absolute !important;
    top: 15px;
    left: calc(-1 * var(--note-panel-width));
	
	padding: 5px 10px 0px 10px  !important;
	margin: 0px !important; 

    height: calc(100% - 65px) /*!important*/;
    width: min(var(--note-panel-width), 90vw);
	
	font-size: calc(11px * var(--fontSizeFactor)); 
	font-weight: normal; 
	line-height: calc(13px * var(--fontSizeFactor)) !important; 
	
	border: none !important;
    
	border-radius: 0px 6px 6px 0px;
    /*background-color: rgba(128,146,164,0.5); /* #999; */
    background-color: rgba(255,255,255,0.3); /* #999; */
	

    z-index: 99999;
    overflow-y: auto;
    overflow-x: hidden;

    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);

    transition: flex-grow 0.2s, position 0.2s, transform 0.1s ease-out; 
	
}

#notepanelcontent, 
#dialogpanelcontent,
#scenespanelcontent {

    display: none;

    /* outline: 1px solid orange; */

    position: absolute;
    height: calc(100% - 46px);
    width: calc(100% - 5px);
    top: 46px;
    left: 5px;

    padding: 0 11px 0 0 !important;

    overflow-y: scroll;
    overflow-x: hidden;

    background: transparent !important;
}

#notepanel:has(.notetab.selectedtab) #notepanelcontent, 
#notepanel:has(.dialogtab.selectedtab) #dialogpanelcontent,
#notepanel:has(.scenestab.selectedtab) #scenespanelcontent {

    display: unset;

}

#notepanel #tabsRow{

    font-size: 11px !important;
    line-height: 17px !important;

    position: absolute;
    top: 0px;
    left: 0px;

    width: inherit;

    overflow: hidden;

}

#notepanel .tab{

    font-weight: bold;
    font-size: 11px !important;
    line-height: 17px !important;
    text-transform: uppercase;
    /* color: hsla(var(--paperBehindInk),0.7); */
    color: hsla(0, 0%, 100%, 0.7);

    position: relative;

    height: 18px;
    width: auto;
    display: inline-block;

    /* border: 1px solid black; */
    border-bottom: none;
    border-radius: 2px 10px 0 0;

    padding: 0px 8px;
    margin: 0 !important;

    /* box-shadow: inset -2px 2px 2px rgba(255,255,255,0.2); */
    box-shadow: 2px -2px 2px rgba(0,0,0,0.3);

}

#notepanel .tab.selectedtab{

    /* color: hsla(var(--paperBehindInk), 1); */
    color: hsla(0, 0%, 100%, 1);
    box-shadow: 0px -2px 2px 2px rgba(0,0,0,0.3);


}

#notepanel .tab:has(+ .selectedtab){

    box-shadow: none;

}

/* #notepanel .tab:not(:has(+ .tab))::after{ */
#notepanel .tab.selectedtab::after,
#notepanel .tab.selectedtab::before{

    content: "";
    position: absolute;

    width: 1000px;
    height: inherit;
    bottom: 0px;

    box-shadow: inset -2px -1px 2px rgba(0, 0, 0, 0.3),
                inset -40px -5px 5px rgba(0, 0, 0, 0.2);
    /* ,
                inset 0 0 20px rgba(0,0,0,0.3) */
                ;
    pointer-events: none;

}

#notepanel .tab.selectedtab::after{

    margin-left: 8px;

}
#notepanel .tab.selectedtab::before{

    translate: calc(-100% - 8px) 0;
    box-shadow: inset 2px -1px 2px rgba(0, 0, 0, 0.3),
                inset 0 0 20px rgba(0,0,0,0.3);

}

#notepanel .tab:hover{

    color: hsla(var(--paperBehindInk), 1);

}

#notepanel .closetab {

    font-weight: bold;
    font-size: 16px;
    float: right;
    padding-top: 0px;
    padding-right: 3px;

    color: hsla(var(--paperBehindInk),0.7);

}

#notepanel .closetab:hover {

    color: hsla(var(--paperBehindInk), 1);

}

#notepanel #notepanelbuttons,
#notepanel #scenespanelbuttons,
#notepanel #dialogpanelbuttons{

    display: none;

    font-size: 11px !important;
    line-height: 13px !important;

    position: absolute;
    width: calc(100% - 10px);
    top: 22px;
    left: 5px;

    /* outline: 1px solid hotpink */

}

#notepanel:has(.notetab.selectedtab) #notepanelbuttons,
#notepanel:has(.scenestab.selectedtab) #scenespanelbuttons,
#notepanel:has(.dialogtab.selectedtab) #dialogpanelbuttons{

    display: unset;

}

#dialogpanelbuttons #dialogsearch{

    float: right;
    width: 48%;
    margin-top: 1px;
    margin-bottom: 1px;
    margin-right: 6px;
    height: 18px;

    padding-left: 18px;

    outline: none !important;
    border: 0.5px solid #555 !important;
    border-radius: 3px;

    overflow: visible;

}

#dialogpanelbuttons #dialogsearch::placeholder{

    color: #555;
    font-style: italic;

}

#dialogpanelbuttons #dialogsearch:focus::placeholder{

    color: transparent;

}

#dialogpanelbuttons #dialogSearchIcon{

    position: absolute;
    text-align: left;
    width: 12px;
    top: 4px;
    right: calc(48% - 10px);
    fill: #555;
    line-height: 0px;
}

#dialogpanelbuttons #dialogsearch:placeholder-shown{

    background: #aaa !important;
    box-shadow: inset 0px 0px 0px 0px #555;

}

#dialogpanelbuttons #dialogsearch + #clearSearchButton{

content: "x";
text-align: center;
font-weight: bold;
font-size: 12.5px;
line-height: 13px;
background: #aaa;
color: white;
width: 14px;
height: 14px;
border-radius: 50%;

position: absolute;
top: 3px;
right: 8.5px;

}

#dialogpanelbuttons #dialogsearch + #clearSearchButton:hover{

    background: #333;

}


#dialogpanelbuttons #dialogsearch:placeholder-shown + #clearSearchButton{

    display: none;

}

#notepanel.expanded{
    /* transform: translateX(100%); */
    left: 0 !important;
}

#notepanel.expanded #drag-bar{

    /* position: fixed; */
    position: absolute;

    width: 10px;
    height: calc(100% - 20px);
    /* right: 0px; */
    /* left: calc(var(--note-panel-width) - 10px); */
    left: calc(min(var(--note-panel-width), 90vw) - 10px);

    bottom: 0px;

    /* margin-top: auto;
    margin-bottom: auto; */


    background: transparent;

    cursor: ew-resize !important ;

    z-index: 100;

}

#notepanel.expanded #drag-bar::before{

    content: ". . . . .";
    font-weight: bold;

    rotate: 90deg;
    translate: 3px 0;
    transform-origin: right center;


    position: absolute;
    top: 50%;
    right: 4px;

    color: hsla(var(--paperBehindInk),0.5);
    text-shadow: 0.5px -0.5px 1px rgba(0,0,0,1);

}

#notepanel.expanded #drag-bar:hover::before{

    color: hsla(var(--paperBehindInk),1);

    transition: color 0.5s;


}

#notepanelcontent ::-webkit-scrollbar:vertical,
#dialogpanelcontent ::-webkit-scrollbar:vertical{

    z-index: 9999;



}

#notepanel.expanded #drag-bar:hover{

    /* border-right: 2px solid rgba(255, 255, 255, 0.4); */
    background-color: rgba(0,128,155,0);
    transition: border-color 0.2s, border-width 0.2s;
    transition-delay: border-color 0.2s, border-width 0.2s;

    cursor: ew-resize !important 


}

body.notepanelIsBeingResized * ,
body.notepanelIsBeingResized > * {

    cursor: ew-resize !important;

}

#flexiContainer.notepanelIsExpanded{
    width: calc(100% - 10px - var(--note-panel-width));
    margin-left: calc(10px + var(--note-panel-width))!important;
    transition: width 0.6s, margin-left 0.6s !important;
}

.noAnimation,
#flexiContainer.notepanelIsExpanded.noAnimation{
	transition: none !important;
}

.notepanelNote .notepanelHeadline{

    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-weight: bold;
    font-size: calc(9px * var(--fontSizeFactor)); 
    line-height: calc(12px * var(--fontSizeFactor)) !important; 


    background-color: rgba(0, 0, 0, 0.2);
    color: rgba(0, 0, 0, 0.5);

    margin: -4px -4px 1px -4px !important;
    padding-left: 4px !important;
    padding-right: 4px !important;
    padding-bottom: 1px !important;

    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;

}

.notepanelNote{

    position: relative;

    font-family: 'Courier Prime', 'Courier New', Courier, monospace;

    padding: 4px 4px 1px 4px;
    margin-bottom: 3px;
    /* margin-left: -2px; */

    white-space: normal !important;

    background-image: repeating-linear-gradient(180deg, transparent 0px, transparent calc(12px * var(--fontSizeFactor)), rgba(0,0,0,0.1) calc(12px * var(--fontSizeFactor)), rgba(0,0,0,0.1) calc(13px * var(--fontSizeFactor)));
    background-color: rgb(255,255,128);
    color: rgba(0, 0, 0, 0.75);
    border:1px solid rgba(0, 0, 0, 0.6 );
    border-radius: 4px !important;

    overflow: hidden;
    text-overflow: ellipsis !important;

    box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);

}

.notepanelNote strong{

    font-weight: bold;

}

.notepanelNote em{

    font-style: italic;

}

.notepanelNote:hover,
.notepanelNote.isSelected{
    border-color: black !important;
    box-shadow: 0 0 0 0.5px black;
}

.notepanelNote.isSelected > .notepanelHeadline,
.notepanelNote:hover > .notepanelHeadline{

    padding-right: calc(3px + 12px * var(--fontSizeFactor)) !important;

}

.notepanelNote.isSelected > .notepanelHeadline,
.notepanelHeadline.isSelected,
.notepanelNote:hover > .notepanelHeadline{
    background-color: black;
    color: white;
    pointer-events: none;
}

.noteButtons{

    position: sticky !important;
    width: 100%;
    height: auto;
    top: 18px;
    left: 0px;

    margin-bottom: 2px;

}

.noteButton{

    position: relative;
    appearance: none;

    margin-left: 0px;
    margin-right: 1px;

    width: 12px;
    height: 12px;

    border-radius: 2px;
    border: 1px rgba(0, 0, 0, 0.5) solid; 

    display: none;
}

.noteButton:checked::after{

    position: absolute;
    top: -2px;
    left: 0;
    width: 100%;

    content: "✓";
    text-align: center !important;
    font-weight: bold;
    color: rgba(0, 0, 0, 0.6);

}

#notepanelReviewIcon{

    position: absolute;
    right: 10px;
    top: 2px;

    height: 12px;
    width: 18px !important;
        
    background-color: hsl(49, 40%, 73%);
    border: 1px solid hsl(49, 37%, 26%);
    border-radius: 4px;
    color: rgba(0, 0, 0, 0);

        /* right: -12px;  */

        /* scale: 90%; */
        /* filter: grayscale(1); */
        /* font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;*/
        font-size: 8px;
        font-weight: bold;
        line-height: 10px;
        padding-left: 4px;

}

#notepanelReviewIcon:has(:checked){
    background-color: #ffe575;
    color: hsl(49, 37%, 26%);
}

#notepanelReviewIcon .noteButton{

    border: none;
    width: 100%;
    top: -3px;

}

#notepanelReviewIcon::after{

    position: absolute;
    bottom: -2px;
    left: 3px;
    height: 0;
    /* top: inherit; */

    content: " " !important;

    border: 3px solid transparent;
    border-top: 0px solid transparent;
    border-left: 3px solid hsl(49, 40%, 73%);

}

#notepanelReviewIcon:has(:checked)::after{
    border-left: 3px solid #ffe575;
}

#notepanelReviewIcon::before{

    position: absolute;
    bottom: -4.44px;
    left: 2px;

    content: " ";

    border: 4.44px solid transparent;
    border-top: 0px solid transparent;
    border-left: 4.44px solid hsl(49, 37%, 26%);

    z-index: -1;

}

#notepanel:has(.greenNote) #noteButtonGreen     {display: inline-block; background: #88FF88;}
#notepanel:has(.yellowNote) #noteButtonYellow   {display: inline-block; background: rgb(255,255,128);}
#notepanel:has(.redNote) #noteButtonRed         {display: inline-block; background: #FF8888;}
#notepanel:has(.magentaNote) #noteButtonMagenta {display: inline-block; background: #FF88FF;}
#notepanel:has(.purpleNote) #noteButtonPurple   {display: inline-block; background: #9088FF;}
#notepanel:has(.notepanelReview) #noteButtonReview       {display: inline-block;}

#notepanel:has(#noteButtonGreen:not(:checked)) .greenNote       {display: none;}
#notepanel:has(#noteButtonYellow:not(:checked)) .yellowNote     {display: none;}
#notepanel:has(#noteButtonRed:not(:checked)) .redNote           {display: none;}
#notepanel:has(#noteButtonMagenta:not(:checked)) .magentaNote   {display: none;}
#notepanel:has(#noteButtonPurple:not(:checked)) .purpleNote     {display: none;}
#notepanel:has(#noteButtonReview:not(:checked)) .notepanelReview{display: none;}

.notepanelReview{

    position: relative;

    white-space: normal;
    word-wrap: break-word;

    padding: 11px 5px 2px 8px;
    margin-bottom: 3px;
    margin-left: -1px;
    margin-right: 0px;

    background-color: #ffe575;
        border: 1px solid #7f723a;
        border-radius: 4px;
        color: #7f723a;

        font-size: calc(10px * var(--fontSizeFactor));
        line-height: calc(14px * var(--fontSizeFactor));
        font-weight: normal;
        text-align: left;
        color: rgba(0, 0, 0, 0.75);

        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);

}

.notepanelReview > .reviewHeadline{

    position: absolute;
    top: 0;
    left: -1px;
    padding: 0px 8px 0px 8px;
    background-color: #7f723a;
    color: #ffe575;

    border-radius: 4px 4px 0 0 ;

    font-weight: bold;
    font-size: 8px;
    line-height: 10px;
    width: calc(100% + 2px);

}

.notepanelReview:hover,
.notepanelReview.isSelected{

    border-color: black !important;
    box-shadow: 0 0 0 0.5px black;

}

.notepanelReview:hover > .reviewHeadline,
.notepanelReview.isSelected > .reviewHeadline{

    background-color: black;
    color: white;
    pointer-events: none;

}

</style>
<script>

function cycleTabs(clickedElement, unconditional){

    if(!$("#notepanel.expanded")) { 
        toggleNotepanel()
        if(!clickedElement) return 
    }
    
    if(clickedElement?.classList.contains("selectedtab") && !unconditional) return

    clickedTab = clickedElement || ($("#notepanel.expanded .selectedtab + .tab") || $("#notepanel .tab")) //|| event.target

    $$(".selectedtab").forEach(tab => {tab.classList.remove("selectedtab")})
    clickedTab.classList.add("selectedtab")

    if($(".selectedtab").classList.contains("dialogtab")) {
        alertThis($id("allDialogFor").selectedOptions[0]?.innerText.trim())
        initiateCharacterBubbles($id("allDialogFor").selectedOptions[0]?.innerText.trim() || "ALL")
    }else{
        unShowCharacterBubbles()
        reevaluateColorContrast()
    }

    if( $(".selectedtab").classList.contains("scenestab") ) { 
        populateScenesPanelButtons()
        updateScenePanel() 
    } 

    if( $(".selectedtab").classList.contains("notetab") ) { 

        if(!globalAllNotes) collectNotes()
        updateNotepanel()
    } 


    documentSetting.selectedPanelTab = ["dialogtab", "scenestab", "notetab"].find(tabname => $(".selectedtab").classList.contains(tabname))
    saveCurrentState()

}

function notePanelColorButtons(){

    if(!$(".noteButtons")) $id("notepanelbuttons").innerHTML = /*html*/`<div class='noteButtons'></div>`

    let notesInPanel = $$(".notepanelNote")
    let colorsInNotes = [...new Set([...notesInPanel].map(element => element.dataset.color))]

    for (colbtn of colorsInNotes){

        if(!$(`.noteButton[data-color="${colbtn}"]`)){

            let btn = document.createElement("input")
                btn.type = "checkbox"
                btn.label = colbtn
                btn.classList.add("noteButton")
                btn.id = colbtn
                btn.dataset.color = colbtn
                btn.checked = true
                btn.onclick = function(){
                        $$(`.notepanelNote[data-color = "${btn.dataset.color}"]`).forEach(note => note.classList.toggle("displayNone", !btn.checked))
                    }
                btn.style.display = "inline-block"
                btn.style.backgroundColor = $(`.notepanelNote[data-color="${colbtn}"]`).style.backgroundColor

                $(".noteButtons").appendChild(btn)

        }    
    }

    $$(".noteButton").forEach(notebtn => {
        if(!$(`.notepanelNote[data-color="${notebtn.dataset.color}"]`)) notebtn.remove()
        })

    if ($(".notepanelReview")){

        let btndiv = document.createElement("div")
            btndiv.id = "notepanelReviewIcon"
            btndiv.innerText = "✓"
            
        let btn = document.createElement("input")
            btn.type = "checkbox"
            btn.classList.add("noteButton")
            btn.id = "reviewBtn"
            btn.checked = true
            
        btndiv.onclick = function(){
                btn.click()
            }                
        btn.onclick = function(){
                $$(`.notepanelReview`).forEach(review => review.classList.toggle("displayNone", !btn.checked))
            }

        btndiv.appendChild(btn)        
        $(".noteButtons").appendChild(btndiv)        

    }
}

function resizeNotepanel(){

    mylog("in here!")

    document.body.classList.add("notepanelIsBeingResized")
    flexiContainer.classList.add("noAnimation")
    let redraw = flexiContainer.getBoundingClientRect()

    document.addEventListener("mouseup", finalizeResizingNotepanel)
    document.addEventListener("mousemove", resizing)

}

function resizing(e){

    mylog("in resizing")

    e = e || window.event
    
        let x = e.pageX

        theRoot.style.setProperty("--note-panel-width", x + "px")
    
        mylog(x)
}


function finalizeResizingNotepanel(){

    document.removeEventListener("mouseup", finalizeResizingNotepanel)
    document.removeEventListener("mousemove", resizing)
    document.body.classList.remove("notepanelIsBeingResized")
    flexiContainer.classList.remove("noAnimation")

    saveCurrentState()

}

function updateNotepanel(){

    mylog("updateNotepanel, which has... " + $id("notepanel").classList || "nothing")

    let allNotes = globalAllNotes.flat()

    $$(".notepanelNote").forEach(note => {note.remove()})
    $$(".notepanelReview").forEach(note => {note.remove()})

        for(let i = 0; i < allNotes.length; i++){

            let elementType = outline[allNotes[i].outlineElementNumber]?.typeAsString
                if (elementType == "Heading"){elementType = "Note in scene " + outline[allNotes[i].outlineElementNumber]?.sceneNumber}
                if (elementType == "Section"){elementType = `Note in ` + outline[allNotes[i].outlineElementNumber]?.stringForDisplay?.toUpperCase() + ``}

            let thisNote = document.createElement("div")
                thisNote.id = "notepanelNote" + i
                thisNote.classList.add("notepanelNote")
                thisNote.dataset.line = allNotes[i].range.location
                thisNote.dataset.length = allNotes[i].range.length
                thisNote.dataset.inline = allNotes[i].inline

                let thisNoteText = allNotes[i].formattedContent

                thisNote.innerHTML = `<div id="placeholder${i}" class="placeholder">${i}</div>
                        <p class="notepanelHeadline">${allNotes[i].headline}</p>${thisNoteText}`

            let dummydiv = document.createElement("div")
                dummydiv.style.backgroundColor = allNotes[i].color
                document.body.appendChild(dummydiv)
            let colCode = window.getComputedStyle(dummydiv).backgroundColor || "#FFFF00"
                if (colCode == "rgba(0, 0, 0, 0)") colCode = "rgb(255,255,0)" //"#FFFF00"

                thisNote.style.backgroundColor = lightenColor(colCode, 50)
                thisNote.dataset.color = colCode 
                dummydiv.remove()

                if($(`.noteButton[data-color="${colCode}"]`) && !$(`.noteButton[data-color="${colCode}"]`).checked) thisNote.classList.add("displayNone")

            $id("notepanelcontent").appendChild(thisNote)

            let trashDiv = document.createElement("div")
                trashDiv.id = "trashNote" + i
                trashDiv.classList.add("trashNote")
                trashDiv.innerHTML = trashIcon
                trashDiv.onclick = () => {deleteNote()}
            $(".placeholder").replaceWith(trashDiv)
            $$(".placeholder").forEach(placeholder => placeholder.remove())
        }

    let currentNote = Array.from($$(".notepanelNote")).find(note => {note.dataset.line <= currentCaretPosition && (note.dataset.line + note.dataset.length) >= currentCaretPosition}) || false
        if(currentNote && isThisOffScreen(currentNote)) scrollNicelyIntoView(currentNote, $id("notePanel"))

    if(globalReviewsData?.length > 0){
        mylog("looping reviews in panel")
        for(let i = 0; i < globalReviewsData.length; i++){

            let thisReview = document.createElement("div")
                thisReview.id = "notepanelReview" + i
                thisReview.classList.add("notepanelReview")
                thisReview.dataset.line = globalReviewsData[i].range[0]
                thisReview.dataset.length = globalReviewsData[i].range[1]
                thisReview.innerHTML = "<div class='reviewHeadline'>REVIEW #" + i + "</div>"

                thisReview.innerHTML += globalReviewsData[i].string

                let notesInPanel = $$(".notepanelNote")
                let whereToInsert
                for(let note of notesInPanel){
                    if (note.dataset.line && note.dataset.line > globalReviewsData[i].range[0]){
                        break
                    }
                    whereToInsert = note
                }

                while(whereToInsert?.nextSibling && whereToInsert?.nextSibling?.classList.contains("notepanelReview")) whereToInsert = whereToInsert.nextSibling
                if(whereToInsert)whereToInsert.insertAdjacentElement("afterend", thisReview)
                // if(!whereToInsert)$id("notepanel").appendChild(thisReview)
                if(!whereToInsert)$id("notepanelcontent").appendChild(thisReview)

        }
    }

    notePanelColorButtons()

    mylog("end of update notepanel")
}

function toggleNotepanel() {

    mylog("toggleNotepanel")

    let isExpanded = !$id("notepanel").classList.contains("expanded")

    
    $id("notepanel").classList.toggle("expanded", isExpanded)
    $id("flexiContainer").classList.toggle("notepanelIsExpanded", isExpanded)
    
    unShowCharacterBubbles()

    //switch to the currently selected tab (and refresh it)
        if(isExpanded){
            setTimeout(() => {
                cycleTabs($(".selectedtab"), true) //true will unconditionally run the function even if the tab is already selected, essentially updating it
            }, 600)
        }



    clearSearchBox()
    saveCurrentState()
    setAllButtons()
    reevaluateColorContrast()
}

function panelNoteIsHovered(element){

    mylog("HOVERING, namely this: " + element.classList)

    if(!notesAreDisplayed && !reviewsAreDisplayed){return}

    panelNoteIsUnhovered() // to make sure only one can be highlighted at one time

    let prefix = ""
    if(element.id.startsWith("notepanelNote")){
        noteId = element.id.replace("notepanelNote", "")
        prefix = "noteNumber"
    }
    if(element.id.startsWith("notepanelReview")){
        noteId = element.id.replace("notepanelReview", "")
        prefix = "review"
    }
    if(!noteId)return

    let noteToHover = $id(prefix + noteId)
    noteToHover?.classList.add("selectedNote")
}

function panelNoteIsUnhovered(element){

    mylog("note is unhovered")
    if(!notesAreDisplayed){return}

    let allNotes = $$(".note, .review")
    for (let note of allNotes){
        note.classList.remove("selectedNote")
    }
}

</script><script>

function populateScenesPanelButtons(){

    document.getElementById("scenespanelbuttons").innerHTML = "<div style='display: inline-block; vertical-align: middle;'>Sort by:</div>"

    let dropDownSpan = document.createElement("div")
        dropDownSpan.classList = "dropDownSpan hasSelect"
        dropDownSpan.style.display = "inline-block"
        dropDownSpan.style.position = "relative"
        dropDownSpan.style.verticalAlign = "middle"
        dropDownSpan.style.marginLeft = "3px"
        dropDownSpan.style.marginRight = "4px"
        dropDownSpan.innerHTML = ""
        document.getElementById("scenespanelbuttons").appendChild(dropDownSpan)

    let sortDropDown = document.createElement("select")
        sortDropDown.id = "sortDropDown"
        sortDropDown.classList.add("colorDropdown")
        sortDropDown.style.width = "auto"
        sortDropDown.innerHTML = `
            <option value="scriptOrder">SCRIPT ORDER&nbsp;</option>
            <option value="location">LOCATION&nbsp;</option>
            <option value="prefixTimeOfDay">SCHEDULE GROUP&nbsp;</option>
            <option value="timeOfDayOption">TIME OF DAY&nbsp;</option>
            <option value="prefixOption">PREFIX&nbsp;</option>
        `
        sortDropDown.value = "scriptOrder"
        if (Array.from(sortDropDown.options).some(option => option.value == documentSetting.sortDropDown)) sortDropDown.value = documentSetting.sortDropDown
        // sortDropDown.value = documentSetting.sortDropDown || "scriptOrder"
        sortDropDown.classList.toggle(sortDropDown.value, true) 

        sortDropDown.onchange = () => {
            documentSetting.sortDropDown = sortDropDown.value
            for (option of sortDropDown.options){
                sortDropDown.classList.toggle(option.value, option.value == sortDropDown.value)
            }
            updateScenePanel()
            saveCurrentState()
        }

    dropDownSpan.appendChild(sortDropDown)

    let checkboxSpan = document.createElement("div")
        checkboxSpan.id = "checkboxSpan"
        checkboxSpan.classList = "checkboxSpan"
        document.getElementById("scenespanelbuttons").appendChild(checkboxSpan)

    let mergeSimilarLocations = document.createElement("input")
        mergeSimilarLocations.type = "checkbox"
        mergeSimilarLocations.id = "mergeSimilarLocations"
        mergeSimilarLocations.checked = documentSetting.mergeSimilarLocations || false
        // document.getElementById("scenespanelbuttons").appendChild(mergeSimilarLocations)
        checkboxSpan.appendChild(mergeSimilarLocations)
        mergeSimilarLocations.onchange = () => {
            documentSetting.mergeSimilarLocations = mergeSimilarLocations.checked;
            window.onload = () => {
                [".sceneNum", ".prefix"].forEach(selector => {
                    setMutualSize(Array.from(selector))
                })
            }
            // [".sceneNum", ".duplicateSceneNum", ".prefix", ".timeOfDay", ].forEach(selector => {
            //     setMutualSize($$(selector))
            // })
            saveCurrentState()
        }

    let mergeSimilarLocationsLabel = document.createElement("label")
        mergeSimilarLocationsLabel.setAttribute("for", "mergeSimilarLocations")
        mergeSimilarLocationsLabel.textContent = "Collate twins"
    // document.getElementById("scenespanelbuttons").appendChild(mergeSimilarLocationsLabel)
    checkboxSpan.appendChild(mergeSimilarLocationsLabel)

    let onlyShowTypos = document.createElement("input")
        onlyShowTypos.type = "checkbox"
        onlyShowTypos.id = "onlyShowTypos"
        onlyShowTypos.checked = documentSetting.onlyShowTypos || false
        onlyShowTypos.onchange = () => {
            documentSetting.onlyShowTypos = onlyShowTypos.checked
            saveCurrentState()
        }
    // document.getElementById("scenespanelbuttons").appendChild(onlyShowTypos)
    checkboxSpan.appendChild(onlyShowTypos)

    let onlyShowTyposLabel = document.createElement("label")
        onlyShowTyposLabel.setAttribute("for", "onlyShowTypos")
        onlyShowTyposLabel.textContent = "Only show typos"
    // document.getElementById("scenespanelbuttons").appendChild(onlyShowTyposLabel)
    checkboxSpan.appendChild(onlyShowTyposLabel)

    let scenepanelHelpButton = document.createElement("div")
        scenepanelHelpButton.id = "scenepanelHelpButton"
        scenepanelHelpButton.classList.add("scenepanelHelpButton")
        scenepanelHelpButton.innerHTML = "?"
        scenepanelHelpButton.onclick = () => {
            // Beat.call(() => Beat.custom.displaySecondWindow("Scene Panel Help", "scenepanelhelpwindow.html", 700, 800))
            Beat.call(/*html*/`Beat.custom.displaySecondWindow("Scene Panel Help", "scenepanelhelpwindow.html", 700, 800)`)
        }
    document.getElementById("scenespanelbuttons").appendChild(scenepanelHelpButton)
    
    let scenepanelSettingsButton = document.createElement("div")
        scenepanelSettingsButton.id = "scenepanelSettingsButton"
        scenepanelSettingsButton.classList.add("scenepanelSettingsButton")
        scenepanelSettingsButton.innerHTML = gearIcon
        scenepanelSettingsButton.onclick = () => {
            // displayContextMenu(null, scenepanelSettingsButton)
            let allTod = JSON.stringify(Array.from($$(".timeOfDay")).map(tod => tod.textContent))
            Beat.call(/*html*/`Beat.custom.displaySecondWindow("Scene Panel Settings", "scenepanelsettingswindow.html", 800, 800, true, '${allTod}')`)

        }
    document.getElementById("scenespanelbuttons").appendChild(scenepanelSettingsButton)
    // checkboxSpan.appendChild(scenepanelSettingsButton)

}

function parseSceneHeadings(){

    mylog()

    if(!outline) return
    if(!($("#notepanel.expanded .scenestab.selectedtab"))) return
    
    // if(!userDefault.timeOfDayObject || Object.keys(userDefault.timeOfDayObject)?.length == 0) applySettings()
    if(!userDefault.timeOfDayObject || Object.keys(userDefault.timeOfDayObject)?.length == 0) {
        userDefault.timeOfDayObject = knownTimesOfDayObject
        saveCurrentState()
    }
    if(!$id("sortDropDown")) populateScenesPanelButtons()

    let schedulingColors = {
            INTDAY:     "hsla(210, 100%, 100%, 1.00)",
            EXTDAY:     "hsla(47, 60%, 80%, 1.00)",
            INTNIGHT:   "hsla(210, 60%, 80%, 1.00)",
            EXTNIGHT:   "hsla(150, 60%, 80%, 1.00)",
            RED:        "lightcoral" //"hsla(2, 20%, 50%, 1.00)"
        }

    let scenes = outline.filter(scene => {return scene.typeAsString == "Heading"})
    let parsedScene = []
    let prefix = ""

    for (scene of scenes){

        let string = scene.stringForDisplay.toUpperCase()

        let intextString = /^((INT(\.)*\/EXT)|(EXT(\.)*\/INT)|(INT)|(EXT)|(I(\.)*\/E)|)\.*/

        if (intextString.test(string)) {

            prefix = string.match(intextString)[0] || ""
            string = string.substring(prefix.length).trim()
            if (prefix == "") prefix = "???"

        }
        
        let addOns = string.match(/\(.*\)/g)
        if (addOns !== null){
            for (addOn of addOns){
                // string = string.replace(addOn, "/").trim() //because I now want to split the string where there used to be a parenthesis
                // string = string.replace(addOn, addOn.replace("(", "/").replace(")", "/")).trim() //because I now want to split the string where there used to be a parenthesis
                string = string.replace(addOn, "/" + addOn).trim() //because I want to split the string at a parenthesis, BUT KEEP IT IN.
            }
        }

        let parts = string/*.replaceAll(/\(.*\)/g, "")*/.toUpperCase().split(/[\s/]+-+[\s/]+|\s*\/\s*/).filter(part => part.length > 0);
        let partsIndex = []
            for (part of parts){

                indexAtStart = scene.range.location + scene.string.toUpperCase().indexOf(part)
                indexAtEnd = indexAtStart + part.length

                partsIndex.push({
                    part: part,
                    indexAtStart: indexAtStart,
                    indexAtEnd: indexAtEnd
                })

            }

        //remove addons from the end of the array
            let removedAddons = []
            let removedIndex = []
            while (addOns?.includes(parts.at(-1))){
                removedAddons.push(parts.at(-1))
                removedIndex.push(partsIndex.at(-1))
                parts.pop()
                partsIndex.pop()
            }

        //check for time of day at the end of the array
            let timeOfDay = "UNKNOWN"
            let dayOrNight
                for (key in userDefault.timeOfDayObject){

                    if (userDefault.timeOfDayObject[key].indexOf(parts.at(-1)?.toUpperCase()) > -1){
                        timeOfDay = userDefault.timeOfDayObject[key][userDefault.timeOfDayObject[key]?.indexOf(parts.at(-1)?.toUpperCase())] || "UNKNOWN"
                        dayOrNight = key.toUpperCase()

                        if (key == "same") { dayOrNight = parsedScene.at(-1)?.dayOrNight }

                        parts.pop()
                        partsIndex.pop()
                        break
                    }
                }
                if (documentSetting.sortNoneAsSame && timeOfDay == "UNKNOWN"){ dayOrNight = parsedScene.at(-1)?.dayOrNight }
                // if (userDefault.timeOfDayObject.same.includes(parts.at(-1).toUpperCase()) || (documentSetting.sortNoneAsSame && timeOfDay == "UNKNOWN")){
                //     dayOrNight = parsedScene.at(-1)?.dayOrNight
                // }


            // if (timeOfDay == parts.at(-1)){
            //     parts.pop()
            //     partsIndex.pop()
            // }
        //THIS is where I should reverse concatenation if sorting by parenthesis!
        if (documentSetting.ShowParenthesis && documentSetting.groupByParenthesis) {
            parts = removedAddons.concat(parts)
            partsIndex = removedIndex.concat(partsIndex)
        }
        if (documentSetting.ShowParenthesis && !documentSetting.groupByParenthesis) {
            parts = parts.concat(removedAddons)
            partsIndex = partsIndex.concat(removedIndex)
        }

    //adding the result to the array
        parsedScene.push({

            sceneNumber: scene.sceneNumber || scenes.indexOf(scene) + 1,
            UUID: scene.uuid,
            prefix: prefix,
            sublocations: parts, //parts.slice(["INT", "EXT"].includes(parts[0].substring(3)) ? 1 : 0),
            startIndices: partsIndex.map(part => part.indexAtStart),
            endIndices: partsIndex.map(part => part.indexAtEnd),
            timeOfDay: timeOfDay,
            dayOrNight: dayOrNight,
            other: addOns || "",
            index: scene.range.location,
            color: schedulingColors[prefix?.substring(0 , 3).replace(".", "").toUpperCase().trim() + dayOrNight?.toUpperCase().trim()] || schedulingColors["RED"],
            colorKey: prefix?.substring(0 , 3).replace(".", "").toUpperCase().trim() + " & " + dayOrNight?.toUpperCase().trim(),
            outlineColor: getComputedStyle($(`[data-uuid = '${scene.uuid}']`)).backgroundColor,
            lengthInPages: scene.numberOfPages
        })
    }

    addDividerLine ()
    
    let sortedScenes = parsedScene.sort(sortBy[$id("sortDropDown").value])

    if($id("sortDropDown").value == "location"){
        sortedScenes = sortByFrequency(sortedScenes)
    }

    //first group 
        let evenOrOdd = "odd"
        let groupDiv = document.createElement("div")
            groupDiv.classList.add("scenepanelgroup")
            groupDiv.id = "scenepanelgroup_0"
            $id("scenespanelcontent").appendChild(groupDiv)

    for (scene of sortedScenes){

        // mark double locations etc
        let thisIsADoubleLocation = false
            if($id("sortDropDown").value == "location"){
                // thisIsADoubleLocation = (scene.sublocations.join(",") == sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.join(",")) 
                thisIsADoubleLocation = (scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(",")) == (sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(","))
            }
        
        //1. the line
        let lineDiv = document.createElement("div")
            lineDiv.classList.add("line")
            lineDiv.classList.add(evenOrOdd)
            lineDiv.classList.toggle("hideWhenMergeIsChecked", thisIsADoubleLocation)
            lineDiv.dataset.line = scene.index
            
            //GROUPING
            //1. location
                if($id("sortDropDown").value == "location"){

                    

                    if (scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(",") !== sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc)).join(",")) { 
                        lineDiv.classList.remove(evenOrOdd)
                        evenOrOdd = (evenOrOdd === "odd" ? "even" : "odd")
                        lineDiv.classList.add(evenOrOdd)
                    }

                    // let startNewGroup = (documentSetting.groupByParenthesis && scene.other) ?
                    //     scene.other.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.other.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] :
                    //     scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0]
                    let startNewGroup = scene == sortedScenes.at(0) || scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] 
                    
                    // if (scene.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0] != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc))[0]) { 
                    if (startNewGroup) { 
                        lineDiv.classList.add("newgroup")
                        lineDiv.classList.remove(evenOrOdd)
                        evenOrOdd = "odd"
                        lineDiv.classList.add(evenOrOdd)

                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //2. time of day
                if($id("sortDropDown").value == "timeOfDayOption"){
                    if (scene.timeOfDay != sortedScenes[sortedScenes.indexOf(scene) - 1]?.timeOfDay) { 
                        lineDiv.classList.add("newgroup")
                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //3. schedule group
                if($id("sortDropDown").value == "prefixTimeOfDay"){
                    if (scene.color != sortedScenes[sortedScenes.indexOf(scene) - 1]?.color) { 
                        lineDiv.classList.add("newgroup")

                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //4. prefix
                if($id("sortDropDown").value == "prefixOption"){
                    if (scene.prefix != sortedScenes[sortedScenes.indexOf(scene) - 1]?.prefix) { 
                        lineDiv.classList.add("newgroup")

                        groupDiv = document.createElement("div")
                        groupDiv.classList.add("scenepanelgroup")
                        groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                        $id("scenespanelcontent").appendChild(groupDiv)
                    }
                }
            //5. script order
                if($id("sortDropDown").value == "scriptOrder"){
                    // if (scene.sceneNumber != sortedScenes[sortedScenes.indexOf(scene) - 1]?.sceneNumber) { 
                    //     lineDiv.classList.add("newgroup")

                    //     groupDiv = document.createElement("div")
                    //     groupDiv.classList.add("scenepanelgroup")
                    //     groupDiv.id = "scenepanelgroup_" + $$(".scenepanelgroup").length
                    //     $id("scenespanelcontent").appendChild(groupDiv)
                    // }
                }

        let leftColumn = document.createElement("div")
            leftColumn.classList.add("leftColumn")
            leftColumn.dataset.line = scene.index

            let flexdiv = document.createElement("div")
                flexdiv.classList.add("flexdiv")
                flexdiv.dataset.line = scene.index
                flexdiv.style.width = "100%"
                flexdiv.style.height = "100%"
                flexdiv.style.display = "flex"

    //fill the line with...
        //0. scene number
        let sceneNumDiv = document.createElement("div")
            sceneNumDiv.innerText = scene.sceneNumber //+ scene.lengthInPages
            sceneNumDiv.classList.add("item")
            sceneNumDiv.classList.add("leftItem")
            sceneNumDiv.classList.add("sceneNum")
            sceneNumDiv.dataset.line = scene.index
            sceneNumDiv.style.background = documentSetting.schedulingColors ? scene.color : scene.outlineColor
            sceneNumDiv.dataset.lengthInPages = scene.lengthInPages
            sceneNumDiv.dataset.colorKey = scene.colorKey
        // leftColumn.appendChild(sceneNumDiv)
        flexdiv.appendChild(sceneNumDiv)


        //1. prefix
        let prefix = document.createElement("div")
            prefix.innerText = scene.prefix.includes("/") ? "I/E" : scene.prefix.replaceAll(".", "")
            prefix.classList.add("item")
            prefix.classList.add("leftItem")
            prefix.classList.add("prefix")
            prefix.dataset.line = scene.index
            prefix.style.background = documentSetting.schedulingColors ? scene.color : scene.outlineColor

        // leftColumn.appendChild(prefix)
        flexdiv.appendChild(prefix)

        //2. time of day
        let timeOfDay = document.createElement("div")
            timeOfDay.innerText = scene.timeOfDay
            timeOfDay.classList.add("item")
            timeOfDay.classList.add("leftItem")
            timeOfDay.classList.add("timeOfDay")
            timeOfDay.dataset.line = scene.index
            timeOfDay.style.background = documentSetting.schedulingColors ? scene.color : scene.outlineColor


        // leftColumn.appendChild(timeOfDay)
        flexdiv.appendChild(timeOfDay)

        leftColumn.appendChild(flexdiv)
        lineDiv.appendChild(leftColumn)

        //2. locations
        sublocations = scene.sublocations
        for (loc of sublocations){

            if (scene.other.includes(loc) && !documentSetting.ShowParenthesis) continue
            if (loc == scene.timeOfDay) continue

            let subloc = document.createElement("div")
                subloc.dataset.uuid = scene.UUID
                subloc.dataset.line = scene.index
                subloc.dataset.startIndex = scene.startIndices[sublocations.indexOf(loc)]
                subloc.dataset.endIndex = scene.endIndices[sublocations.indexOf(loc)]
                subloc.classList.add("item")
                subloc.classList.add("rightItem")
                subloc.classList.add("location")
                subloc.innerText = loc
                
                if (scene.other.includes(loc)) {
                    subloc.classList.add("addon")
                }

                if(documentSetting.excludedLocations?.includes(loc)){
                    subloc.classList.add("excludedLocation")
                }
                if(documentSetting.groupExclusions?.includes(loc)){
                    subloc.classList.add("dontCompare")
                }

            lineDiv.appendChild(subloc)

        }

        Array.from($$(".scenepanelgroup")).at(-1).appendChild(lineDiv)
        if(thisIsADoubleLocation) {
            $(".scenepanelgroup:last-child").lastChild.classList.add("isDouble")
            let copyOfSceneNumDiv = sceneNumDiv.cloneNode(true)
                copyOfSceneNumDiv.classList.add("duplicateSceneNum")
            let lastOriginalLine = Array.from($$(".scenepanelgroup > :not(.isDouble)")).at(-1)
                // lastOriginalLine.querySelector(".flexdiv").appendChild(copyOfSceneNumDiv)
                lastOriginalLine.querySelector(".flexdiv").insertBefore(copyOfSceneNumDiv, lastOriginalLine.querySelector(".flexdiv .prefix"))
        }
    }

    flagLinesWithSingleLocation() 

    $$(".scenepanelgroup").forEach(group => {

        let headlineDiv = document.createElement("div")
            headlineDiv.classList.add("groupHeadline")
        
        // let mainLocation = group.querySelector(".location:not(.dontCompare)")?.textContent || (group.querySelector(".location")?.textContent ? (group.querySelector(".location")?.textContent + "</strong> without sublocations") : "")
        let mainLocation = group.querySelector(".location:not(.dontCompare)")?.textContent || (group.querySelector(".item")?.textContent ? "WITH NO NAME" : "")
        let todHeadline = group.querySelector(".timeOfDay")?.textContent
        let prefixHeadline = group.querySelector(".prefix")?.textContent
        let scheduleHeadline = group.querySelector(".prefix")?.textContent + " " + group.querySelector(".timeOfDay")?.textContent
            if(mainLocation){
                let scenesInGroup = group.querySelectorAll(".sceneNum:not(.isDouble .sceneNum)")
                let numberOfScenes = scenesInGroup.length
                let lengthOfScenes = numberIntoEights(Array.from(scenesInGroup).reduce((acc, val) => acc + Number(val.dataset.lengthInPages), 0))

                switch ($id("sortDropDown").value) {
                    case "location":
                        
                        let typeOfFirstItem = "at main location"
                            if (documentSetting.groupByParenthesis && group.querySelector(".rightItem:not(.dontCompare)")?.classList.contains("addon")) typeOfFirstItem = "with parenthesis"

                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> ${typeOfFirstItem} <strong>${mainLocation}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        
                        if (group.classList.contains("singlegroup")) headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> at <strong>NON-RECURRING LOCATIONS</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;
                
                    case "prefixTimeOfDay":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> during <strong>${group.querySelector(".sceneNum").dataset.colorKey}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;

                    case "scriptOrder":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;

                    case "timeOfDayOption":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> during <strong>${todHeadline}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;

                    case "prefixOption":
                        
                        headlineDiv.innerHTML = `<strong>${numberOfScenes} scene${numberOfScenes > 1 ? "s" : ""}</strong> with prefix <strong>${prefixHeadline}</strong>, in total <strong>${lengthOfScenes} pages</strong> `
                        break;
                }
            }
            
            // group.parentNode.insertBefore(headlineDiv, group)
            group.insertBefore(headlineDiv, group.firstChild)

    })
    
    compareAllLocations()
    addNumberOfPagesToLines()

    //set color of single groups
        $("#scenespanelcontent").style.setProperty("--singlegroupColor", documentSetting.singleGroupAsRed ? "rgba(220, 100, 100, 0.6)" : "rgba(255, 255, 255, 0.6)")

    //add eventhandlers
    Array.from($$(".location")).forEach(subloc => {

        subloc.onclick = (event) => {
                event.stopPropagation()
                //this empty onclick is to prevent the event from bubbling up to the group
        }
        subloc.ondblclick = (event) => {
                event.stopPropagation()
                event.preventDefault()
                event.stopImmediatePropagation()
                // newNameDialog(Array.from($$(".isSelected")).push(event.target))
                let selectedItems = Array.from($$(".isSelected"))
                    selectedItems.forEach(item => { item.classList.remove("isSelected") })
                newNameDialog(selectedItems.length > 0 ? selectedItems : Array.of(event.target))
            }
        subloc.onmouseover = (event) => {
                if ($("#contextMenu")) return //so as not to un-highlight items when moving to the menu 
                $$(".isSelected").forEach(element => {
                    element.classList.remove("isSelected")
                })
                if (!event.shiftKey) return
                $$(".location").forEach(element => {
                    if(element.textContent == event.target.textContent){
                        element.classList.add("isSelected")
                    }
                })
            }
        subloc.onmouseout = (event) => {
                // if ($("#contextMenu")) return //so as not to un-highlight items when moving to the menu 
                // if (!event.shiftKey) return
                $$(".isSelected").forEach(element => {
                    element.classList.remove("isSelected")
                })
            }

    })
    
    //size all items equally
        selectors = [".sceneNum", ".prefix"]
        selectors.forEach(selector => setMutualSize(selector))

}

function addNumberOfPagesToLines(){ 

    $$(".scenespanelcontent .line").forEach(line => {

    let whatToAddSingle = line.querySelectorAll(".sceneNum:not(.duplicateSceneNum)") 
    let whatToAddMultiple = line.querySelectorAll(".sceneNum")
    let pagesForLineSingle = numberIntoEights(Array.from(whatToAddSingle).reduce((acc, val) => acc + Number(val.dataset.lengthInPages), 0))
    let pagesForLineMultiple = numberIntoEights(Array.from(whatToAddMultiple).reduce((acc, val) => acc + Number(val.dataset.lengthInPages), 0))    
        
    line.innerHTML += `<div class="pagesForLine">
        <span class="multiplePageCount">${pagesForLineMultiple} pgs</span>
        <span class="singlePageCount">${pagesForLineSingle} pgs</span>
        </div>`

    })
}

function flagLinesWithSingleLocation(){

    if($id("sortDropDown").value !== "location") return
    if(!documentSetting.singleAtTop) return

    //add a new group before the first
    let newGroup = document.createElement("div")
        newGroup.classList.add("scenepanelgroup")
        newGroup.id = "scenepanelgroup_0"
        $id("scenespanelcontent").insertBefore(newGroup, $(".scenepanelgroup"))
    
    let allGroups = Array.from($$(".scenepanelgroup"))

    allGroups.forEach(group => {

        let onlyOneLine = group.querySelectorAll(".line").length == 1
        
        group.classList.toggle("singlegroup", onlyOneLine)
        
        if(!onlyOneLine) return

        let linecopy = group.querySelector(".line").cloneNode(true)
            linecopy.classList.toggle("odd", allGroups.indexOf(group) % 2 == 0)
            linecopy.classList.toggle("even", allGroups.indexOf(group) % 2 == 1)
            linecopy.classList.toggle("newgroup", allGroups.indexOf(group) == 0)
            allGroups[0].appendChild(linecopy)
            allGroups[0].classList.add("singlegroup")

            group.remove()
            // group.style.opacity = "0.3"
    })

    allGroups[0].querySelector(".line").classList.add("newgroup")

}

function addDividerLine(){
    $id("scenespanelcontent").style.setProperty("--scenesPanelLeftColumnWidth", (documentSetting.scenesPanelLeftColumnWidth || 120) + "px")
    $id("scenespanelcontent").innerHTML = "<div id='dividerline' draggable='true'></div>"
    
        $id("dividerline").ondragstart = (e) => {
            $id("scenespanelcontent").addEventListener("dragover", onDragOverLocal);
            $id("scenespanelcontent").classList.add("dragging")

            let temporaryDragImage = document.createElement("div")
                temporaryDragImage.id = "temporaryDragImage"
                temporaryDragImage.style.width = "1px"
                temporaryDragImage.style.height = "1px"
                temporaryDragImage.style.position = "absolute"
                temporaryDragImage.style.top = "0"
                temporaryDragImage.style.left = "0"
                temporaryDragImage.style.zIndex = "1000"
                temporaryDragImage.style.background = "transparent"
                document.body.appendChild(temporaryDragImage)

                e.dataTransfer.setDragImage(temporaryDragImage, 0, 0);

        }
        function onDragOverLocal(e) {
            e.preventDefault();
            let newWidth = e.clientX - $id("scenespanelcontent").getBoundingClientRect().left;
            $id("scenespanelcontent").style.setProperty("--scenesPanelLeftColumnWidth", newWidth + "px");
            documentSetting.scenesPanelLeftColumnWidth = newWidth;
        }
        $id("dividerline").ondragend = (e) => {
            $id("temporaryDragImage").remove()
            $id("scenespanelcontent").removeEventListener("dragover", onDragOverLocal);
            $id("scenespanelcontent").classList.remove("dragging")
            saveCurrentState();
        }
    }

function setMutualSize(selector){

            items = Array.from($$(selector))
            if(items.length == 0) return

            let largestWidth = 0
            
            for (item of items){
                if (item.style.display == "none") continue
                item.style.width = "auto"
                item.style.maxWidth = "none"
                largestWidth = Math.max(largestWidth, item.getBoundingClientRect().width)
            }
            if(selector == ".sceneNum" && $(".duplicateSceneNum")) 
                document.querySelector('.duplicateSceneNum').style.setProperty('--sceneNumWidth', `${largestWidth}px`)              

            for (item of items){
                item.style.width = largestWidth + "px"
            }
}

function compareAllLocations() {
    const allLocations = $id("scenespanelcontent").querySelectorAll(".location");
    const comparedPairs = new Set(); // To keep track of already compared pairs

    allLocations.forEach((location1, index1) => {
        const locationString1 = location1.textContent;
        if (locationString1.length < 3) return;

        allLocations.forEach((location2, index2) => {
            if (index1 === index2) return; // Skip comparing the same element with itself
            if (documentSetting.excludedLocations?.includes(location1.textContent)) return // Skip excluded locations

            const locationString2 = location2.textContent
            if (locationString2.length < 3) return

            const articleString = articleArray.join("|")
            const articleRegex = new RegExp(`\\b(${articleString})\\b\\s+`, "gi");


            const strippedString1 = locationString1.replace(articleRegex, '')
            const strippedString2 = locationString2.replace(articleRegex, '')
            let similarExceptArticle = strippedString1 == strippedString2 && locationString1 != locationString2

            const pairKey = [index1, index2].sort().join('|');
            if (comparedPairs.has(pairKey)) return; // Skip already compared pairs

            comparedPairs.add(pairKey);

            const distance = damerauLevenshtein(locationString1, locationString2);
            // const distance = levenshteinDistance(locationString1, locationString2);

            if (distance > 0 && distance < Math.min(((Math.max(locationString2.length, locationString1.length)) * 1/3), 4) || similarExceptArticle){
                    location1.classList.add("similarLocation");
                    location2.classList.add("similarLocation");

                    // Store all similar locations in an array
                    location1.dataset.similarTo = (location1.dataset.similarTo || "").split(',').concat(locationString2).join(',');
                    location2.dataset.similarTo = (location2.dataset.similarTo || "").split(',').concat(locationString1).join(',');

                    location1.dataset.representation = Array.from(allLocations).filter(loc => loc.textContent == locationString1).length
                    location2.dataset.representation = Array.from(allLocations).filter(loc => loc.textContent == locationString2).length
                    location1.classList.toggle("majority", location1.dataset.representation > location2.dataset.representation)
                    location2.classList.toggle("majority", location2.dataset.representation > location1.dataset.representation)
                    location1.classList.toggle("minority", location1.dataset.representation < location2.dataset.representation)
                    location2.classList.toggle("minority", location2.dataset.representation < location1.dataset.representation)

            }
        });
    });
}


function levenshteinDistance(str1 = '', str2 = '') {

    const track = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
        
        for (let i = 0; i <= str1.length; i += 1) {
            track[0][i] = i;
        }
        for (let j = 0; j <= str2.length; j += 1) {
            track[j][0] = j;
        }
        for (let j = 1; j <= str2.length; j += 1) {
            for (let i = 1; i <= str1.length; i += 1) {
                const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
                track[j][i] = Math.min(
                track[j][i - 1] + 1, // deletion
                track[j - 1][i] + 1, // insertion
                track[j - 1][i - 1] + indicator, // substitution
                );
            }
        }

        return track[str2.length][str1.length];

}

function damerauLevenshtein(str1, str2) {
    const len1 = str1.length;
    const len2 = str2.length;
    const matrix = Array.from({ length: len1 + 1 }, () => Array(len2 + 1).fill(0));

    // Initialize the matrix
    for (let i = 0; i <= len1; i++) {
        matrix[i][0] = i;
    }
    for (let j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }

    // Compute distances
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1, // Deletion
            matrix[i][j - 1] + 1, // Insertion
            matrix[i - 1][j - 1] + cost // Substitution
        );

        // Transposition
        if (i > 1 && j > 1 && str1[i - 1] === str2[j - 2] && str1[i - 2] === str2[j - 1]) {
            matrix[i][j] = Math.min(
            matrix[i][j],
            matrix[i - 2][j - 2] + cost
            );
        }
        }
    }

    return matrix[len1][len2];
}

function sortByFrequency(arr, position = 0) {

  // Count the frequency of each value in the specified position of the sublocations arrays
  const freqMap = new Map();
  for (const obj of arr) {
    const sublocs = obj.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc));
    if (sublocs.length > position) {
      const val = sublocs[position].trim();
      if (!documentSetting.groupExclusions?.includes(val)) { // Exclude groupExclusions here
        freqMap.set(val, (freqMap.get(val) || 0) + 1);
      }
    }
  }

  // Sort the objects based on the frequency of the specified position
  arr.sort((a, b) => {
    let sublocsA = a.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc));
    let sublocsB = b.sublocations.filter(loc => !documentSetting.groupExclusions?.includes(loc));

    if (sublocsA.length <= position || sublocsB.length <= position) {
      return 0; // Objects don't have a value in the specified position, so no need to sort further
    }
    const valA = sublocsA[position].trim();
    const valB = sublocsB[position].trim();
    if (documentSetting.groupExclusions?.includes(valA) || documentSetting.groupExclusions?.includes(valB)) { // Exclude groupExclusions here
      return 0;
    }
    
    const freqA = freqMap.get(valA);
    const freqB = freqMap.get(valB);
    return freqB - freqA; // Sort in descending order of frequency

    while(arr.some(obj => obj.sublocations.length > position + 1)){
      nextPosition = position + 1
      sortByFrequency(arr, nextPosition)
    }
  });

  return arr;
}

const sortBy = {
    "timeOfDayOption": (a,b) => {

        let timeOfDayArray = Object.values(userDefault.timeOfDayObject).reduce((acc, val) => acc.concat(val), []);
        keyA = timeOfDayArray.indexOf(a.timeOfDay)
        keyB = timeOfDayArray.indexOf(b.timeOfDay)
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
    "location": (a,b) => {
        
        let filteredA = a.sublocations.filter(location => !documentSetting.groupExclusions?.includes(location));
        let filteredB = b.sublocations.filter(location => !documentSetting.groupExclusions?.includes(location));

        if(!documentSetting.groupByParenthesis){
            filteredA = filteredA.filter(location => !a.other.includes(location));
            filteredB = filteredB.filter(location => !b.other.includes(location));
        }
   
        keyA = filteredA.join(',')
        keyB = filteredB.join(',')
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
    "prefixOption": (a,b) => {
        keyA = a.prefix.trim()
        keyB = b.prefix.trim()
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
    "prefixTimeOfDay":
    (a,b) => {
        keyA = a.color
        keyB = b.color
        if (keyA < keyB) return -1;
        if (keyA > keyB) return 1;
        return 0
    },
}


function updateScenePanel(){

    if (!$(".scenestab.selectedtab")) return

    parseSceneHeadings()
    return

}

function swapLocationParts(startIndex, endIndex, newText, oldText){

    Beat.call(`
        Beat.replaceRange(${startIndex}, ${endIndex - startIndex}, "${newText}")`
    )

}

function makeLocationToD(item) {

    $$(".item").forEach(el => {if (el.textContent == item.textContent) el.classList.add("highlighted")})

    let text = item.textContent.toUpperCase() 
    let occurences = Array.from($$(".item")).filter(el => el.textContent == text).length

    Beat.callAndWait(([text, occurences]) => {
        let result = Beat.dropdownPrompt(`Do you want to add\n${text} (occurs ${occurences} times)\nto the list of Times-of-Day?`, `Sort ${text} as...`, ["DAY", "NIGHT", "SAME AS PREVIOUS"])
        return result
    }, [text, occurences])
    .then(
        response => {

            let val = response

                if(val == ""){
                    Beat.callAndWait(() => {
                        Beat.alert("Selection needed", "The Scene Manager needs all Time-of-Days to be sorted as one of either DAY, NIGHT or SAME.\n\nPlease make a selection in the dropdown box, or hit cancel to abort.")
                        return "whatever"
                    })
                    .then(
                        response => {
                            makeLocationToD(item)
                        })
                }

                console.log("OK was pressed and returned with the value", val)
                val = val.split(" ")[0] //get only first word if several (to get "SAME" from "SAME AS PREVIOUS")
            
                userDefault.timeOfDayObject[val.toLowerCase()]?.push(text)
                $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
                updateScenePanel()
        },
        error => {
            
            console.log(error)
            console.log("Make Location ToD cancelled (or ran into an error)")
            $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
            
        }
    )
}

function makeTodLocation(item) {

    $$(".item").forEach(el => {if (el.textContent == item.textContent) el.classList.add("highlighted")})

    let text = item.textContent.toUpperCase() 
    let occurences = Array.from($$(".item")).filter(el => el.textContent == text).length

    Beat.callAndWait(([text, occurences]) => {
        let result = Beat.confirm(`This will remove\n${text}\nfrom the list of Times-of-Day. \n\nGo ahead?`, `${text} currently occurs ${occurences} times in your sceneheadings. Removing it from the list will treat it as a location, and sceneheadings ending with ${text} will be considered having no Time-of-day.`)
        
            return JSON.stringify(result)
    }, [text, occurences])
    .then(
        response => {

            if (response == "false") return

            for (key in userDefault.timeOfDayObject) {
                userDefault.timeOfDayObject[key] = userDefault.timeOfDayObject[key].filter(item => item !== text)
            }

            $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
            updateScenePanel()
        },
        error => {
            
            console.log(error)
            console.log("Make Location ToD cancelled (or ran into an error)")
            $$(`.item.highlighted`).forEach(el => el.classList.remove("highlighted"))
            
        }
    )
}

function deselectAllScenepanelItems(){

    $$('.item.isSelected, .item.highlighted').forEach(element => {
        element.classList.remove('isSelected');
        element.classList.remove('highlighted');
    })

}

function setScrollShadow(){

    // let myDiv = $id("scenespanelcontent")
    let myDiv = event.target

    if (myDiv.scrollTop > 0) {
        myDiv.classList.add('scrolled');
    } else {
        myDiv.classList.remove('scrolled');
    }


}

</script>

<style>

#scenespanelbuttons{

    display: flex !important;
    align-items: center;

    font-weight: bold;
    color: hsla(var(--paperBehindInk), 1);

    padding-top: 1px;
    
}

/* :has(.scenestab:not(.selectedtab)) #scenespanelbuttons{ */
:not(:has(.scenestab.selectedtab)) #scenespanelbuttons{
    
    display: none !important;

}
    

#scenespanelbuttons > *{
    vertical-align: middle;
}

#sortDropDown{
    color: black !important;
}

#checkboxSpan {

    position: relative;

    display: inline-block;
    vertical-align: middle;
    margin-left: 3px;
    margin-right: 52px;

    white-space: nowrap !important;
    overflow: hidden;
    /* text-overflow: ellipsis; */

    flex-grow: 1;
    flex-shrink: 1;

    
    & label{
    
        position: relative;
        display: inline-block;
        
        /* outline: 1px solid lime;  */
        text-overflow: ellipsis !important;
        /* overflow: hidden !important; */
        white-space: nowrap !important;
    }

}

#mergeSimilarLocations, #mergeSimilarLocations + label{

    position: relative;

    margin-left: 2px;
    margin-right: 0px;
    display: none;
    font-weight: normal;
    white-space: nowrap !important;
    
    &:is(:has(#sortDropDown.location) #mergeSimilarLocations),
    &:is(:has(#sortDropDown.location) #mergeSimilarLocations + label){
        display: inline-block;
    }
}

#onlyShowTypos, #onlyShowTypos + label{

    position: relative;

    margin-left: 2px;
    margin-right: 0px;
    display: inline-block;
    font-weight: normal;
    white-space: nowrap !important;

    /* &:is(:has(#sortDropDown.location) #onlyShowTypos),
    &:is(:has(#sortDropDown.location) #onlyShowTypos + label){
        display: inline-block;
    } */
}

#onlyShowTypos{
    margin-left: 10px;
    margin-right: 0px;
}

#scenepanelSettingsButton{

    position: absolute;
    right: 8px;
    top: 2px;
    width: 16px;
    height: 16px;
    
    display: inline-block;
    font-weight: normal;

    /* &:is(:has(#sortDropDown.location) #scenepanelSettingsButton){
        display: inline-block;
    } */

}

#scenepanelHelpButton{

    position: absolute;
    right: 28px;
    top: 2px;
    width: 16px;
    height: 16px;

    font-size: 10px;
    text-align: center;
    
    display: inline-block;
    font-weight: normal;

    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 50%;

    color: black;
    background: white;
    opacity: 0.4;

        &:hover{
            opacity: 1;
            cursor: pointer;
        }

    /* &:is(:has(#sortDropDown.location) #scenepanelSettingsButton){
        display: inline-block;
    } */

}

#scenespanelcontent{

    --scenesPanelLeftColumnWidth: 120px;

    background: #888 !important;

    position: absolute;
    width: calc(100% + 3px);
    height: calc(100% - 48px);
    margin-left: -8px;
    margin-right: -4px;
    padding: 8px !important;
    padding-top: 0px !important;
    padding-right: 12px !important;
    overflow-x: hidden;
    overflow-y: auto;
    text-overflow: ellipsis;

    /* white-space: pre !important; */
    font-size: calc(11px * var(--fontSizeFactor));
    font-weight: bold;
    color: white;

    border-bottom-right-radius: 10px;

    /* border-top: 2px groove #555 !important; */

    &::xx.after{

        content: "";
        position: fixed;
        top: 0px;
        left: 0;
        width: calc(100% - 8px);
        margin-left: 4px;

        border-top: 2px groove #555 !important;
    }

    & #dividerline{        
        
        position: fixed;
        top: 60px;
        left: calc(var(--scenesPanelLeftColumnWidth) + 12px);
        height: calc(100% - 110px);
        width: 4px;

        opacity: 0;
        border-right: 2px solid red;

        z-index: 999999;
        
        &:hover{
            opacity: 0;
            cursor: col-resize;
            /* transition: opacity 1s 0.5s; */
        }
    }
    
    &:has(#dividerline:hover) .leftColumn{
        
        border-right: 0.5px solid rgba(0, 0, 0, 0.9);
        transition: border 1s 0.5s;
        box-shadow: 1px 0 0 0 rgba(255, 255, 255, 0.7),
                    -1px 0 0 0 rgba(0, 0, 0, 0.7) inset;

    }

    &.dragging *{

        cursor: col-resize !important;
    }

    & .scenepanelgroup{

        position: relative;

        border: 3px solid rgba(255, 255, 255, 0.6);
        border-radius: 12px;
        /* margin-top: 2px;
        margin-bottom: 33px; */
        background-color: #555;

        margin-top: 4px;
        margin-bottom: 8px;

        overflow: hidden;

        &:empty, &:has(.groupHeadline:empty){
            display: none;
        }

        padding-top: 26px;
        box-shadow: inset 0 26px 0 0px rgba(255, 255, 255, 0.6);

        &.singlegroup{
            /* border-color: rgba(220, 100, 100, 0.6) !important;
            box-shadow: inset 0 26px 0 0px rgba(220, 100, 100, 0.6); */
            border-color: var(--singlegroupColor) !important;
            box-shadow: inset 0 26px 0 0px var(--singlegroupColor);
        }

    }

    & .groupHeadline{

        text-align: center;
        width: 100%;
        padding: 0px 10px;
        /* outline: 1px solid orange; */

        position: absolute;
        /* left: 15px !important; */
        top: 5px !important;
        font-weight: normal;
        color: black;

        overflow: hidden;
        text-overflow: ellipsis;

        & strong{
            font-weight: bold;
        }

    }

    & .leftColumn{

        position: relative;
        left: 0;
        top: 0;

        width: var(--scenesPanelLeftColumnWidth) !important;
        display: inline-block;
        vertical-align: top;
        height: auto !important;

        padding: 0 4px 0 0;
        margin: none;

        border-right: 0.5px solid rgba(0, 0, 0, 0.4);

        overflow: hidden;
        white-space: nowrap;

        /* &:is(:has(.isDouble) .leftColumn){
            text-align: right;
        } */

        transition: height 0.5s !important;

        &:is(:has(#sortDropDown.location):has(#mergeSimilarLocations:checked) .leftColumn){

            width: var(--scenesPanelLeftColumnWidth) !important;
            white-space: normal;
        }
        
        & .flexdiv{

            width: var(--scenesPanelLeftColumnWidth);

            display: flex;
            /* flex-direction: row; */
            justify-content: flex-start; /* space-between; */
            align-items: stretch;
            /* height: 100%; */
            
            &:is(:has(#sortDropDown.location):has(#mergeSimilarLocations:checked) .flexdiv){
                
                flex-wrap: wrap;
                justify-content: end !important;

            }

        }

    }
    
    & .item{

        width: auto;
        height: calc(11px * var(--fontSizeFactor) + 4px);
        line-height: calc(12px * var(--fontSizeFactor));
            
        display: inline-block;
        padding: 2px 6px 2px 6px;
        
        box-shadow: inset 0.5px 0.5px 0px 0.5px rgba(255, 255, 255, 0.4),
                    inset -0.5px -0.5px 0px 0.5px rgba(0, 0, 0, 0.4);

        border-radius: none;
        border: none;
        vertical-align: middle;

        overflow: hidden;
        opacity: 1;

        /* transition: width 0s, height 0.5s, opacity 0.5s !important; */
        
    }

    & .item.isSelected:not(.highlighted), & .item:hover{
        background-image: linear-gradient(rgba(0,0,0, 0.7), rgba(0,0,0,0.7)) !important;
        color: white !important;
    }


    & .leftItem,
    & .rightItem {

        margin-left: 0px;
        margin-right: 0px;

    }

    & .leftItem:not(.leftItem:not(.isDouble) + .leftItem),
    & .rightItem:not(.rightItem:not(.isDouble) + .rightItem) { /* first item */

        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;

    }

    & .leftItem:not(:has( + .leftItem:not(.duplicateSceneNum))),
    & .rightItem:not(:has( + .rightItem:not(.duplicateSceneNum))) { /* last item */

        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;

    }

    & .sceneNum{

        color: black;
        background-color: lightcoral;

        text-align: right;
        padding-left: 8px;
        border-radius: 10px 0 0 10px !important;

        flex-shrink: 0;

        transition: border-radius 1.5s, height 0.5s 0s, width 0.5s 0.0s, opacity 0.4s 0.1s !important;

        &:is(:has(.isDouble):has(#mergeSimilarLocations:checked) .sceneNum){
            padding-right: 8px;
            border-radius: 10px !important;
        }

    }

    & .prefix{

        color: black;
        background-color: lightcoral;

        text-align: center;

        flex-shrink: 0;

        transition: border 0s, height 0.5s 0s, width 0.0s 0.0s, opacity 0.4s 0.1s !important;

    }

    & .timeOfDay{

        color: black;
        background-color: lightcoral;

        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;

        text-align: left;

        max-width: 100%;

        flex-grow: 1;

        transition: border 0s, height 0.5s 0s, width 0.0s 0.5s, opacity 0.4s 0.1s !important;

    }

    & .location{

        position: relative;
        background-color: hsl(200, 40%, 30%);
        transition: height 0.5s 0s, width 0.5s 0s, opacity 0.4s 0.1s !important;

        text-overflow: ellipsis;

        z-index: 9999;
        
        &:not(.location + .location){ /* first item of class location */

            margin-left: 4px;

        }

        &.similarLocation:not(.excludedLocation){

            background-color: hsl(40, 70% , 40%);
            color: white;
            font-weight: bold;

            &.majority{
                /* background-color: hsl(135, 60%, 40%); */
                background-color: hsl(90, 40%, 30%);
                color: white;
                font-weight: bold;
            }
            &.minority{
                /* background-color: hsl(135, 60%, 40%); */
                background-color: hsl(0, 60%, 30%);
                color: white;
                font-weight: bold;
            }
        }

        &.highlighted{
            /* background-color: hsl(40, 60%, 50%) !important; */
            
            background-color: white !important;
            color: black !important;
            box-shadow: inset 0 0 0 1px black !important;

        }

        &.excludedLocation{
            /* border-bottom: 2px solid hsl(80, 61%, 50%); */
            background-image: linear-gradient(to top, yellowgreen 0px, yellowgreen 2.5px, transparent 2.5px) ;
        }

        &.dontCompare{
            
            opacity: 0.4 !important;
        }

    }    
}

#notepanelcontent::before,
#scenespanelcontent::before {
        
        content: "";
        display: block;
        opacity: 0;
        
        z-index:99999;
        
        position: sticky;
        top: 0;
        left: -10px;
        width: 1000px !important;
        height: 50px !important;
        margin-bottom: -50px !important;
        
        box-shadow: inset 0 30px 30px -30px rgba(0, 0, 0, 0.7);
        
        pointer-events: none;

    }

#notepanelcontent.scrolled::before,
#scenespanelcontent.scrolled::before {
        opacity: 1;
    }

.line{

    position: relative;
    display: block;   
    height: auto !important;

    line-height: 0;

    border-radius: 0;
    padding: 2px 6px;
    margin: 0px !important;

    border-top: 0.5px solid rgba(0, 0, 0, 0.6);

    transition: padding 0.5s, border 0.2s, height 0.5s, opacity 0.5s !important;

    /* &:not(:has(#mergeSimilarLocations:checked) .hideWhenMergeIsChecked):nth-of-type(even){ */
    /* &:not(.hideWhenMergeIsChecked):nth-of-type(even of :not(.hideWhenMergeIsChecked)){ */
    &.even{
        background: rgba(255, 255, 255, 0.45);
        
        &:not(.even + .even){
            border-top: 0.5px solid black;
        }
    }
    /* &:not(:has(#mergeSimilarLocations:checked) .hideWhenMergeIsChecked):nth-of-type(odd){ */
    /* &:not(.hideWhenMergeIsChecked):nth-of-type(odd of :not(.hideWhenMargeIsChecked)){ */
    &.odd{
        background: rgba(255, 255, 255, 0.35);

        &:not(.odd + .odd){
            border-top: 0.5px solid black;
        }
    }

    &.newgroup,
    &:first-child{
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
    }
    &:has(+ .newgroup),
    &:last-child{
        /* border-bottom: 1px solid rgba(0, 0, 0, 0.6); */
        border-bottom-left-radius: 10px;
        border-bottom-right-radius: 10px;
    }
}

.pagesForLine {

    z-index: -9999 !important;

}

.pagesForLine *{
        position: absolute;
        right: 0;
        top: 0;
        padding: 4px 6px !important;

        font-size: calc(9px * var(--fontSizeFactor));
        line-height: calc(12px * var(--fontSizeFactor));
        font-weight: normal;
        color: white;

    }

.isDouble .multiplePageCount{
    display: none !important;
}

:not(:has(#mergeSimilarLocations:checked)) .multiplePageCount,
:has(#mergeSimilarLocations:checked) .pagesForLine .singlePageCount{
            
    opacity: 0 !important;
    transition: opacity 0.6s 0.0s !important;

}

:has(#mergeSimilarLocations:checked) :not(.line.isDouble) > .multiplePageCount,
:not(:has(#mergeSimilarLocations:checked)) .singlePageCount {

    opacity: 0.7 !important;
    transition: opacity 0.5s 0.1s !important
}

:has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .item, 
/* :has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .leftColumn,  */
:has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .timeOfDay, 
:has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .prefix{

        min-height: 0px !important; 
        min-width: 0px !important;
        height: 0px !important; 
        width: 0px !important;
        margin: -2px 0 !important;
        padding: 0px !important;
        border: none !important;
        border-width: 0px !important;
        overflow: hidden;
        opacity: 0 !important;

        flex-grow: 0 !important;
        flex-shrink: 0 !important;
        
        /* float: right !important; */

        /* transition: height 0.5s, opacity 0.5s !important;     */

}

.duplicateSceneNum{

    --sceneNumWidth: 0px;

    display: inline-block;
    opacity: 1 !important;
    width: var(--sceneNumWidth);

    border-radius: 10px !important;

    transition: border-width 0.5s 0.5s, width 0.5s 0.0s, height 0.5s 0s, opacity 0.4s 0.1s !important;


    &:not(:has(#mergeSimilarLocations:checked):has(#sortDropDown.location) .duplicateSceneNum){
        
        height: 0px !important;
        width: 0px !important;
        /* max-width: 0px !important; */
        margin: 0px !important;
        padding: 0px !important;
        opacity: 0 !important;
        color: transparent;

        transition: width 0.0s 0s, height 0.5s 0s, opacity 0.4s 0.1s !important;


    }

}

:has(#mergeSimilarLocations:checked):has(#sortDropDown.location) .hideWhenMergeIsChecked.line{
        
        min-height: 0px !important; 
        min-width: 0px !important;
        height: auto !important;
        padding: 0px !important;
        border: none !important;
        border-width: 0px !important;
        margin: 0px !important;

        transition: padding 0.5s, border 0.2s, height 0.5s, opacity 0.5s !important;

    }

    :has(#mergeSimilarLocations:checked):has(#sortDropDown.location) /*.hideWhenMergeIsChecked*/ .innerdiv{

        white-space: normal !important;

    }

/* :has(#sortDropDown.location):not(:has(#mergeSimilarLocations:checked)){

        & #scenespanelcontent .duplicateSceneNum{
            height: 0px !important; 
            width: 0px !important;
            margin: 0px !important;
            padding: 0px !important;
            border: 0px !important;
            opacity: 0;

            transition: opacity 0.5s;
            transition-delay: height 0.5s, width 0.5s, margin 0.5s, padding 0.5s;
        }
 
} */


:has(#onlyShowTypos:checked) :is(.line, .scenepanelgroup):not(:has(.similarLocation:not(.excludedLocation))){

    display: none;

}

/* :has(#onlyShowTypos:checked) .groupHeadline:is(){

    display: none;

} */


html[data-outdoors="1"] #scenespanelbuttons{

    color: black !important;

    & *{
        color: black !important;
        border-color: black !important;
        fill: black !important;
    }

}

html[data-outdoors="1"] #scenespanelcontent{

    background: white !important;

    & .item{

        /* box-shadow: inset 0 0 0 1px black; */
        border: 1px black solid;
        padding-top: 1px !important;
        box-shadow: none !important;

        /* margin-bottom: 1px; */

    }

    & .scenepanelgroup{

        /* border-color: #ddd; */
        outline: 1px solid black;
        background: #ddd;
        
    }

    & .line{

        border: 1px 1px 0px 1px solid black !important;
        /* padding-bottom: 1px; */

    }

    & .location{

        background-color: #fff;
        color: black;

        /* &:hover, &.highlighted{
            color: white !important;
        } */

        &.highlighted{
            background-color: black !important;
            color: white !important; 
        }
    }

    & .pagesForLine *{

        font-weight: bold;
        color: black !important;

    }


}

</style><style>

.menu{

    position: absolute;
    background: rgb(232, 232, 232);
    
    border: #c1c1c1 solid 1px;
    border-radius: 10px;

    font-size: 14px;
    white-space: nowrap;

    width: auto; /*200px;*/
    height: auto; /* 400px;*/
    min-width: 250px;
    max-width: 280px !important;
    min-height: 100px;

    box-shadow: 0px 5px 30px rgb(0,0,0,0.7);

    transform: translateY(calc(-100% - 10px));
    z-index: 99999

}

:is(.menu, .modal) .name{

    background: #bbb;
    color: white;
    font-weight: 700;
    text-align: center;
    display: block;
    width: calc(100% + 20px);

    margin-top: -10px;
    padding-top: 4px;
    margin-left: -10px;
    padding-left: 16px;

    padding-right: 10px;

    margin-bottom: 7px;
    padding-bottom: 4px;

    border-radius: 9px 9px 0 0 ;

}

:root{

    --pointer-placement: 15%;
}

:is(.menu, .modal) strong {

    font-weight: 700;
    padding-top: 16px !important;
    padding-left: 6px;

}

:is(.menu, .modal) .shortcut{

    float: right;

    padding-left: 10px !important;
    letter-spacing: 2px;

    opacity: 0.5;

    font-style: none !important;
    font-size: inherit !important;
    line-height: inherit !important; 

    white-space: pre !important;

    pointer-events: none;

}

.menu::before,
.menu::after{

    position: absolute;
    content: "";
    box-sizing: border-box;
    
    bottom: -11px;
    left: var(--pointer-placement);

    width: 20px !important;
    height: 20px !important;
    
    border-left: 10px #c1c1c1 solid;
    border-top: 10px #c1c1c1 solid;
    border-right: 10px transparent solid;
    border-bottom: 10px transparent solid;
    border-radius: 2px 0 0 0;
    
    opacity: 0.95;

    transform: rotate(-135deg);
}

.menu::after{

    border-left-color: #e8e8e8;
    border-top-color: #e8e8e8;

    transform: rotate(-135deg) translate(1px, 1px);

}

.menuContents{

    padding: 10px;

    white-space: nowrap;
    width: auto;
    height: auto;

    overflow: hidden;

    text-align: left;
}

:is(.menu, .modal) ul,
:is(.menu, .modal) label,
:is(.menu, .modal) input,
:is(.menu, .modal) .shortcut
/* .menu .select */
 {

    margin: unset;
    padding: unset;

    line-height: normal;
    white-space: nowrap;

}

.colorDropdown, 
#sortDropDown,
#allDialogFor {

        -webkit-appearance: none !important;
        appearance: none !important; 

        width: 100% !important;
        height: auto !important;

        border: none !important;
        background-color: transparent !important; 
        background-image: transparent !important;

        color: inherit;
        opacity: inherit;

        padding: unset !important;
        margin: 0 !important;
        max-width: unset !important;

        padding: 3px 3px 3px 24px !important;

        font-size: 14px !important;
        font-family: inherit !important;
        font-weight: inherit !important;
        /* color: #1c87c9; */
        border-radius: 3px !important;
        /* box-shadow: 4px 4px #ccc; */

      }

#sortDropDown,
#allDialogFor{

    /* width: unset !important;
    background: unset !important; */

    /* width: auto !important; */
    font-weight: bold !important;
    font-size: 12px !important;

    text-overflow: ellipsis;
    padding: 0px 20px 0px 8px !important;
}

#sortDropDown:focus,
#allDialogFor:focus{
    outline: none !important;
}

.colorDropdown:hover,
#sortDropDown:hover,
#allDialogFor:hover{
    color: white
}

.colorDropdown option,
#sortDropDown option,
#allDialogFor option{
    font-size: 14px !important;
    line-height: 26px !important; 

    color: inherit !important;
    opacity: inherit !important;
    
        font-family: inherit !important;
        font-weight: inherit !important;
    }

#sortDropDown option,
#allDialogFor option{

    font-weight: bold !important;

}
    

#scenespanelbuttons .hasSelect,
#dialogpanelbuttons .hasSelect,
:is(.menu, .modal) select:focus{
    outline: none;
    font-weight: normal;
    
}

#scenespanelbuttons .hasSelect,
#dialogpanelbuttons .hasSelect{
    
    overflow: hidden !important;

}

:is(.menu, .modal) .label{

    position: relative;
    display: inline;
    white-space: normal;

}

:is(.menu, .modal) strong + .shortcut{
    padding-right: 6px;
}

:is(.menu, .modal) li{

    display: block;
    white-space: nowrap;
    width: auto;

    padding: 4px 6px !important;
    border-radius: 4px;

}

:is(.menu, .modal) li:hover {

    background-color: #027aff;
    color: white

}

/* .menu li:has(select), */
:is(.menu, .modal) li.hasSelect{
    padding: 4px 6px 0px 4px !important;
    line-height: 10px !important;
    position: relative;
    background: rgba(206,206,206);
}

#scenespanelbuttons .hasSelect,
#dialogpanelbuttons .hasSelect{

    position: absolute;

    padding: 0px !important;
    margin-top: 1px !important;
    height: 17px !important;
    width: auto !important;
    max-width: 45% !important;
    
    font-size: 10px;
    top: 0px; 
    left: 0px;
    line-height: 1px !important;
    font-weight: bold;
    background: rgba(206,206,206);
    border-radius: 4px;

}

#sortDropDown  option,
#allDialogFor  option{

    font-weight: normal !important;

}

#sortDropDown:checked,
#sortDropDown:focus:checked,
#allDialogFor:checked,
#allDialogFor:focus:checked{

    font-weight: bold !important;

}

/* .menu li:has(select)::after, */
#scenespanelbuttons .hasSelect::before,
#scenespanelbuttons .hasSelect::after,
#dialogpanelbuttons .hasSelect::before,
#dialogpanelbuttons .hasSelect::after,
:is(.menu, .modal) li.hasSelect::before,
:is(.menu, .modal) li.hasSelect::after{
    content: " ";

    white-space: pre;
    position: absolute;
    right: 4px;
    top: 2px; /*was2*/
    font-size: 10px !important;
    line-height: 8px !important;

    border-left: 2px solid black;
    border-top: 2px solid black;
    width: 4px !important;
    height: 4px !important;
    transform: rotate(45deg) translate(0px, 6px);

    pointer-events: none;

}

#scenespanelbuttons .hasSelect::after,
#dialogpanelbuttons .hasSelect::after,
:is(.menu, .modal) li.hasSelect::after{

    border-left: none;
    border-top: none;
    border-right: 2px solid black;
    border-bottom: 2px solid black;

    transform: rotate(45deg) translate(4px, 10px); /*was 4, 10*/

}

#scenespanelbuttons .hasSelect::before,
#scenespanelbuttons .hasSelect::after,
#dialogpanelbuttons .hasSelect::before,
#dialogpanelbuttons .hasSelect::after{

    scale: 0.8;
    translate: 0 -2px;

}

/* #scenespanelbuttons .hasSelect:not(:has(.menuitem))::before,
#scenespanelbuttons .hasSelect:not(:has(.menuitem))::after, */
#dialogpanelbuttons .hasSelect:not(:has(.menuitem))::before,
#dialogpanelbuttons .hasSelect:not(:has(.menuitem))::after{

    display: none;

}


#scenespanelbuttons .hasSelect:hover::before,
#scenespanelbuttons .hasSelect:hover::after,
#dialogpanelbuttons .hasSelect:hover::before,
#dialogpanelbuttons .hasSelect:hover::after,
:is(.menu, .modal) li.hasSelect:hover::before,
:is(.menu, .modal) li.hasSelect:hover::after{
    
    border-color: white !important;

}


/* .menu li:hover > .toggle > .switch{
    background: #027aff !important;
} */



:is(.menu, .modal) .centered{
    /* text-align: center !important; */
    display: flex !important;
    flex-direction: row;
    /* justify-content: center; */
    justify-content: center;
    /* border: 1px blue dotted;  */
}

:is(.menu, .modal) .centered > * {

    flex-grow: 1;
    flex-basis: 0;

    /* outline: red 1px dotted */
}

/* .menu .toggle{
    width: 100%;
    text-align: center;
} */

:is(.menu, .modal) .radio{

    flex-grow: 0 !important;
    flex-basis: auto !important;
    
    display: inline-block;
    position: relative;
    /*float: left;*/
    width: 22px;
    height: 22px;
    border-radius: 999px;
    border: 1px solid silver; 
    background: white;
    margin: 0 5px -6px 5px;

    transform: translateY(-1px);

    pointer-events: none;

}

:is(.menu, .modal) input:checked + .radio {
    background-color: black;
}

/* .menu input:checked + .radio::before{

    content: " ";

    position: absolute;
    left: 1px;
    top: 1px; 

    width: 16px;
    height: 16px;
    border: 1px silver solid !important;
    border-radius: 999px;
    background-color: black;

} */

:is(.menu, .modal) input:checked + .radio::after{

content: " ";

position: absolute;
left: 4px;
top: 4px; 

width: 12px;
height: 12px;
/* border: 1px silver outset !important; */
border-radius: 999px;
background-color: #eee;
box-shadow: inset 0px 0px 4px white,
    inset -1px -1px 1px #999
;

}

:is(.menu, .modal) .switch{

    flex-grow: 0 !important;
    flex-basis: auto !important;
    
    display: inline-block;
    position: relative;
    /*float: left;*/
    width: 36px;
    height: 20px;
    border-radius: 18px;
    border: 1px solid silver; 
    margin: 0 5px -6px 5px;

    transform: translateY(-1px);

    pointer-events: none;

    /* line-height: 12px !important; */

}
:is(.menu, .modal) .switch::before{

    position: absolute;
    top: -2px;

    content: "";
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 1px solid silver;
    background: white;
    box-shadow: 0px 0px 4x rgba(0, 0, 0, 0.3);


}

:is(.menu, .modal) input{
    flex-grow: 0 !important;
    opacity: 0;
    width: 0px !important;
    height: 0px !important;
    overflow: hidden;

    /* line-height: 14px !important; */
}

:is(.menu, .modal) input:not(:checked) + .switch::before,
:is(.menu, .modal) input:not(:checked) + label + .switch::before{
    
    left: -1px;

}

:is(.menu, .modal) input:checked + .switch::before,
:is(.menu, .modal) input:checked + label + .switch::before{

    right: -1px;
}

:is(.menu, .modal) input:indeterminate + .switch::before,
:is(.menu, .modal) input:indeterminate + label + .switch::before{

    left: 9px;
    top: 1px;
    opacity: 0.6;
    height: 14px;
    width: 14px;

}

:is(.menu, .modal) input:checked + .switch,
:is(.menu, .modal) input:checked + label + .switch{
    background: #333;
}

:is(.menu, .modal) hr{
    opacity: 0.5;
}

.labelBefore{
    display: unset;
    width: unset; 
    text-align: right;
    padding-right: 6px !important; 
    /* width: 50% !important;
    border: magenta 1px dotted*/
} 

.labelAfter{
    display: unset;
    width: unset; 
    text-align: left;
    padding-left: 6px !important; 
    /* width: 50% !important;
    border: magenta 1px dotted */
}

.switch + label,
label:has(+.switch) {
    
    pointer-events: none;
}

.greyedout {
    opacity: 0.2;
    pointer-events: none;
}

.willFold {

    opacity: 0.2;
    pointer-events: none;

}

.menu:has(#buttonForIndexCards:checked) .willFold,
.menu:has(#buttonForFixed:checked) .willFold{

    pointer-events: all;
    opacity: 0.95;


}

.menu:has(#buttonForFlexible:checked) .willFold{

/* height: 0px;
opacity: 0;
overflow: hidden;
margin: 0;
padding: 0; */

opacity: 0.2;
pointer-events: none;

/* height: 0px;
margin: 0px;
padding: 0px;
overflow: hidden; */

}

/* .menu:has(#buttonForFlexible:checked) hr.willFold{
    display: none
} */


:is(.menu, .modal) .hint {

opacity: 0.6;
padding-top: 6px !important;
padding-left: 4px !important;

font-size: 10px;
line-height: 12px !important;
font-style: italic;

white-space: normal;
pointer-events: none;


}


@media (prefers-color-scheme: dark) {

    :root{

        --menu-background: rgb(40,40,40);
        --menu-border-color: rgb(81,81,81);
        --menu-color: rgb(233,233,233);

        --inkOnPaper: 0, 0%, 100%;
	    --paperBehindInk: 0, 0%, 0%;

    }

    .menu  { 
    background:  rgb(40, 40, 40); 
    color: rgb(233,233,233); 
    border-color: rgb(81,81,81);


    box-shadow: 0px 5px 30px rgb(0,0,0,0.7),
    0px 0px 0px 0.5px rgb(0,0,0,1);


    }
    .menu .name{
        background-color: #444;
    }

    .menu::before{
        border-left-color: var(--menu-border-color);
        border-top-color: var(--menu-border-color)
    }
    .menu::after{
        border-left-color: var(--menu-background);
        border-top-color: var(--menu-background)
    }
    .menu input:checked + .switch,
    .menu input:checked + label + .switch{
        background: #555;
    }

    /* .menu li:has(select), */
    .menu li.hasSelect{
        background: #555;
    }

    .contextMenu {
        background: rgba(40,40,40,0.9);
        color: var(--menu-color);
        border-color: var(--menu-border-color);
    }
    .contextMenu li,
    .contextMenu li svg{
        color: var(--menu-color) !important;
        fill: var(--menu-color) ;
    }

    #-------------DIALOGS{}

    .settingsWindow{

        background:  rgb(40, 40, 40); 
        color: rgb(233,233,233); 
        border: 1px rgb(81,81,81) solid !important;

    }

    .generalButtonStyle {
        border: 1px #222 solid !important;
        /* box-shadow: 1px 1px 2px #ccc; */
        background-color: #555 !important;

        color: white !important;
    }

    .generalButtonStyle:hover {	
        background: #027aff !important;
        color: white !important
    }

    select{
        border: 1px #222 inset !important;
        background: #555 !important;
        color: white;
    }

    option:nth-of-type(even){
        background: #444;
    }


}

</style>

<script>

function toggleNewMenu(whichOne){

    mylog("=============")
    mylog("toggleNewMenu")
    mylog("=============")

    theClickedThing = event.target

    mylog(theClickedThing.classList)

    if ($id("menu")){

        if($id("menu").firstChild.id == whichOne){
            closeNewMenu()
            return
        }
        closeNewMenu()
    }

    toggleTrackingContainer(true) // closes all dialogs
    showNewMenu(theClickedThing, whichOne)

}

function showNewMenu(theClickedThing, whichOne){

    mylog("showNewMenu")

    let button = theClickedThing?.getBoundingClientRect() || $id("indexCardButton").getBoundingClientRect()

    // let area = $id("flexiContainer").getBoundingClientRect()

    if($id("menu")){$id("menu").remove()}
    if (trackingContainerVisibility == 1){toggleTrackingContainer()}
	if (helpContainerVisibility == 1){toggleHelpContainer()}

    menu = document.createElement("div")
    menu.id = "menu"
    menu.classList.add("menu")
    if (button.right > window.innerWidth / 2){
        menu.style.right = (window.innerWidth - button.right - 15) + "px"
        theRoot.style.setProperty("--pointer-placement", "85%")
    }else{
        menu.style.left = (button.x - 15) + "px"
        theRoot.style.setProperty("--pointer-placement", "7%")
    }
    menu.style.y = (button.y) + "px"

    document.body.appendChild(menu)
    $id("cover").style.display = "block"
    $id("cover").style.backgroundColor = "transparent"

    fillNewMenu(whichOne)
    setAllButtons()
}

function fillNewMenu(whichOne){

    switch (whichOne) {
        case "indexCardMenu":
            indexCardMenu()
            break;
        case "showStuffMenu":
            showStuffMenu()
            break;
        case "notesMenu":
            notesMenu()
            break;
        case "zoomMenu":
            zoomMenu()
            break;
        case "settingsMenu":
            settingsMenu()
            break;
        case "exportMenu":
            exportMenu()
            break;
        case "trackingMenu":
            trackingMenu()
            break;
        default:
            break;
    }
}

function closeNewMenu(){

    if($id("menu")){
        $id("menu").remove()    
    }
    $id("cover").style.display = "none"

}

function indexCardMenu(){

    menu1 = document.createElement("div")

    menu1.id = "indexCardMenu"
    menu1.classList.add("menuContents")

    test = `</div><div>`

    menu1.innerHTML = /*html*/`
        <ul>
            <p class="name">Outline Menu</p>

            <strong>Outline Mode: </strong>
            <li onclick="toggleProportional(true); 
                $id('liForExpandedScenes').classList.toggle('greyedout', documentSetting.scenesAreProportional && !documentSetting.indexCardMode);
                $id('liForExpandedSections').classList.toggle('greyedout', !documentSetting.indexCardMode);"
                >
		        <input id="buttonForFlexible" type="checkbox">
                <div class="radio"></div><!--was class switch!-->
                    <label for="buttonForFlexible" style="pointer-events: none">
                        Flexible Time<span class="shortcut">F</span>
                    </label>
            </li>

            <li onclick="toggleProportional(false);
                $id('liForExpandedScenes').classList.toggle('greyedout', documentSetting.scenesAreProportional && !documentSetting.indexCardMode);
                $id('liForExpandedSections').classList.toggle('greyedout', !documentSetting.indexCardMode);
                $id('strongForExpandedScenes').classList.toggle('greyedout', documentSetting.scenesAreProportional && !documentSetting.indexCardMode);
                $id('strongForExpandedSections').classList.toggle('greyedout', !documentSetting.indexCardMode);"
                >
		        <input id="buttonForFixed" type="checkbox">
                <div class="radio"></div>
                    <label for="buttonForFixed" style="pointer-events: none">
                        Fixed Heights<span class="shortcut">F</span>
                    </label>
            </li>

            <li onclick="toggleIndexCardMode(); 
                $id('liForExpandedScenes').classList.toggle('greyedout', documentSetting.scenesAreProportional && !documentSetting.indexCardMode);
                $id('liForExpandedSections').classList.toggle('greyedout', !documentSetting.indexCardMode);
                $id('strongForExpandedScenes').classList.toggle('greyedout', documentSetting.scenesAreProportional && !documentSetting.indexCardMode);
                $id('strongForExpandedSections').classList.toggle('greyedout', !documentSetting.indexCardMode);"
                >
		        <input id="buttonForIndexCards" type="checkbox" >
                <div class="radio"></div>
                    <label for="buttonForIndexCards" style="pointer-events: none">
                        Index Cards<span class="shortcut">X</span>
                    </label>
            </li>

            <hr>

            <strong>Colums:</strong><span class="shortcut" style="float:right">O</span><br/>
            <li class="centered" onclick="toggleOneColumnOutline()">
                <input id="buttonForOneColumn" type="checkbox">
                    <label for="buttonForOneColumn" class="labelBefore" style="pointer-events: none">Single</label>
                        <div class="switch"></div>
                    <label for="buttonForOneColumn" class="labelAfter" style="pointer-events: none">Multiple</label>
            </li>

            <p class="hint">When set to multi, every # starts new column</p>
            <hr>
            <strong id="strongForExpandedScenes" class="${(documentSetting.scenesAreProportional || !$(".scene")) ? `greyedout` : ``}">Expand scenes: </strong><span class="shortcut" style="float:right">E</span><br/>
            <li id="liForExpandedScenes" class="${(documentSetting.scenesAreProportional || !$(".scene")) ? `greyedout` : ``} centered" onclick="anArrowWasClicked($('.arrowForIndexCards'), true)">
                <input id="buttonForExpandedScenes" type="checkbox">
                    <label for="buttonForExpandedScenes" class="labelBefore">None</label>
                        <div class="switch" style="float:none !important; display: inline-block;"></div>
                    <label for="buttonForExpandedScenes" class="labelAfter">All</label>
            </li>
            <hr>
            <strong id="strongForExpandedSections" class="${(!documentSetting.indexCardMode) ? `greyedout` : ``}">Expand sections: </strong><span class="shortcut" style="float:right">D</span><br/>
            <li id="liForExpandedSections" class="${(!documentSetting.indexCardMode) ? `greyedout` : ``} centered" onclick="expandOrCollapseSections()">
                <input id="buttonForExpandedSections" type="checkbox">
                    <label for="buttonForExpandedSections" class="labelBefore">None</label>
                        <div class="switch"></div>
                    <label for="buttonForExpandedSections" class="labelAfter">All</label>
                </li> 

            <hr>
            
            <strong class="${(!$(".boneyard")) ? `greyedout` : ``}">Boneyard: </strong><span class="shortcut" style="float:right">⌘B</span><br/>
            <li class="${(!$(".boneyard")) ? `greyedout` : ``} centered" onclick="addShowHideBoneyard($('.sectionArrow'), true)">
                <input id="buttonForBoneyard" type="checkbox">
                    <label for="buttonForBoneyard" class="labelBefore">Hide</label>
                        <div class="switch"></div>
                    <label for="buttonForBoneyard" class="labelAfter">Show</label>
                </li> 
            <li class="${($(".boneyard")) ? `greyedout` : ``}" onclick="addShowHideBoneyard()">Add Boneyard Act
                    <span class="shortcut" style="float:right">⌘B</span>
                </li>

            <!--p class="hint willFold">Hint: ALT+clicking a scene arrow or section card button will expand/collapse all instead of just the clicked card.</p-->
        </ul>
    `

    $id("menu").innerHTML = ""
    $id("menu").appendChild(menu1)
}

function showStuffMenu(){

    innerMenu = document.createElement("div")

    innerMenu.id = "showStuffMenu"
    innerMenu.classList.add("menuContents")
    innerMenu.innerHTML = /*html*/`
    <ul>    
        <p class="name">View Menu</p>

        <strong>Side Panel: </strong><span class="shortcut" style="float:right"></span><br/>
        <li class="centered" onclick="toggleNotepanel()">
            <input id="buttonForNotePanel" type="checkbox">
                <label for="buttonForNotePanel" class="labelBefore">Closed</label>
                    <div class="switch"></div>
                <label for="buttonForNotePanel" class="labelAfter">Open<span class="shortcut" style="float:right">§</span></label>
        </li>
        <hr>

        <strong>Show info:</strong><br/>

        <li  onclick="toggleShowSceneNumbers()">
            <input id="buttonForNumbers" type="checkbox">
                <div class="switch"></div>  
                    <label for="buttonForNumbers">Scene Numbers<span class="shortcut" style="float:right">S</span></label>
        </li>

        <li onclick="toggleShowPageNumbers()">
            <input id="buttonForPages" type="checkbox">
                <div class="switch"></div>
                    <label for="buttonForPages">Page Numbers<span class="shortcut" style="float:right">P</span></label>
        </li>

        <li onclick="advancedTogglers('showPageDividers', 'buttonForPageDividersTwin'); setAllButtons()">
            <input id="buttonForPageDividersTwin" type="checkbox">
                <div class="switch"></div>
                    <label for="buttonForPageDividersTwin">Pagination<span class="shortcut" style="float:right">^P</span></label>
        </li>
        <li onclick="toggleShowSceneLength()">
            <input id="buttonForLength" type="checkbox">
                <div class="switch"></div> 
                    <label for="buttonForLength">Lengths in Eights<span class="shortcut" style="float:right">L</span></label>
        </li>
        <!--hr>
        <li onclick="zoomSizes('+')">Increase Font Size<span class="shortcut" style="float:right">&#8984;+</span></li>
        <li onclick="zoomSizes('-')">Decrease Font Size<span class="shortcut" style="float:right">&#8984;-</span></li>
        <li onclick="zoomSizes('0')">Reset Font Size<span class="shortcut" style="float:right">&#8984;0</span></li-->

        <hr>
        <!--li ${documentSetting.indexCardMode ? `class="greyedout"` : ``} onclick="toggleMultipleSceneLines()">
            <input id="buttonForSceneLines" type="checkbox">
                <div class="switch"></div> 
                    <label for="buttonForSceneLines">Multiple Scene Lines<span class="shortcut" style="float:right">^L</span></label>
        </li-->
        <li ${documentSetting.indexCardMode ? `class="greyedout"` : ``} onclick="toggleDisplaySynopsis(); $id('liForOnlySynopsis').classList.toggle('greyedout', !$id('buttonForSynopsis').checked)">
            <input id="buttonForSynopsis" type="checkbox">
                <div class="switch"></div> 
                    <label for="buttonForSynopsis">Show Inline Synopsis<span class="shortcut" style="float:right">Y</span></label>
        </li>
        <li id="liForOnlySynopsis" style="padding-left: 30px !important;"
            ${(flexiContainer.classList.contains("showSynopsisInScenes") && !flexiContainer.classList.contains("indexcards")) ? ``: `class="greyedout"`} onclick="flexiContainer.classList.toggle('onlySynopsis'); setAllButtons()">
            <input id="buttonForOnlySynopsis" type="checkbox">
                <div class="switch"></div> 
                    <label for="buttonForOnlySynopsis">...and Hide Slugs<span class="shortcut" style="float:right">^Y</span></label>
        </li>
        
        <hr>
        <strong>Color Scheme: </strong><span class="shortcut" style="float:right; pointer-events: none;">C</span><br/>
            <li class="centered" onclick="toggleColorScheme()">
                <input id="buttonForColors" type="checkbox">
                    <label for="buttonForColors" class="labelBefore">FTOutliner</label>
                        <div class="switch"></div>
                    <label for="buttonForColors" class="labelAfter">Beat</label>
            </li>
        <li onclick="toggleInvertText()">
            <input id="buttonForInverted" type="checkbox">
                <div class="switch"></div>  
                    <label for="buttonForInverted">Invert text on dark shades<!--span class="shortcut" style="float:right">N</span--></label>
        </li>
        <hr>
        <strong>Visual modes:</strong><br/>
        
        
        <li  onclick="outdoorMode(); setAllButtons()">
            <input id="buttonForOutdoor" type="checkbox">
                <div class="switch"></div> 
                    <label for="buttonForOutdoor">High Contrast Mode<span class="shortcut" style="float:right">H</span></label>
        </li>
        <li  onclick="$id('flexiContainer').classList.toggle('greyonly'); setAllButtons()">
            <input id="buttonForGreyOnly" type="checkbox">
                <div class="switch"></div> 
                    <label for="buttonForGreyOnly">All Colors to Grey<span class="shortcut" style="float:right">^C</span></label>
        </li>
    </ul>
`

$id("menu").innerHTML = ""
$id("menu").appendChild(innerMenu)
}

function notesMenu(){

innerMenu = document.createElement("div")

innerMenu.id = "notesMenu"
innerMenu.classList.add("menuContents")
innerMenu.innerHTML = /*html*/`
<ul>    
    <p class="name">Notes Menu</p>
    <strong>Show in Outline:</strong><br/>
    <li onclick="toggleDisplayNotes()">
        <input id="buttonForNotes" type="checkbox">
            <div class="switch"></div>  
                <label for="buttonForNotes">Notes<span class="shortcut" style="float:right">N</span></label>
    </li>
    <li onclick="toggleDisplayMarkers()">
        <input id="buttonForMarkers" type="checkbox">
            <div class="switch"></div>
                <label for="buttonForMarkers">Markers<span class="shortcut" style="float:right">M</span></label>
    </li>
    <li onclick="toggleDisplayReviews()">
        <input id="buttonForReviews" type="checkbox">
            <div class="switch"></div> 
                <label for="buttonForReviews">Reviews<span class="shortcut" style="float:right">R</span></label>
    </li>
    <li onclick="toggleDisplayBeats()">
        <input id="buttonForBeats" type="checkbox">
            <div class="switch"></div> 
                <label for="buttonForBeats">Beats<span class="shortcut" style="float:right">B</span></label>
    </li>
    <hr>
    <li id='cycleNoteForwardMenuItem' onclick="$id('expandedNote')?.focus(); cycleNotes()">Cycle Notes Forward<span class="shortcut" style="float:right">&#8677;</span></li>
    <li id='cycleNoteBackwardMenuItem' onclick="$id('expandedNote')?.focus(); cycleNotes(true)">Cycle Notes Backward<span class="shortcut" style="float:right">&#8679;&#8677;</span></li>
    <hr>
        <li onclick='createDocFromNotes(); closeNewMenu()'>
                <p>All Notes to New Doc
                <span class="shortcut" style="float:right"></span></p>
            </li>
        <li onclick='Beat.call("Beat.custom.sendTextToHTML(); Beat.custom.collectReviews(true)"); closeNewMenu()'>
                <p>All Reviews to New Doc
                <span class="shortcut" style="float:right"></span></p>
            </li>
    </ul>
`

$id("menu").innerHTML = ""
$id("menu").appendChild(innerMenu)
}

function trackingMenu(from){

    if($id("menu").innerHTML == ""){
        $id("menu").innerHTML = "<br/><br/><br/><center>Loading...</center><br/><br/><br/>"
    }
    
    mylog(trackingMenu.caller.name)
    if(trackingMenu.caller.name != "collectCharacters" && trackingMenu.caller.name != "onclick" ){
        // so what we do here is that if the menu just opened, we need to collect the charactes
        // if (!characterMenuList || characterMenuList.length == 0) {
            let redraw = $id("menu").getBoundingClientRect()
            
            iCameFromMenu = true
            collectCharacters()
            return
        }
        
    let characterString = ""
        innerMenu = document.createElement("div")

    if(characterMenuList && characterMenuList.length > 0){

        for(let i = 0; i < Math.min(characterMenuList.length, 9); i++){

            characterString += /*html*/`
            <li onclick="toggleSoloCharacter(${i + 1}); trackingMenu()">
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${characterMenuList[i].value}<span class="shortcut">${i + 1}</span>
                ${characterMenuList[i].selected ? "<span style='float: left; width: 0px; overflow: visible; font-weight: 700'>&check;</span>" : ""}
            </li>
            `
        }
    }else{
        characterString = /*html*/`<li class="centered">(No characters detected)</li>`
    }

    innerMenu.id = "trackingMenu"
    innerMenu.classList.add("menuContents")
    innerMenu.innerHTML = /*html*/`

    <ul>    
        <p class="name">Tracking Menu</p>
        <strong>Quick-filter by top characters:</strong><br/>
        ${characterString}

        <hr>
        
        <li onclick="deselectAllCharacters()">Deselect all characters<span class="shortcut" style="float:right">0</span></li>
        <li onclick="closeNewMenu(); toggleTrackingContainer()">More granular filters...<span class="shortcut" style="float:right">T</span></li>

        <hr>
        <li onclick="toggleIncludeSynopsis()">
            <input id="buttonForIncludeSynopsis" type="checkbox">
                <div class="switch"></div>
                    <label for="buttonForIncludeSynopsis" style="pointer-events: none">
                        Include mentions in Synopsis<span class="shortcut" style="float:right"></span>
                    </label>
        </li>
        <li onclick="toggleExcludeVoiceOvers()">
            <input id="buttonForVoiceOvers" type="checkbox">
                <div class="switch"></div>
                    <label for="buttonForVoiceOvers" style="pointer-events: none">
                        Track (V.O.) etc separately<span class="shortcut" style="float:right"></span>    
                    </label>
        </li>
        <p class="hint">When selected, names with an extension (V.O.), (O.S.) etc are NOT grouped together with the name</p>

        <hr>
            <strong style="padding: 6px">Filter by color:</strong><br/><!--note here!-->
            <li style="padding-top: 0px !important" class="hasSelect">
                <span class="dropDownSpan">
                    <select id="colorDropdown" class="colorDropdown" onchange="simulateAltClick()">
                <option>no colors set</option><option>no colors set</option>
            </select>
                </span>
        </li>
        <p class="hint">SHORTCUT:<br/>Also select color by ALT + clicking on a scene.<br/>ALT + click on an empty space to reset.</p>
    </ul>
    `

    $id("menu").innerHTML = ""
    $id("menu").appendChild(innerMenu)

    {$id("buttonForVoiceOvers").checked = !userDefault.excludeVoiceOvers}
    {$id("buttonForIncludeSynopsis").checked = documentSetting.trackingIncludesSynopsis}

    alsoFillColorDropdown()
}

function zoomMenu(){

    innerMenu = document.createElement("div")

    innerMenu.id = "zoomMenu"
    innerMenu.classList.add("menuContents")
    innerMenu.innerHTML = /*html*/`
    <ul>    
    <p class="name">Zoom Menu</p>

        <li onclick="zoomSizes('+')">Zoom Font Size<span class="shortcut" style="float:right">&#8984;+</span></li>
        
        <li onclick="zoomSizes('-')">Zoom Font Size<span class="shortcut" style="float:right">&#8984;-</span></li>
        
        <li onclick="zoomSizes('0')">Reset Font Size<span class="shortcut" style="float:right">&#8984;0</span></li>
        <hr>
        
        <li ${documentSetting.indexCardMode ? `` : `class="greyedout"`} onclick="changeIndexCardHeight('+')">
            Increase Index Card Size
            <span class="shortcut" style="float:right">^&#8984;+</span></li>
        
            <li ${documentSetting.indexCardMode ? `` : `class="greyedout"`} onclick="changeIndexCardHeight('-')">
            Decrease Index Card Size
            <span class="shortcut" style="float:right">^&#8984;-</span></li>
        
            <li ${documentSetting.indexCardMode ? `` : `class="greyedout"`} onclick="changeIndexCardHeight('0')">
            Reset Index Card Size
            <span class="shortcut" style="float:right">^&#8984;0</span></li>
    </ul>
`

    $id("menu").innerHTML = ""
    $id("menu").appendChild(innerMenu)

}

function openFeedbackWindow(){
    Beat.call("Beat.custom.displaySecondWindow('Feedback', 'feedback.html', width=800, height=800, false)")
}

function openDocumentationWindow(){
    Beat.call("Beat.custom.displaySecondWindow('Documentation', 'documentation.html', width=1200, height=800, false)")
}

function linesWindow(objectToDump, windowTitle){
    
    let sendLines = JSON.stringify(objectToDump)
    Beat.call(([sendLines, windowTitle] ) => Beat.custom.displaySecondWindow(windowTitle, "textDumpWindow.html", 1200, 800, false, sendLines), [sendLines, windowTitle])

}

function settingsMenu(){

    let debugMenuItems = (loggingIsOn || altIsBeingPressed)? 
        /*html*/ `
            <!--hr-->
            <p class="name" style="border-radius: 0; margin-top: 4px; border-top: 1px solid #c44; background: #caa">Debugging Tools</p>
            <strong>Open New Window With:</strong><br/>
            <!--li onclick='Beat.call("Beat.custom.outlineToJSON()")'>
                    <p>Outline as JSON &gt; New Doc
                    <span class="shortcut" style="float:right"></span></p>
                </li>
            <li onclick='Beat.call("Beat.custom.linesToJSON()")'>
                    <p>Lines as JSON &gt; Beat.console
                    <span class="shortcut" style="float:right"></span></p>
                </li-->
            <li onclick='linesWindow(lines, "Lines As JSON")'>
                    <p>Lines As JSON
                    <span class="shortcut" style="float:right"></span></p>
                </li>
            <li onclick='linesWindow(outline, "Outline As JSON")'>
                    <p>Outline As JSON
                    <span class="shortcut" style="float:right"></span></p>
                </li>
            <!--li onclick='linesWindow("{" + logArray.reverse().join("},{"))'-->
            <!--li onclick='linesWindow(logArray.reverse())'-->
            <li onclick='linesWindow(logArray.reverse(), "Current FTOutliner log")'>
                    <p>Current Log
                    <span class="shortcut" style="float:right"></span></p>
                </li>
            <hr>
            <li onclick='toggleConsole()'>
                <input id='buttonForLogging' type='checkbox'>
                    <div class='switch'></div>  
                        <label for='buttonForLogging'>Debug Mode<!--span class='shortcut' style='float:right'>N</span--></label>
            </li>
        ` : ``

    innerMenu = document.createElement("div")

    innerMenu.id = "settingsMenu"
    innerMenu.classList.add("menuContents")
    innerMenu.innerHTML = /*html*/`
    <ul>    
        <p class="name">Settings Menu</p>

        <strong>Plugin Settings:</strong><br/>
        <!--li onclick="toggleWarnings()">
            <input id="buttonForWarnings" type="checkbox">
                <div class="switch"></div>  
                    <label for="buttonForWarnings">Disable Warnings<span class="shortcut" style="float:right">W</span></label>
        </li-->
        <!--li onclick="toggleRealTime()">
            <input id="buttonForRealTimeUpdates" type="checkbox">
                <div class="switch"></div>  
                    <label for="buttonForRealTimeUpdates">Disable Real Time<span class="shortcut" style="float:right"></span></label>
        </li>
        <p class="hint">If you experience lag while typing, you can disable real-time updating. As soon as FTOutliner is focused again, it will catch up with your changes.</p>
        <hr-->
        <!--strong>Color Scheme: </strong><span class="shortcut" style="float:right">C</span><br/>
            <li class="centered" onclick="toggleColorScheme()">
                <input id="buttonForColors" type="checkbox">
                    <label for="buttonForColors" class="labelBefore">FTOutliner</label>
                        <div class="switch"></div>
                    <label for="buttonForColors" class="labelAfter">Beat</label>
            </li>
        <li onclick="toggleInvertText()">
            <input id="buttonForInverted" type="checkbox">
                <div class="switch"></div>  
                    <label for="buttonForInverted">Invert text on dark shades<span class="shortcut" style="float:right"></span></label>
        </li>
        <hr-->
        <!--strong>Advanced:</strong><br/-->
        <!--li onclick='if(!$id("advancedSettings").open)$id("advancedSettings").showModal()'-->
        <li onclick='openSettingsWindow()'>
            <p>Advanced Settings…
                <span class="shortcut" style="float:right">⌘,</span></li>
        <hr>
        <strong>Help & Support:</strong><br/>
        <li onclick="openFeedbackWindow()">
            <p>Report an issue…</p>
                <span class="shortcut" style="float:right"></span></li>
        <li onclick="openDocumentationWindow()">
            <p>Open documentation (Beta)…</p>
                <span class="shortcut" style="float:right"></span></li>
        <!--li onclick="displayAboutBox()">
            <p>About…
                <span class="shortcut" style="float:right"></span></li-->
        <li onclick="toggleHelpContainer()">
            <p>Show all keyboard shortcuts…
                <span class="shortcut" style="float:right">?</span></li>
        <!--li onclick="">
            <p style="color: red!important">Support…
                <span class="shortcut" style="float:right"></span></li-->
        <hr>
        <!--li onclick="Beat.call('Beat.custom.sendChangelogToDialog()')"-->
        <li onclick="Beat.call(() => {Beat.custom.displaySecondWindow('Welcome', 'welcomewindow.html', 800, 650, true)})">
                Version History...
                <span class="shortcut" style="float:right"></span></li>
        <li onclick="forceRestart()">
                Force restart
                <span class="shortcut" style="float:right"></span></li>
        ${debugMenuItems}
        </ul>
`

    $id("menu").innerHTML = ""
    $id("menu").appendChild(innerMenu)

}

function openURL(url){

    window.open('https://github.com/ftolsson/ftoutliner/issues', '_blank')
}

function exportMenu(){

    innerMenu = document.createElement("div")

    innerMenu.id = "exportMenu"
    innerMenu.classList.add("menuContents")
    innerMenu.innerHTML = /*html*/`
    
    <ul>
        <p class="name">Export Menu</p>

        <li onclick="togglePrintMode()">
            Print Outline (Beta)
            <span class="shortcut" style="float:right">&#8984;P</span></li>
    <li onclick="togglePrintMode(true)">
            Export to HTML (Beta indeed)
            <span class="shortcut" style="float:right">&#8984;E</span></li>    
    <hr>
    <li onclick="newPrintBox()">
            Print/Export Settings...
            <span class="shortcut" style="float:right">⇧⌘P</li>    
    </ul>
    `

    $id("menu").innerHTML = ""
    $id("menu").appendChild(innerMenu)

}

function setButtonForExpandedScenes() {

    mylog("setButtonForExpandedScenes")

    let sections = $$(".section")
    let hasIt = false
    let hasNt = false
    for (section of sections){
        if (section.classList.contains("isExpanded")){
            hasIt = true
        }else{
            hasNt = true
        }
    }
    if(hasIt && hasNt){
        if($id("buttonForExpandedScenes")){$id("buttonForExpandedScenes").indeterminate = true}
    }else{
        if($id("buttonForExpandedScenes")){$id("buttonForExpandedScenes").indeterminate = false}
        if($id("buttonForExpandedScenes")){$id("buttonForExpandedScenes").checked = hasIt}
    }
    mylog("done")
}

function setButtonForExpandedSections() {
    let sections = $$(".section:not(.level1)")
    let hasIt = false
    let hasNt = false
    for (section of sections){
        if (section.classList.contains("collapsedSection")){
            hasIt = true
        }else{
            hasNt = true
        }
    }
    if(hasIt && hasNt){
        if($id("buttonForExpandedSections")){$id("buttonForExpandedSections").indeterminate = true}
    }else{
        if($id("buttonForExpandedSections")){$id("buttonForExpandedSections").indeterminate = false}
        if($id("buttonForExpandedSections")){$id("buttonForExpandedSections").checked = hasNt}
    }
}

function setAllButtons(){

    mylog("settingAllButtons")

    if($id("menu")){
        let whichOne = $id("menu").firstChild?.id
        mylog(whichOne)
            //fillNewMenu(whichOne)
    }

    setButtonForExpandedScenes()
    setButtonForExpandedSections()

    if($id("buttonForIndexCards")){$id("buttonForIndexCards").checked = documentSetting.indexCardMode}
        Beat.call("Beat.custom.updateViewsMenu('2'," + (documentSetting.indexCardMode) + ")")
    if($id("buttonForFlexible")){$id("buttonForFlexible").checked = (documentSetting.scenesAreProportional && !documentSetting.indexCardMode)}
        Beat.call("Beat.custom.updateViewsMenu('0'," + (documentSetting.scenesAreProportional && !documentSetting.indexCardMode) + ")")
    if($id("buttonForFixed")){$id("buttonForFixed").checked = (!documentSetting.scenesAreProportional && !documentSetting.indexCardMode)}
        Beat.call("Beat.custom.updateViewsMenu('1'," + (!documentSetting.scenesAreProportional && !documentSetting.indexCardMode) + ")")

    if($id("buttonForOneColumn")){$id("buttonForOneColumn").checked = !(documentSetting.oneColumnOutline)}
    if($id("buttonForBoneyard")){$id("buttonForBoneyard").checked = !(flexiContainer.classList.contains("boneyardIsClosed"))}

    if($id("buttonForNumbers")){$id("buttonForNumbers").checked = (showSceneNumbers == 'inline')}
    if($id("buttonForPages")){$id("buttonForPages").checked = (showPageNumbers == 'inline')}
	if($id("buttonForLength")){$id("buttonForLength").checked = (showSceneLengths == 'inline')}

	//if($id("buttonForWarnings")){$id("buttonForWarnings").checked = (!userDefault.warningsAreOn)}
    if($id("buttonForColors")){$id("buttonForColors").checked = (userDefault.colorScheme == "Beat")}
    if($id("buttonForInverted")){$id("buttonForInverted").checked = userDefault.invertTextOnDark}
    if($id("buttonForRealTimeUpdates")){$id("buttonForRealTimeUpdates").checked = (realTimeIsOn == 0)}

    if($id("buttonForNotes")){$id("buttonForNotes").checked = (notesAreDisplayed == true)}
        Beat.call("Beat.custom.updateShowMenu('0'," + (notesAreDisplayed) + ")")
    if($id("buttonForMarkers")){$id("buttonForMarkers").checked = (markersAreDisplayed == true)}
    Beat.call("Beat.custom.updateShowMenu('1'," + (markersAreDisplayed) + ")")
    if($id("buttonForBeats")){$id("buttonForBeats").checked = (beatsAreDisplayed == true)}
        Beat.call("Beat.custom.updateShowMenu('3'," + (beatsAreDisplayed) + ")")
    if($id("buttonForReviews")){$id("buttonForReviews").checked = (reviewsAreDisplayed == true)}
        Beat.call("Beat.custom.updateShowMenu('2'," + (reviewsAreDisplayed) + ")")
    if($id("buttonForNotePanel")){$id("buttonForNotePanel").checked = ($id("flexiContainer").classList.contains("notepanelIsExpanded"))}

    if($id("buttonForSynopsis")){$id("buttonForSynopsis").checked = ($id("flexiContainer").classList.contains("showSynopsisInScenes"))}
    if($id("buttonForOnlySynopsis")){$id("buttonForOnlySynopsis").checked = (flexiContainer.classList.contains("onlySynopsis"))}
    
    if($id("buttonForGreyOnly")){$id("buttonForGreyOnly").checked = ($id("flexiContainer").classList.contains("greyonly"))}
    if($id("buttonForOutdoor")){$id("buttonForOutdoor").checked = (documentSetting.outdoor == 1)}
    
    mylog("indexcards = " + documentSetting.indexCardMode + " & AreScenesProp = " + documentSetting.scenesAreProportional)

    if($id("buttonForLogging")){$id("buttonForLogging").checked = loggingIsOn}

    if($id("buttonForVoiceOvers")){$id("buttonForVoiceOvers").checked = !userDefault.excludeVoiceOvers}
    if($id("buttonForIncludeSynopsis")){$id("buttonForIncludeSynopsis").checked = documentSetting.trackingIncludesSynopsis}


    //ADVANCED DIALOG BUTTONS. (No if needed, bc created at launch with html)

    $id("buttonForDualLines").checked = documentSetting.showMultipleSceneLines
    $id("buttonForDualSectionLines").checked = documentSetting.showMultipleSectionLines
    $id("buttonForLowerCase").checked = documentSetting.allowLowerCaseSections
    $id("buttonForPageDividers").checked = documentSetting.showPageDividers
    if($id("buttonForPageDividersTwin")) $id("buttonForPageDividersTwin").checked = documentSetting.showPageDividers
    $id("buttonForAlways").checked = documentSetting.showPageDividersAlways
    $id("buttonForVerticals").checked = documentSetting.showVerticals

    saveCurrentState()
}

function cycleMenus(shift){

    if(!$id("menu")){ //if no menu, start at cycling from last one
        whichOne = "zoomMenu"
    }else{
        whichOne = $(".menuContents").id
    }

        let menuArray = [
            "settingsMenu",
            "exportMenu",
            "indexCardMenu",
            "showStuffMenu",
            "notesMenu",
            "trackingMenu",
            "zoomMenu"
        ]
        let buttonArray = [
            $id("helpButton"),
            $id("printButton"),
            $id("indexCardButton"),
            $id("showStuffButton"),
            $id("notesButton"),
            $id("characterButton"),
            $id("zoomButton")
        ]

        
        let m = menuArray.indexOf(whichOne)
            if(shift){
                m--
            }else{
                m++
            }
                if (m >= menuArray.length){m = 0}
                if (m < 0){m = menuArray.length -1}

        theClickedThing = buttonArray[m]
        whichOne = menuArray[m]

    showNewMenu(theClickedThing, whichOne)

}

</script>
<style>

.generalButtonStyle {
	border: 1px #aaa solid !important;
	border-radius: 6px !important;
	/* box-shadow: 1px 1px 2px #ccc; */
	background-color: white !important;

	text-decoration: none !important;
	padding: 2px 8px !important;
	color: black !important;

	display: inline-block;
	text-overflow: ellipsis !important;
	overflow: hidden !important;
	max-width: 90% !important;
	white-space: nowrap;

	font-size: 14px
}

.defaultButton {

	/* background-color: #eee !important; */
}

.generalButtonStyle:hover {
	
	background: #027aff !important;
	color: white !important
}

.generalButtonStyle:focus{

	outline: none;
}


/* #settings * , #tracking *{
 transition: 0.5s !important;
 line-height: 16px !important;
} */

.dialogBottomButtonRow {

	position: absolute;
	bottom: 40px;
	right: 40px;	

}

.settingsWindow{
	position:absolute !important; 
	top: 50% !important; 
	left: 50% !important;
	transform: translate(-50%, -50%) !important;
	/* min-height: 650px !important; */
	width: 650px !important; 
	padding: 40px;
	background-color:rgba(240,240,240,0.95); 
	background-color: var(--menu-background);
	border: 0.5px black solid;
	border: 0.5px var(--menu-border-color) solid;
	border-radius:12px;
	z-index: 9998;
	white-space: normal !important;
	box-shadow: 5px 5px 50px black !important;
	
	font-size: 14px;
	line-height: 16px;
	font-weight: 500;

	transition: 0.2s;

	-webkit-backdrop-filter: blur(10px);
}

#aboutBox,
#printbox,
#errorWindow,
#textContainer{
	height: auto !important;
	z-index: 9998 !important;

	max-width: 96% !important;
}

#warningDiv{
	width: 100px !important;
	height: auto !important;
	margin-top: -70px !important;
	margin-left: -5px !important;
	margin-bottom: 20px !important;
}

#introtext, #outrotext, .normalWindowText{
	white-space: normal !important;
	max-width: 560px;
	margin-left: auto;
	margin-right: auto;

	max-height: 500px;
}

.errorWindowText, .errorWindowText b, .errorWindowText i{
	white-space: normal !important;
	margin-left: auto;
	margin-right: auto;

	line-height: 16px !important;

	margin-top: 16px !important;

	pointer-events: all !important;

}

#errorBox{

	font-family: inherit;
	font-size: inherit;

	border: 1px black solid !important;
	border-radius: 8px !important;
	background-color: white !important;

	white-space: normal !important;
	padding: 8px 8px !important;

	pointer-events: all !important;

	width: 100% !important;
	height: 200px !important;
	z-index: 10000 !important;

	resize: none !important;
}

.key{
	margin: 2px;
	display: inline-block;
	/* background-color: #555; */
	background-color: #111;
	border: 1px solid #000;
	border-radius: 2px;
	font-size: 12px;
	font-weight: 500;
	padding: 1px 4px;
	color:rgb(222,222,222);
	text-align: center;
	min-width: 17px;
	height: 17px;
	line-height: 14px;

	z-index: 10000;

	/* box-shadow: none !important; */
	/* text-shadow: none !important; */
	/* filter: none !important; */
	}
	
.blurWindow{
	position: absolute !important;
	top: 0 !important;
	left: 0 !important;
	width: 100% !important; 
	height: 100% !important;

	background-color: rgba(0,0,0,0);
		
	/* background-color: rgba(85,85,85,0.45); */
	/* z-index: 9997 !important; */
	/* -webkit-backdrop-filter: blur(2px);
	backdrop-filter: blur(2px); */
	}

.blurWindow.lessBlur{
	-webkit-backdrop-filter: none !important;
	backdrop-filter: none !important;
	background-color: rgba(85,85,85,0.35) !important;
	z-index: 9997 !important;
}

#buttons{
    border: rgb(240, 240, 240) 2px ridge; 
    border-radius: 5px; 
    padding: 20px 60px 20px 80px; 
    white-space: normal !important; 
    /* line-height: 28px; */

	max-width: 560px !important;
	margin: auto auto !important;
	/* transition: 1s; */

	overflow: none !important;
	overflow-y: scroll !important;

	max-height: 90% !important;
}

#buttons::-webkit-scrollbar{
	display: none;
}

.headline{
    font-weight: 800; 
    font-size:24px;
    white-space: normal !important;
	/* transition: 1s !important; */
	/* max-width: 560px;
	margin-left: auto !important;
	margin-right: auto !important; */
	max-height: 200px;
	line-height: 28px !important;
}

.subheading{
	margin-left: -20px !important;
	margin-bottom: 2px !important;
	margin-top: 10px !important;	
	font-weight: 700;
}

.shortcutText{
    font-size: 12px; 
    font-weight: 400;
    font-style: italic; 
    color:hsl(0, 0%, 40%);
    white-space: normal !important;
	/* transition: 1s !important; */
}

p.shortcutText{
    line-height: 16px !important;
    margin-left: 20px !important;
	white-space: normal !important;
}

label{
    margin-left: 0px;
    padding-left: -20px;
    white-space: normal !important;
}

label input{
    margin-left: -20px;
    margin-top: 12px;
}

#printbox label{

	margin-left: auto !important;
	width: unset;
	max-width: unset;
	min-width: unset;

	line-height: 30px !important;
}

#printbox input{

	box-sizing: content-box !important;

	height: 22px;
	/* line-height: 30px !important; */
	border: 1px lightgray solid !important;
	border-radius: 4px !important;
	padding-left: 5px !important;

	font-size: 13px !important;

	/* transform: translateY(3px); */
}

#printbox p{

	white-space: normal;
}

#buttons * {
	white-space: normal;
}

#reachtext {
	line-height: 16px !important;
	max-height: 500px;
}

#okbutton {
	font-size: 14px; 
	padding: 5px 0px 5px auto;
}

#okbuttonpara{
	width: 100% !important;
	max-width: 560px;
	margin: 0px auto !important;
}

#upperframe {
	height: 70% !important;
}

#emptyScreenMessage, #emptyScreenMessage > p, 
#emptyScreenMessage > h1, 
#emptyScreenMessage > h1 > b {

font-size: 16px !important;
line-height: 20px !important;

margin-top: auto !important; 
margin-bottom: auto !important; 
color: white !important; 
white-space: normal !important;
margin-left: auto !important;
margin-right: auto !important;

min-width: 100px !important;
max-width: 80% !important;

/* outline: red 1px solid !important */
}

#emptyScreenMessage > h1, 
#emptyScreenMessage > h1 > b {
	/* line-height: 24px !important; */
	font-weight: 700 !important;
}

html[data-outdoors='1'] #emptyScreenMessage *:not(button:hover){
	color: black !important;
}

#helpWindow {
	/* border: 6px rgb(220,220,220) solid !important; */
	/* background-color: rgba(85, 85, 85, 0.8) !important; */
	/* box-shadow: 5px 5px 50px rgba(0, 0, 0, 0.3) !important; */
	/* border: 100px rgba(85, 85, 85, 0.8) solid !important; */

	position: absolute !important;
	left: 0px !important;
	top: 0px !important;
	width: 100% !important;
	height: 100% !important;

	transform: none !important;
	border-radius: 0px !important;

	/* background-color: rgba(85, 85, 85, 0.8) !important; */
	background-color: rgba(85, 85, 85, 0.95) !important;

	white-space: normal !important;

	/* background: none !important; */
	

	/* box-shadow: none !important; */

	overflow-y: auto !important;

}

#helpWindowInnerDiv{

	position: relative;

	/* top: 50% !important;
	left: 50% !important; */
	
	column-width: 340px;
	column-gap: 20px;
	/* column-rule: #aaa solid 1px; */

	width: 100% !important;
	height: auto !important;
	/* max-width: 95% !important;  */
	/* height: auto !important; */
	/* max-height: 100% !important;	 */

	color: rgb(240,240,240) !important;
	white-space: normal !important;

	/* padding: 0 5px 0 70px !important ; */
	/* transform: translate(-50%, -50%) !important; */

	overflow: auto !important;
	overflow-y: scroll !important;
	
	/* content: " "; */

	/* z-index: -1; */
}


/* #helpWindow::-webkit-scrollbar,
#helpWindowInnerDiv::-webkit-scrollbar {
	display: hidden !important;
	background-color: transparent;
} */

/* #helpWindow p,  */
#aboutBox .mostText,
#printbox .mostText,
#helpWindow .mostText, 
#helpWindow .subheading,
#helpWindow .headline{
/* filter: drop-shadow(0px 0px 2px black) !important; */
text-shadow: 1px 1px 6px black !important;
/* -webkit-text-shadow: 0px 0px 3px black !important; */
white-space: normal !important;
line-height: 18px !important;


}

#aboutBox .mostText,
#printbox .mostText{
	text-shadow: none !important;
	font-size: 12px !important;
	line-height: 15px !important;

}

#innerDiv {
	height: auto;
}

#aboutBox, #printbox{
	max-height: 98% !important;
	overflow-y: auto !important;
}

#helpWindow .mostText{
	font-size: 12px !important;
	font-weight: 300;
}

#helpWindow p{
	margin-left: 24px !important;
}

#helpWindow p.subheading{
	-webkit-column-break-after: avoid;
	-webkit-column-break-before: auto;
	margin-left: 0px !important; 
	margin-bottom: 12px !important;
	margin-left: -15px !important; 

}

#helpWindow .subheading {
	/* margin-left: -48px !important; */
	/* margin-bottom: 6px !important; */
	margin-top: 6px !important;
	/* margin-left: 0px !important;	 */
	-webkit-column-break-after: avoid;
	-webkit-column-break-before: auto;

	font-size:  14px !important;
}

#helpWindow .headline{
	/* margin-left: -20px !important; */
	/* margin-left: -48px !important; */
	margin-left: 0px !important;
	column-span: all;
	padding-bottom: 20px !important;
	padding-top: 20px !important;
	text-align: center;
}

#helpWindow .key:first-child{
	-webkit-column-break-before: avoid;
	filter: none !important;
	/* margin-left: -28px !important */
	margin-left: -24px; 
}



#helpWindow p:last-child{
	padding-bottom: 22px;
}

@media screen and (max-width: 700px), (max-height: 700px) {

	#helpWindowInnerDiv{
		column-count: 0;
	}

	#settings, #tracking {
		height: calc(80% - 20px) !important;
		width: calc(60% - 20px) !important;
		padding-top: auto !important;
		padding-bottom: auto !important;
		/* transition: 1s !important; */
	}

	.floatright{
		float: none !important;
	}

	#trackertext{
		width: 0px !important;
		overflow: hidden;
		opacity: 0 !important;
	}

	#selectlistparent {
		/* max-height: 50% !important; */
		float: none !important;
		width: 100% !important;
		/* padding-left: 0px !important;
		margin-left: -40px !important; */
		/* text-align: left !important; */
	}

	select, select * {
		width: 100% !important;
		margin-left: -40px !important;
		padding-left: -40px !important;
		text-align: left !important;
	}


	#buttons {
		max-width: 560px !important;
		margin: auto auto !important;
		/* transition: 1s; */
	}

	#shortcutForTop {
		display: none !important;
	}

}

.collection{
	background: rgba(0,0,0,0.3);
	border-radius: 6px;
	margin-bottom: 10px;
	padding: 10px;
	break-inside: avoid;
	
	padding-left: 25px !important;

}

@media screen and (max-width: 500px) {

	.headline:not(#helpWindow .headline), 
	#introtext, #outrotext, #reachtext, hr,
	#trackingoutro {
		opacity: 0%;
		max-height: 0px !important; 
		/* transition: 1s; */
	}

	.floatright{
		float: none !important;
	}

	#trackertext {
		max-height: calc(50% - 30px) !important;
		overflow: hidden !important;
		margin-top: 15px !important;
	}



	#trackertext ul, #trackertext li {
		text-overflow: ellipsis !important;
	}

	/* #selectlistparent {
		max-height: 50% !important;
		float: none !important;
		width: 100% !important;
		padding-left: 0px !important;
		margin-left: -40px !important;
		text-align: left !important;
	} */

	#selectlistparent {
		/* max-height: 50% !important; */
		float: none !important;
		width: 100% !important;
		/* padding-left: 0px !important;
		margin-left: -40px !important; */
		text-align: left !important;
	}

	select, select * {
		width: 100% !important;
		margin-left: -40px !important;
		padding-left: -40px !important;
		text-align: left !important;
	}

	#upperframe {
		height: calc(100% - 50px) !important;
	}

	.shortcutText{
		display: none;
	}

	#errorClickButton.generalButtonStyle{
		max-width: 90% !important;
	}
}
@media screen and (max-height: 625px) {
	.headline, 
	#introtext, #outrotext, #reachtext, hr,
	#trackingoutro {
		opacity: 0%;
		max-height: 0px !important; 
		/* transition: 1s; */
	}

	/* .floatright{
		float: none !important;
	}*/

	#trackertext {
		max-height: calc(100% - 50px) !important;
		overflow: hidden !important;
		margin-top: 15px !important;
	}

	#trackertext ul, #trackertext li {
		text-overflow: ellipsis !important;
	}*/

	#selectlistparent {
		height: 100% !important;
		/* float: none !important;
		width: 100% !important;
		padding-left: 0px !important;
		margin-left: -40px !important;
		text-align: left !important; */
	}

	select, select * {
		height: 100% !important;
		/* width: 100% !important;
		margin-left: -40px !important;
		padding-left: -40px !important;
		text-align: left !important; */
	}

	#upperframe {
		height: calc(100% - 40px) !important;
	} 

}

#outOfSyncMessage{
	text-align: left !important;
	padding-left: 120px !important;
}

#---CHANGELOG{}

#textContainer{

max-height: 85%;
}

[class*=changelog],
#textContainer *{

/* font-family: 'Courier Prime Sans', monospace; */
/*font-size: 12px !important; */
line-height: 18px !important; 
white-space: pre-wrap !important;

}

.changelog-bold{

	font-weight: 900;
	font-size: 14pt;

}

.changelog-mosttext,
.changelog-mosttext p{

	/* color: red; */
}

.changelog-item,
.changelog-item-bullet {

	/* margin-left: 3ch !important; */
	margin-left: 15px !important;
	/* color: blue; */

	margin-top: 6px !important;
	margin-bottom: 0px !important;
	padding-top: 0px !important;
	padding-bottom: 0px !important;
	

}

.changelog-item-bullet::before {

	content: "⚫︎";
	/* content: "*"; */
	/* margin-left: -2ch !important; */
	margin-left: -15px !important;

}

.changelog-subitem,
.changelog-subitem-bullet{
	
	/* margin-left: 5ch; */
	margin-left: 30px;
	/* color: green */
}

.changelog-subitem-bullet::before{

	/* content: "◦"; */
	/* font-size: 20pt; */
	content: "⚪︎";
	/* margin-left: -2ch !important; */
	margin-left: -15px !important;
	
}	

.bottomArea{

	position: sticky;
	bottom: -40px !important;
	left: -40px !important;

	margin-left: -40px !important;

	height: 100px;
	width: calc(100% + 80px);

	background: linear-gradient(0deg,
		var(--menu-background) 0%,
		var(--menu-background) 65%,
		transparent 100%
		);

	mix-blend-mode: screen;

}

#advancedSettings.settingsWindow {

	position: absolute !important;
	padding: 20px !important;

	/* max-height: unset !important; */
	/* height: auto !important; *//*somehow, height auto SETS a clipping height rather than adjusting. Very weird. */

	/* line-height: 10px !important; */
}

#advancedSettings.settingsWindow ul:last-of-type{

	padding-bottom: 50px;
	/*outline: 2px solid hotpink */

}

#advancedSettings li {

	display: relative !important;

}

#advancedSettings label{

	/* text-indent: 50px hanging !important; */
	display: inline-block;
	position: relative;
	
	min-width: calc(100% - 50px) !important;
	width: calc(100% - 50px) !important;
	max-width: calc(100% - 50px) !important;
	vertical-align: top !important;

}

#advancedSettings .labelBefore{

	min-width: unset !important;
	width: unset !important;

}

#advancedSettings .shortcut{

	position: absolute;
	right: 0px !important

}


</style>

<!-- here's some actual HTML that is not generated from JS. Change when I get the time. -->

<div id="outOfSyncDiv">
	<p id="outOfSyncMessage"></p>
	<p id="theScenesDiv"></p>
</div>

<!--THE HELP WINDOW -->

<div id="helpWindow" class="settingsWindow" style="display: none;" onclick="toggleHelpContainer();">
	
	<div id="helpWindowInnerDiv">
	
	<p class="headline">KEYBOARD SHORTCUTS<br/>

	<p class="mostText" style="column-span: all; margin: auto !important; max-width: 600px;">Most of FTOutliner’s commands can be reached from the menus, where you will also find the respective keyboard shortcuts. 
		Menus can be cycled with F1 (or fn + F1 if your function keys are mapped to MacOS features like brightness).<br/><br/>
		NOTE: Because FTOutliner is a plugin and sits in its own window, shortcuts will work only if the plugin window is focused. If you are typing into your document, an extra click in the FTOutliner window is needed to focus it before any mouse or keyboard interaction.<br/>
		&nbsp;
	</p>

	<div class="collection">
		<p class="subheading"><b>SWITCHING MODES</b></p>
	
		<p class="mostText"><span class="key">F</span> toggle between Flexible Time Mode and Non-proportional</p>
		<p class="mostText"><span class="key">X</span> toggle Index Card Mode on and off</p>
	
		<p class="mostText"><span class="key">O</span> toggle One-column view on and off</p>
	</div>
	<div class="collection">
	
		<p class="subheading"><b>WORKING WITH THE OUTLINE</b></p>
	
		<p class="mostText"><span class="key">CLICK</span> anything to scroll document to corresponding position</p>
		<p class="mostText"><span class="key">RIGHT CLICK</span> for context menu with options</p>
		<p class="mostText"><span class="key"> ↵ </span> with elements selected, also opens context menu</p>
		<br/>
	
		<p class="mostText"><span class="key">&#8984;</span><span class="key">A</span> select All scenes and sections</p>
		<p class="mostText"><span class="key">^</span><span class="key">A</span> select All scenes (excluding sections)</p>
		<p class="mostText"><span class="key">&#8984;</span><span class="key">D</span> Deselect all scenes and sections</p>
	
		<p class="mostText" style="margin-left: 0px !important;"><br/><span style=" margin-top: 2px !important; float: left;">NOTE: &nbsp;</span><span class="key">&#8984;</span>/<span class="key">^</span><span class="key">A</span> only selects non-dimmed scenes. Use with tracking and filtering to select scenes with certain character or color.<br/>&nbsp;</p>
	
		<p class="mostText"><span class="key">↑</span>/<span class="key">↓</span> walk through the outline</p>
		<p class="mostText"><span class="key">&nbsp;⇧&nbsp;</span><span class="key">↑</span>/<span class="key">↓</span> extend selection</p>
	</div>
	<div class="collection">
		<p class="subheading"><b>SHOW INFO IN OUTLINE</b></p>
	
		<p class="mostText"><span class="key">P</span> show/hide Page numbers</p>
		<p class="mostText"><span class="key">S</span> show/hide Scene numbers</p>
		<p class="mostText"><span class="key">L</span> show/hide Length of scenes (in eights)</p>
		<br/>
	
		<p class="mostText"><span class="key">^</span><span class="key">S</span> toggle multiple Scene heading lines<br/>(Fixed and Flexible Modes only)</p>	
		<p class="mostText"><span class="key">Y</span> show/hide sYnopsis <br/>(always shown in Index Card Mode)</p>	
		<p class="mostText"><span class="key">^</span><span class="key">Y</span> hide sceneheadings when synopsis is shown</p>	
	</div>
	<div class="collection">
		<p class="subheading"><b>SCRIPT NOTES &amp; MARKERS</b></p>
		<p class="mostText"><span class="key">N</span><span class="mostText"> Show/Hide Notes</p>
		<p class="mostText"><span class="key">&nbsp; &#8677; &nbsp;</span> and <span class="key">&nbsp;⇧&nbsp;</span><span class="key">&nbsp; &#8677; &nbsp;</span><span class="mostText"> Cycle all notes one by one</p>
		<p class="mostText"><span class="key">M</span><span class="mostText"> Show/Hide Markers</p>
		<p class="mostText"><span class="key">B</span><span class="mostText"> Show/Hide Beats</p>
		<br>
		<p class="mostText"><span class="key">§</span><span class="mostText"> Show/Hide the NOTE PANEL</p>
		<br/>
		<p class="mostText" style="margin-left: 0px !important">NOTE: Notes are shown in yellow unless starting with ? (green) or !, !! or !!! (red, magenta or purple, respectively). </p>
		<br/>
		</div>
	<div class="collection">
		<p class="subheading"><b>EXPANDING AND COLLAPSING</b></p>
		
		<p class="mostText" style="margin: 0px !important">In Index Card and Non-proportional modes, scenes can be collapsed and expanded by clicking the arrow (scenes) or the right icon in section cards (index card mode only).
		<br/><br>Affect all at once with <span class="key">⌥</span><span class="key">CLICK</span> or:</p>
		<br/>
		<p class="mostText"><span class="key">E</span> toggle Expand/Collapse for all scenes</p>
		<p class="mostText"><span class="key">D</span> toggle Expand/Collapse for all sections</p>
		
	</div>
	<div class="collection">
		<p class="subheading"><b>BONEYARD</b></p>
		
		<p class="mostText"><span class="key">⌘</span><span class="key">B</span> If no Boneyard present: Add one</p>
		<p class="mostText"><span class="key">⌘</span><span class="key">B</span> If Boneyard present: Toggle it</p>
		<br/>
		<p class="mostText" style="margin-left: 0px !important">NOTE: The Boneyard is just a regular act, but with special properties like being hideable in the outline.<br/><br/>While great for storing scenes and sections you don't know what to do with, remember that this is a FTOutliner feature only.<br/>Beat will regard any boneyard content as regular screenplay material, printing and exporting it along with everything else, so any boneyard contents should be deleted manually before distribution.</p>
		
	</div>
	<div class="collection">
		<p class="subheading"><b>VIEW OPTIONS</b></p>
		
		<p class="mostText"><span class="key">⌘</span><span class="key">+</span> and <span class="key">⌘</span><span class="key">-</span> change font size</p>
		<p class="mostText"><span class="key">⌘</span><span class="key">0</span> reset font size to default</p>
		<br/>
		<p class="mostText"><span class="key">^</span><span class="key">+</span> and <span class="key">^</span><span class="key">-</span> change index card height</p>
		<p class="mostText"><span class="key">^</span><span class="key">0</span> reset index card height to default</p>
		<br/>
		<p class="mostText"><span class="key">C</span> toggle color scheme</p>
		<p class="mostText"><span class="key">^</span><span class="key">C</span> temporarily disable scene colors</p>
		<p class="mostText"><span class="key">H</span> toggle Hi Contrast (black and white only) mode</p>
		<br/>
		<p class="mostText" style="margin: 0px !important;"><span style="margin-top: 2px; float:left;">NOTE: For US keyboards, substitute </span><span class="key">+</span> with <span class="key">=</span></p>
		
	</div>
	<div class="collection">
		<p class="subheading"><b>FILTER BY COLOR</b></p>
		<p class="mostText"><span class="key">⌥</span><span class="key">CLICK</span> on scene to filter by color</p>
		<p class="mostText"><span class="key">⌥</span><span class="key">&nbsp;⇧&nbsp;</span><span class="key">CLICK</span> to add filter color</p>
		<br/>
		<p class="mostText"><span class="key">ESC</span> or <span class="key">⌥</span><span class="key">CLICK</span> on empty space to exit</p>
		<br/>
		<p class="subheading"><b>FILTER BY CHARACTER</b></p>
		<p class="mostText"><span class="key">1</span>&mdash;<span class="key">9</span> filter by nine characters with most speeches</p>
		<p class="mostText"><span class="key">&nbsp;⇧&nbsp;</span><span class="key">1</span>&mdash;<span class="key">9</span> add characters to filter</p>
		<p class="mostText"><span class="key">T</span> Track from complete list of speaking characters</p>
		<br/>
		<p class="mostText"><span class="key">0</span> exit character filtering</p>
		<br/>
		<p class="mostText" style="margin: 0px !important;">Characters are ordered by most number of speeches. Selecting more than one will highlight scenes with both/all present.</p>
		
	</div>
	<div class="collection">
		<p class="subheading"><b>PRINTING & EXPORTING</b></p>
		
		<p class="mostText"><span class="key">⌘</span><span class="key">P</span> Print or save to PDF</p>
		<p class="mostText"><span class="key">⌘</span><span class="key">E</span> Export to HTML</p>
		<p class="mostText"><span class="key">&nbsp;⇧&nbsp;</span><span class="key">⌘</span><span class="key">P</span> Print/Export Settings</p>

		
	</div>
	<div class="collection">
		<p class="subheading"><b>EDITING AND ADDING NEW ELEMENTS</b></p>
		
		<p class="mostText" style="margin: 0px !important;">You can edit names of scenes and sections, and add new ones, directly within FTOUtliner.<br/><br/>While these features were designed for the Index Card Mode, some of them work in other modes too.</p>
		<br/>
		<p class="mostText"><span class="key">DOUBLE CLICK</span> scene heading, section title or synopsis text to EDIT</p>	
		<p class="mostText"><span class="key">DOUBLE CLICK</span> empty area of index card to ADD new synopsis</p>
		<br/>
		<p class="mostText"><span class="key">⌥</span> when hovering scenes and sequences to show button for adding new scene or sequence</p>
	</div>
	<div class="collection">
		<p class="subheading"><b>ADVANCED (OH WELL) SETTINGS</b></p>
		
		<p class="mostText"><span class="key">W</span> toggle Warnings when deleting, moving and more</p>
		
		<p class="mostText"><span class="key">R</span> toggle Real Time updates. Typically, this should be kept ON, unless your computer exhibits lagging issues.</p>
		
	</div>

</div></div>

<dialog id="advancedSettings" class="settingsWindow modal">

	<p class="headline">Advanced Settings</p>
	<hr>

	<ul>
		<strong><br/>Scene And Section Headers</strong><br/>
		<li  onclick="advancedTogglers('dualSceneLines', 'buttonForDualLines')">
			<input id="buttonForDualLines" type="checkbox">
			<div class="switch"></div>
					<label style="pointer-events: none" for="buttonForDualLines">Show multiple SCENE lines<span class="shortcut" style="float:right">^S</span></label>
		</li>
		<li  onclick="advancedTogglers('dualSectionLines', 'buttonForDualSectionLines')">
			<input id="buttonForDualSectionLines" type="checkbox">
			<div class="switch"></div>  
					<label style="pointer-events: none" for="buttonForDualSectionLines">Show multiple SECTION lines<span class="shortcut" style="float:right">^T</span></label>
		</li>
	<!--/ul>
	<ul>
		<strong><br/>Section headings:</strong--><br/>
		<li onclick="advancedTogglers('allowLowerCaseSections', 'buttonForLowerCase')">
			<input id="buttonForLowerCase" type="checkbox">
			<div class="switch" onclick="$id('buttonForLowerCase').click()"></div>  
					<label style="pointer-events: none" for="buttonForLowerCase">Show SECTION capitalization as typed rather than uppercase only<span class="shortcut" style="float:right">^U</span></label>
		</li>
		<li onclick="advancedTogglers('showLengthsInSections', 'buttonForSectionLengths')">
			<input id="buttonForSectionLengths" type="checkbox">
			<div class="switch" onclick="$id('buttonForSectionLengths').click()"></div>  
					<label style="pointer-events: none" for="buttonForSectionLengths">Show accumulated length-in-pages for sections<span class="shortcut" style="float:right"></span></label>
		</li>
	</ul>
	<br/>
	<hr>
	<ul>
	<strong><br/>Pages</strong><br/>
	<li  onclick="advancedTogglers('showPageDividers', 'buttonForPageDividers')">
		<input id="buttonForPageDividers" type="checkbox" checked="">
			<div class="switch"></div>  
				<label style="pointer-events: none" for="buttonForPageDividers">Show page dividers (Flexible view only)<span class="shortcut" style="float:right">^P</span></label>
	</li>
	<li style="margin-left: 50px; overflow: hidden" class="" onclick="advancedTogglers('always', 'buttonForAlways')">
		<input id="buttonForAlways" type="checkbox">
			<label for="buttonForAlways" class="labelBefore">When hovering</label>
				<div class="switch"></div>
			<label for="buttonForAlways" class="labelAfter">All the time<span class="shortcut" style="padding-right: 110px; float:right">^⌥P</span></label>
	</li>
	<!--li  onclick="advancedTogglers('always', 'buttonForAlways')">
		<input id="buttonForAlways" type="checkbox">
		<div class="switch"></div>  
				<label style="pointer-events: none" for="buttonForAlways">at all times, not just when hovered<span class="shortcut" style="float:right">⌥P</span></label>
	</li-->
	</ul>
	<br/>
	<hr>
	<ul>
		<strong><br/>Index Cards View:</strong><br/>
		<li  onclick="advancedTogglers('verticals', 'buttonForVerticals')">
			<input id="buttonForVerticals" type="checkbox">
			<div class="switch"></div>  
					<label style="pointer-events: none" for="buttonForVerticals">Show vertical bars for section levels<span class="shortcut" style="float:right">^V</span></label>
		</li>
		<li  onclick="advancedTogglers('autoWiden', 'buttonForAutoWiden')">
			<input id="buttonForAutoWiden" type="checkbox">
			<div class="switch"></div>  
					<label style="pointer-events: none" for="buttonForAutoWiden">Automatically widen index cards when editing<span class="shortcut" style="float:right"></span></label>
		</li>
		<li  onclick="advancedTogglers('widenedColumnsGetAutoHeight', 'buttonForAutoHeight')">
			<input id="buttonForAutoHeight" type="checkbox">
			<div class="switch"></div>  
					<label style="pointer-events: none" for="buttonForAutoheight">Widened cards also adjust height to fit<span class="shortcut" style="float:right"></span></label>
		</li>
	</ul>

	<p><br/></p>
	<div class="dialogBottomButtonRow">
		<button class="generalButtonStyle" onclick="for (butn of $$('#advancedSettings input')){if(butn.checked){butn.click()}}">Revert to defaults</button>
		<button class="generalButtonStyle" onclick="$id('advancedSettings').close()">Close</button>
	</div>
</dialog>

<script>

function displayEmptyScreenMessage(){

	if (!documentSetting.scenesAreProportional){toggleProportional()} //or else message is not nicely centered vertically.

	document.getElementById('outOfSyncDiv').style.display = 'none'
	document.getElementById('outOfSyncDiv').classList.remove('animate')
	
	flexiContainer.classList.remove("wait")

	document.getElementById("flexiContainer").innerHTML = /*html*/`
	
	<div id="emptyScreenMessage">
	<h1><b>Welcome to FTOutliner</b></h1>
	<p>&nbsp;</p>
	<p>This is a plugin that will show your screenplay divided into acts and sequences, and with your scenes displayed in a top-to-bottom timeline fashion with their size proportional to their length in the script.</p>
	<p>&nbsp;</p>
	<p>As soon as you add some structural elements into the document window this text will go away.<br/>
		Or click the button below to have some basic elements added for you!</p>
	<p>&nbsp;</p>
	<p>Happy writing!</p>
	<p>&nbsp;</p>
	<p style="text-align: center; margin-top: 60px !important;">
	<button class="generalButtonStyle" onclick="addTemplate()" style="text-align: center; font-size: 14px !important">Sure! Add some elements to get me started!</button>
	</p>
	`
}

function addTemplate(){

	mylog("adding template")
	
	let contentString = /*html*/ `#ACT I\\n\\n##Sequence 1\\n\\nInt. Somewhere -- day\\n\\nInt. Somewhere ELSE -- day\\n\\n##Sequence 2\\n\\nInt. ANOTHER PLACE -- day\\n\\nInt. YET ANOTHER PLACE -- day\\n\\n#ACT II\\n\\n##Sequence 3\\n\\nExt. some other location -- night\\n\\nInt. AND ONE MORE -- NIGHT\\n\\nInt. THEN THIS ONE -- day\\n\\n##Sequence 4\\n\\nInt. AND ALSO THIS -- DAY\\n\\nInt. FOLLOWED BY THIS -- day\\n\\n#ACT III\\n\\n##Sequence 5\\n\\nInt. Then finally the last few scenes -- evening\\n\\n##Sequence 6\\n\\nint. Just one more after this -- night\\n\\nInt. And thats it -- dusk\\n`
	
	mylog("string is written")
	
	Beat.call(`Beat.replaceRange(0, 0, "${contentString}")`)
	
	mylog("replace range has run")

	// let hardCodedNumberOfScenes = 12

	// for (let i = 0; i < hardCodedNumberOfScenes; i++){
	// 	cardStateForSections.push("false")
	// 	cardStateForScenes.push("false")
	// }

	setTimeout(function(){

		let allSections = $$(".section:not(.level1)")
		for (section of allSections){

			section.classList.add("isExpanded")

		}

	}, 600)

}


function displayErrorMessage(information){

	errorHasFired = true

	let hrefText = `mailto:ftoutliner@eviltomato.com?subject=Error report from FTOutliner&body=Hi,%0D%0A%0D%0AI just experienced an error in FTOutliner.%0D%0A%0D%0A
			Here's what I was doing: (please be as detailed as possible)%0D%0A%0D%0A%0D%0A%0D%0A
			____________________________________________________________%0D%0A
			Below are the last up to 100 log entries leading up to the error.%0D%0A%0D%0A 
			${information.join('%0D%0A').replaceAll('"', '%22').replaceAll("&", "%26").replaceAll(" ", "%20").replaceAll("\n", "%0D%0A")}%0D%0A%0D%0A`

	let emergencyLevelText = /*html*/`
		<p class="errorWindowText"><strong>FIRST OF ALL: </strong><i><b>Your script is most likely okay!</b></i></p>
		<p class="errorWindowText">Most of the time, FTOutliner does not touch the contents of your script. There is no indication this error occured during one of those few instances.</p>
		<p class="errorWindowText"><i>Of course, feel free to check the script for any anomalies. Should you find any, remember to hit UNDO (cmd+z) to return to the state before this error happened.</i></p>
	`

	if (actualChangesToScriptInProgress){
		emergencyLevelText = /*html*/`
			<p class="errorWindowText"><strong>THE BAD NEWS: </strong></p>
			<p class="errorWindowText">It seems that FTOUtliner was right in the middle of MOVING, DELETING or EDITING text when this happened.
				</p>
			<p class="errorWindowText">This means if we're really out of luck, FTOutliner may have managed to start, but not finish, a process of altering the contents of your script.</p>

			<p class="errorWindowText"><strong>THE GOOD NEWS: </strong><p>
			<p class="errorWindowText">If it did, you should be able to use UNDO (cmd+z) to get back to your previous state. Once should be enough.<br/>
				<i>So please look through your script document now to check if anything is off.</i></p>

			<p class="errorWindowText">Also please remember that Beat constantly autosaves as-you-type, so should you not be able to undo, selecting FILE > REVERT TO... will give you a list of your most recent auto-saved states.</p>
		`
	}

	let message = /*html*/`
	
		<div id="errorWindow" class="settingsWindow" style="white-space: normal; ">
		<div id="warningDiv">${warningSign}</div>
		<p class="headline" >Uh-oh! We’ve encountered a problem.</p>
		<p class="errorWindowText">This is embarrassing. FTOutliner just ran into an error and will need to be restarted.</p>
		
		${emergencyLevelText}

		<p>&nbsp;</p>
		<hr>
		
		<p class="errorWindowText"><b>WHEN YOU CLOSE THIS DIALOG, </b>FTOutliner will try to create an email with some data that may help track down exactly where in the code the error happened.</p>
		<p class="errorWindowText">Please add as much detail as possible about what you were doing when the error message occurred, and send it to the pre-typed address. The only forwarded data will be the names of the latest jumps in the code. </p>
		<p class="errorWindowText">&nbsp;</p>

		<p id="closeAfterErrorButtonPara" style="text-align: center"><a id="errorClickButton" class="generalButtonStyle" href="${hrefText}" onclick="Beat.call('Beat.custom.reallyQuit(true)')">Close FTOutliner and create email</a>

		<p>&nbsp;</p>
		</div>
	`

	coverContainer.style.display = "block"
	coverContainer.innerHTML += message

}


function displayAnyBox(message){


	if($id("menu"))$id("menu").remove()

	let textContainer = document.createElement("div")
		textContainer.id = "textContainer"
		textContainer.classList.add("settingsWindow")
		textContainer.style.overflowY = "scroll"
		textContainer.onclick = function(){toggleTrackingContainer(true)}
		
	let innerContainer = document.createElement("div")
		innerContainer.classList.add("innerDiv")
		// innerContainer.style.fontFamily = "'Courier Prime Sans', monospace"
		innerContainer.innerHTML = "<br/><p class='headline'>Version History</p>"

	let bottomArea = document.createElement("div")
		bottomArea.id = "bottomArea"
		bottomArea.classList.add("bottomArea")

	let closeButton = document.createElement("div")
		closeButton.id = "textCloseButton"
		closeButton.classList.add("generalButtonStyle")
		closeButton.style.position = "absolute"
		closeButton.style.bottom = "20px"
		closeButton.style.left = "50%"
		closeButton.style.transform = "translateX(-50%)"
		closeButton.innerHTML = "Sure. Fine. Whatever."
		closeButton.onclick = function(){toggleTrackingContainer(true)}
		
		message = message.replace(/(\n.*\n)\s*-+\s*\n/gm, "<strong><u>$1</u></strong>\n") //underlined
		message = message.replace(/^[^\S\n]+-\s+(.*)\n/gm, "<p class='changelog-subitem-bullet'> $1</p>\n") //sub-bullet
		message = message.replace(/\n<p class='changelog-subitem-bullet'>/gm, "<p class='changelog-subitem-bullet'>") //sub-bullet double linebreak
		message = message.replace(/^[^\S\n]+(.*)\n/gm, "<p class='changelog-subitem'>$1</p>\n") //sub no-bullet
		
		message = message.replace(/^\*\s+(.*)\n/gm, "<p class='changelog-item-bullet'> $1</p>") //bullet

		message = message.replace(/^(\=+)/gm, "")//"<span class='changelog-bold'>$1</span>")
		message = message.replace(/^(v\s\d.*)\n/gm, "<hr><br/><span class='changelog-bold'>$1</span>") //bold

		// message = message.replace(/^[^\S\n]+(.*)\n/gm, "<p class='changelog-subitem'>$1</p><br/>")

		// message = message.replace(/\s-\s(.*)\n/g, "<p class='changelog-sub-item'>$1</p>")
		// message = message.replace(/\*(.*)\n/g, "<p class='changelog-item';'>$1</p>")
		// message = message.replace(/\n\n/g, "</p><br/><p class='changelog-mosttext'>")
		message = message.replace(/\n/g, "<br/>")
		innerContainer.innerHTML += "<p class='changelog-mosttext'>" + message + "</p>"
	
	coverContainer.style.display = "block"
	$id("flexiContainer").appendChild(textContainer)
	$id("textContainer").appendChild(innerContainer)
	$id("textContainer").appendChild(bottomArea)
	$id("bottomArea").appendChild(closeButton)
	
}

function displayAboutBox(){



	message = /*html*/`

		<div id="aboutBox" class="settingsWindow" onclick="">
		<div id="innerDiv">
		<p class="headline">
			About things. Such as this plugin. And me.
		</p>
		<br/>
		<p class="mostText">
			Hi. I'm Fredrik T Olsson. I am a Swedish screenwriter.<br/>
			<br/> 
			Ever since starting out in this profession, I have longed for someone to create a screenwriting app with an outline feature that's more than just a list of scenes. One that would give me a visual overview of my story, that would simplify navigation as well as help me structure and re-structure, and where notes and scene lengths and other important info were available right there in the outline where they belong.<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When Beat came along and allowed for external plugins, I decided to try my hand at making one myself. This is the result.<br/>
			<br/>
			One year into the existence of FTOutliner, Beat has become the screenwriting app I live in. My gratitude to Lauri-Matti Parppei for creating Beat in the first place (and then tirelessly helping this javascript newbie understand my ways around the API) knows almost no limits.<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;At this point, I don't think I could imagine myself writing in another app again, and without FTOutliner on one half of the screen helping me navigate.<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;That is my current setup, and I use it daily for the work I do. Here's hoping it will help you as much as it has helped me.<br/>
			<br/>
			I'm not a coder, so you might well find quirks that aren't intended. If you do, please let me know.<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Oh, and if you don't, but just happen to like my plugin, feel free to tell me that too. We're all screenwriters; it's not like we get too many pats on our backs for what we do.<br/>
			<br/>
			Questions, feedback and bug reports can be sent to <a href="mailto:ftoutliner@eviltomato.com">ftoutliner@eviltomato.com</a><br/>
			<br/>
			Finally, why FTOutliner? That's an awfully contrived name. Well. I pretend it's short for Flexible Time. But of course it isn't, really. I'm just trying to get my initials in there. Again, we're all screenwriters. If we don't take credit, we rarely get it. <br/>
			<br/>
			This plugin, its design, code and underlying ideas, to any degree that they can be copyrighted and claimed, should be considered © Fredrik T Olsson 2021—2022 and onwards. If you like what you see, please don't steal it. I put a lot of work into it.<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Also, I am providing it for free and as is, which means that while I am continuously doing my best to ensure that FTOutliner won't cause any harm to what you (or I) write, by using it you acknowledge that the usual legalese applies. Which basically means that should anything bad happen all the same, you were the one taking a chance on a free, hobbyist app, and I cannot be held responsible. So there.<br/>
			<br/>
			That's about it, I think! Happy writing! Let's tell some exciting stories!<br/>
			<br/>
			Version: ${userDefault.ftoutlinerVersion}<br/>
			© Fredrik T Olsson, 2021—2023<br/>

	</p>
	<br/>
	<div style="display: flex; align-items: center; justify-content: center;">
		<p class="generalButtonStyle" onclick="closeMe()" >Sure, dismiss already!</p>
	</div>

</div></div>
`

	if($id("menu"))$id("menu").remove()
	coverContainer.style.display = "block"
	let aboutContainer = document.createElement("div")
		aboutContainer.innerHTML = message
		$id("flexiContainer").appendChild(aboutContainer)
	
}

function closeMe(){
	//mylog("run by " + JSON.stringify(closeMe.caller?.name))
	$id("aboutBox")?.remove()
	coverContainer.style.display = "none"
	$id("menu")?.remove()
}

function newPrintBox(){

	if($id("printbox"))return

	let printbox = document.createElement("div")
		printbox.id = "printbox"
		printbox.classList.add("settingsWindow")

	let nameValue = documentSetting.documentName || ""
	let subNameValue = documentSetting.documentSubName || ""
	let authorValue = documentSetting.documentAuthor || ""

	let contents = /*html*/`
		<div id="innerDiv">
		<p class="headline">Print/Export Settings</p>
		<br/>
		<p>The following text will be used for information in the printed/exported page. <br/>
			Fields that are left blank will print blank.</p>
		<br/>
		<label for="screenplayname" style="text-align: right; display: inline-block; width: 24% !important; padding-right: 0px;">Title &nbsp;</label><input type="text" tabindex="1" id="screenplayname" style="width: 74%;" value="${nameValue}" placeholder="The name of your screenplay"><br/>
		<label for="subheader" style="text-align: right; display: inline-block; width: 24% !important; padding-right: 0px;">Subheader &nbsp;</label><input type="text" tabindex="2" id="subheader" style="width: 74%" value="${subNameValue}" placeholder="episode number, name of draft, etc"><br/>
		<label for="writernames" style="text-align: right; display: inline-block; width: 24% !important; padding-right: 0px;">Writer(s) &nbsp;</label><input type="text" tabindex="3" id="writernames" style="width: 74%" value="${authorValue}" placeholder="That would be you"><br/>
		</p>
		<br/>&nbsp;
		<br/>
		<p class="mostText">NOTE: the outline will print in the same mode (flexible or non-proportional) and with the same scenes collapsed/expanded as shown on screen.</p>
		<br/>
		<br/>
		<!--div style="display: flex; align-items: center; justify-content: center;"-->
		<div style="text-align: right; white-space: normal;">
		<div id="cancelButton" onclick="storeAndClosePrintbox(false)" class="generalButtonStyle">Cancel</div>
		<div id="submitButton" style="margin-left: 2px;" onclick="storeAndClosePrintbox(true)" class="generalButtonStyle defaultButton">Save & Exit</div>
		</div>
		</div>`

		printbox.innerHTML = contents

		if($id("menu"))$id("menu").remove()
			toggleCaptureKeypresses(false)
			document.addEventListener("keydown", textFieldListener)

			coverContainer.style.display = "block"
			flexiContainer.appendChild(printbox)

		// saveCurrentState()

}

function storeAndClosePrintbox(yesToStore){

	if(yesToStore){

		documentSetting.documentName = $id("screenplayname").value 
		documentSetting.documentSubName = $id("subheader").value 
		documentSetting.documentAuthor = $id("writernames").value 

		saveCurrentState()
		Beat.call(`Beat.custom.setTheWindowTitle()`)

	}

	document.removeEventListener("keydown", textFieldListener)
	toggleCaptureKeypresses(true)
	$id("printbox")?.remove()

}

function textFieldListener(e){

	if(e.key == "Escape"){
		event.preventDefault()
		storeAndClosePrintbox(false)
		return
	}
	if(e.key == "Enter"){
		event.preventDefault()
		storeAndClosePrintbox(true)
	}

}


</script><script>
function togglePrintMode(exportInstead){

	if (documentSetting.indexCardMode && !exportInstead){
		let message1 = "Sorry, cannot print Index Cards"
		let message2 = "FTOutliner is currently limited to printing in outline mode only.\\n\\nYou can, however, choose to print outlines either with flexible or non-flexible scene heights.\\n\\nAny filters (by color or by character(s)) are respected too."
		Beat.call("Beat.alert('" + message1 + "','" + message2 + "')")
		return
	}
	
	document.getElementById("flexiContainer").classList.toggle("printMode")	
	if (![...document.getElementById("flexiContainer").classList].includes("printMode")){
		recalculateHeights()
		return}

	//resetting heights and hide-slugs for print!
	if(!exportInstead){
		let allScenes = $$(".scene")
		let flexiHeight = $id("flexiContainer").getBoundingClientRect().height
			for(scene of allScenes){
				scene.classList.remove("sluglineIsHidden")
				if (scene.getBoundingClientRect().height / flexiHeight < 0.012){
					//scene.classList.add("sluglineIsHidden")
				}
			}
	}

	//create a print box 

	$$(".scene, .orphan").forEach(element => {element.style.setProperty('--paperHeightFactor', paperHeightFactor)})
	//hack to get paperheight over to printout
		
	let content = document.getElementById("flexiContainer").innerHTML
	// if (!exportInstead){content = content.replace(/px\s\*\svar\(--heightFactor\)/g, "px * " + paperHeightFactor + "")}
	if (exportInstead){content = content.replace(/px\s\*\svar\(--heightFactor\)/g, " * (var(--heightFactor) / 60) * (80vh - " + (unDistributableHeight + 60) + "px)")}

	let classListOfFlexiContainer = [...document.getElementById("flexiContainer").classList].join(" ")

	let documentName = documentSetting.documentName || ""
	let documentSubName = documentSetting.documentSubName || ""
	let documentAuthor = documentSetting.documentAuthor || ""

	if(!exportInstead){

		callString = "Beat.custom.printThis(`" + (content) + "` , `" + (classListOfFlexiContainer) + "`, `" + documentName + "` , `" + documentSubName + "` , `" + documentAuthor + "`)"
	}else{
		callString = "Beat.custom.exportThis(`" + (content) + "` , `" + (classListOfFlexiContainer) + "`, `" + documentName + "` , `" + documentSubName + "` , `" + documentAuthor + "`)"
	}
	
	Beat.call(callString)
}

function preflight(){

dialogHTML = /*html*/`

    <div>Screenplay title</div>
    <div>Subheading</div>
    <div>Writer</div>
    <div>Some fields may have been auto-filled from the data on your title page. Delete and leave blank to have fields print with no value</div>

    <div>Flexible (TOGGLE) None-proportional</div>
    <div>Index cards currently cannot be printed.</div>

    <div>One Column (TOGGLE) Multiple
    


`



}

</script><style>

[contenteditable="true"] {

    -webkit-user-select: text;
    user-select: text;
}

.editBox {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    /* height: inherit; */
    /* background-color:inherit; */
    color: black;

    vertical-align: text-top;

    border: none;
    outline: none !important;

    cursor: text !important;

    padding-left: 3px;

    z-index: 9999;

    overflow: auto;

}

.section:has(.synopsis.isBeingEdited):hover {

    color: unset !important;

}

html[data-outdoors='1'] .editBox:not(.inSection) {

    background: white !important;
    color: black !important;

}

.editBox::-webkit-scrollbar{
    display: none;
}

.editBox::-webkit-selection,
.editBox::selection {
    /* background-color: #02a7ff; */
    background-color: hsl(201, 100%, 40%);
    color: #fff;

    padding: 2px;
}

.inSection.editBox {

    /* white-space: nowrap; */
    background: black !important;

    text-transform: uppercase;
    /* border-radius: 4px 0 0 0 !important; */

}

.inScene.editBox{

    /* white-space: nowrap; */

    /* height: calc(14px * var(--fontSizeFactor)) !important; */
    /* margin-top: 2px !important; */
    text-transform: uppercase;
    background: black !important;
    color: white !important;
}

/* .sectionCards .inScene.editBox{

    height: calc(19px * var(--fontSizeFactor)) !important;
    
    border-radius: 4px 4px 0 0 !important;    
    border-top: 2px solid black !important;
    
} */

.inSynopse.editBox{

    --bkg: rgba(255,255,255,0.5);

    color: black;
    /* background: white !important; */
    /* background: linear-gradient(90deg, transparent, transparent 14px, var(--bkg) 14px, var(--bkg) calc(100% - 3px), transparent calc(100% - 3px)) !important;  */
    /* background: none !important; */
    border-radius: 3px !important;

    /* border: 2px black solid !important; */
    /* box-shadow: inset 1px 1px 3px rgba(0,0,0,0.7); */


    height: auto;
}

.indexcards .inSynopse.editBox{

    margin-top: -1px !important;
    margin-left: -1px !important;

}

.inAct.editBox{

    text-transform: uppercase;
    background: var(--pageBackground) !important;
    color: white !important;

}

.inNote.editBox{

    color: lime;
    z-index: 9999999;
    border: 10px solid gold;


}

.synopsis.isBeingEdited {
    color: rgba(0,0,0,0) !important; 
}

#flexiContainer.section:has(.synopsis.isBeingEdited) .synopsis.isBeingEdited::before,
.synopsis.isBeingEdited::before{
    color: rgba(0,0,0,1 ) !important; 
    opacity: 1 !important;
}


.synopsis.isBeingEdited:hover{
    background-image: none !important;
}

.indexcards .synopsiscontainer:has(.isBeingEdited){

height: auto !important;

overflow: hidden !important;
scroll-margin: 0px;

}

#flexiContainer.indexcards:has(.synopsis.isBeingEdited) .section:not(.level1):not(:has(.isBeingEdited)):not(.section:hover),
#flexiContainer.indexcards:has(.synopsis.isBeingEdited) .scene:not(.level1):not(:has(.isBeingEdited)):not(.scene:hover){

    opacity: 0.6 !important;

}


</style>



<script>

    var initialDraggability

function editContent(ev, elementToEdit) {   

    mylog("doubleclicked " + ev?.target?.classList || elementToEdit?.classList)
    
    if(weAreCurrentlyEditingText || document.getElementById('outOfSyncDiv').style.display == 'block'){return}
    //the OutOfSync check above disallows editing if outline is updating. So as not to edit out-of-date data.
    
    if(ev){ev.stopImmediatePropagation()}
    $(".isBeingEdited")?.classList.remove("isBeingEdited")
    $id("editBox")?.remove()

    theElement = elementToEdit?.querySelector(".section-heading, .sceneheading, .notepanelNote, .expandedNote") || ev.target
        let sceneSize = false
            if (theElement.closest(".scene")) sceneSize = window.getComputedStyle(theElement.closest(".scene")) || false
        let sceneHeight = sceneSize?.height || false

    let editBoxDelay = 0

        //this sends us to the new synopsisEditor!
            //NOTE: any code for synopsis editing still lingering below WILL produce an error
            //because it still expects synopsis to be outline elements. Remove it. 
        if((theElement.classList.contains("synopsis") || theElement.classList.contains("synopsiscontainer"))){

            if(!documentSetting.indexCardMode && documentSetting.scenesAreProportional){

                alertThis("Editing synopsis in this view is disabled", "By its nature, Flexible view hides content all the time which makes it unsuitable for inline editing.\n\nOn the other hand, in the FIXED and INDEX CARD views, editing synopsis is easier than ever.\n\nSwitch to one of those views by hitting F or X and edit the card from there.")
                return
            }

            if(documentSetting.indexCardMode && documentSetting.autoWiden && !theElement.closest(".level1").classList.contains("wider")) {
                makeWider(theElement)
                editBoxDelay = 250
            }
            setTimeout(function(){
                indexCardEditor(theElement, ev)
            }, editBoxDelay)
            return

        }

    mylog("before if dots")

    //to prevent editing dots:
    if( [...$id("flexiContainer").classList].includes("indexcards")
        &&
        [...theElement.classList].includes("scene")){
            mylog("checking inside to see that parent is expanded")
            let theParent = theElement.parentNode
            let a = [...theParent.classList]
            while (!a.includes("section")){
                theParent = theParent.parentNode
                a = [...theParent.classList]
            }
            if(!a.includes("isExpanded")){
                return
            }
    }

    if(ev?.altKey || ev?.ctrlKey || ev?.metaKey){
        return
    }

    //return if trying to edit uneditable things
        if (!["section-heading", "sceneheading", "notepanelNote", "expandedNote"].some(allowedClass => theElement.classList.contains(allowedClass))){ //experimental 2023-01-08
            return
        }

    //return if trying to edit dimmed things
    if([...document.getElementById("flexiContainer").classList].includes("uncolorAllScenesBut")){
        if(colorsArray.some(color => [...theElement.classList].includes(color.toLowerCase()))){
            return
        }
    }

    if([...theElement.classList].includes("sluglineIsHidden")){
        Beat.call(`Beat.alert("Can't edit hidden text", "You are trying to edit the heading of a scene that's too small to fit on the screen.\\n\\nPlease edit directly in the document, or switch to non-flexible view (shortcut F) to see all scenes regardless of length.")`)
        return
    }

    mylog("past all the guard clauses, now setting weAreCurrentlyEditingText to true")
    //================================================================================

    initialDraggability = !(!theElement.draggable) //will freeze the value
    theElement.draggable = false

    weAreCurrentlyEditingText = true

    toggleCaptureKeypresses(false)
    document.addEventListener('keydown', editBoxListen)
    theElement.ondblclick=""
    theElement.classList.add("isBeingEdited")
    
    let currentOutlineCount = findOutlineCountFor(theElement)
    let theOldText = outline[currentOutlineCount]?.stringForDisplay
        if(["notepanelNote", "expandedNote"].some(noteclass => theElement.classList.contains(noteclass))){
            theOldText = theElement.innerText
        }

    if(document.getElementById('youAreHere')){
        document.getElementById('youAreHere').remove()
    }

    //time to let the editbox know what it is representing
        mylog("setting the KINDOF")
    
    let a = [...theElement.classList]
        let kindOf = ""
            if (a.includes("sceneheading")){
                kindOf = "inScene"
                theElement.classList.remove("isSelected")
                theElement.parentNode.classList.remove("isSelected")
            }
            if (a.includes("section-heading")){
                kindOf = "inSection"
                // theElement.parentNode.classList.add("isSelected")
                theElement.classList.remove("isSelected")
                theElement.parentNode.classList.remove("isSelected")
            }
            if ([...theElement.parentNode.classList].includes("level1")){
                kindOf = "inAct"
            }
            if (["notepanelNote", "expandedNote"].some(allowedClass => theElement.classList.contains(allowedClass))){
                kindOf = "inNote"
                theElement = theElement.querySelector("text")
                theOldText = theElement.innerText
            }
        
    mylog("the result is" + kindOf)

    // creating the editbox
    // NEW: after 220704, the rest is in a setTimeOut, and delayed if widen happens
    mylog("about to create the editBox")

    setTimeout(function(){

        let editBox = document.createElement("div")
            editBox.id = "editBox"
            editBox.draggable = false
            editBox.innerText = theOldText
            editBox.contentEditable = "true"
            editBox.classList.add("editBox")
            editBox.classList.add(kindOf)

        //copy sizes etc from original

            let sizes = theElement.getBoundingClientRect()
        
            let leftIndent = 0
                if($id("notepanel")?.classList?.contains("expanded") && kindOf != "inNote"){
                    leftIndent = $id("notepanel").getBoundingClientRect().width
                }

            let scrolledAmount = $id("flexiContainer").scrollTop
            if(documentSetting.scenesAreProportional && sceneHeight) theElement.closest(".scene").style.minHeight = sceneHeight
        
            $id("flexiContainer").appendChild(editBox)

            editBox.style.left = (sizes.left - flexiContainer.getBoundingClientRect().left) + "px"
            editBox.style.top = sizes.top + scrolledAmount + "px"
            editBox.style.width = sizes.width + "px"
            editBox.style.height = "auto" //testing auto height for all editing!
                // if($(".dualSceneLines") && kindOf == "inScene") editBox.style.height = "auto"
                // if($(".dualSectionLines") && kindOf == "inSection") editBox.style.height = "auto"

            editBox.style.whiteSpace = "normal"
            editBox.style.zIndex = 10000
            editBox.style.display = "block"
            editBox.style.opacity = "1"
        
        let elementCSS = window.getComputedStyle(theElement)

            editBox.style.color = elementCSS.color
                if (theElement.classList.contains("sceneheading")){
                    editBox.style.color = "black"
                }
                if (theElement.classList.contains("section-heading")){
                    editBox.style.color = "white"
                }
                if (theElement.classList.contains("section-heading") && !flexiContainer.classList.contains("allowLowerCaseSections")){
                    editBox.style.textTransform = "uppercase";
                }

            editBox.style.fontSize =  elementCSS.fontSize
            editBox.style.fontStyle = elementCSS.fontStyle 
            editBox.style.fontWeight =elementCSS.fontWeight
            editBox.style.lineHeight =elementCSS.lineHeight
            editBox.style.textAlign = elementCSS.textAlign 
            editBox.style.padding = elementCSS.padding
            editBox.style.paddingBottom = "0"
            editBox.style.border = elementCSS.border
            editBox.style.margin = elementCSS.margin
            if (documentSetting.indexCardMode) {
                editBox.style.borderRadius = elementCSS.borderRadius
            }else if(theElement.closest(".scene, .section")){
                editBox.style.borderRadius = window.getComputedStyle(theElement.closest(".scene, .section"))?.borderRadius
            }
            editBox.style.borderBottom = elementCSS.borderBottom

        mylog("editbox appended")

        let range = document.createRange();
            range.selectNodeContents(editBox);
        let sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

        editBoxResizeObserver = new ResizeObserver(entries => {
            for (entry of entries){
                theElement.style.height = entry.contentRect.height + "px"
            }
        })
        editBoxResizeObserver.observe($(".editBox"))

        document.getElementById("editBox").focus()
        document.getElementById("editBox").addEventListener("blur", function(){
            let changed = (theOldText != editBox.innerHTML)
            editBoxResizeObserver.disconnect()
            theElement.style.height = ""
            event.preventDefault();
            exitEdit(theElement, changed)}) 

        mylog("eventlisteners appended")

        
    }, editBoxDelay) //ends the timeout

    console.trace()

}

function exitEdit(theElement, changesWereConfirmed) {
    mylog("exitedit")

    if(!weAreCurrentlyEditingText){return}
    weAreCurrentlyEditingText = false

    // let widenedColumns = $$(".wider")
    //     widenedColumns.forEach(element => {
    //         element.classList.remove("wider")
    //     });

    editBoxResizeObserver.disconnect()
    if(!changesWereConfirmed) theElement.style.height = ""
    if(theElement.closest(".scene")) theElement.closest(".scene").style.minHeight = ""

    coverContainer.classList.remove("lessBlur")
    coverContainer.style.display = "none"
    flexiContainer.classList.add("positionRelative")
    
    if(document.getElementById("editBox")){

        console.time("exitEdit")

        let newContent = JSON.stringify(document.getElementById("editBox").innerText) //freezes the value
        newContent = newContent.substr(1, newContent.length-2) //strips quotation marks
        
    
        if (newContent == /\\n\s*/){newContent = ""}
        if (newContent == "\\n" || newContent == "\\n "){newContent = ""}

        if ([...theElement.classList].includes("synopsis") && newContent != ""){ //should effectively delete the synopsis element if left empty
            //1. divide synopsis with line breaks into separate synopsis elements
            newContent = newContent.replace(/\\n/g, "\\n= ")

            //2. replace empty rows with nothingness!
            newContent = newContent.replace(/=\s*\\n/g, "") // = with spaces and then linebreak
            newContent = newContent.replace(/=\s*$/g, "") // = at the end of the string
        }
        if (!theElement.classList.contains("synopsis") && newContent == ""){ //scene headings and sections are named UNTITLED if empty
            newContent = "Untitled"
        }
        
        document.removeEventListener("keydown", editBoxListen)

        mylog("before checking if changes were confirmed")
        
        if(theElement && changesWereConfirmed){
            
            mylog("this means changes were confirmed = true")

            currentOutlineCount = findOutlineCountFor(theElement)

            let shownLine
            let line
            let startPosition
            let length

            // if(theElement.classList.contains("synopsis") && outline[currentOutlineCount].synopsis){

            //     //Second place to make better synopsis editing!

            //     shownLine = outline[currentOutlineCount].synopsis[theElement.dataset.synopsisNumber].stringForDisplay
            //     line = outline[currentOutlineCount].synopsis[theElement.dataset.synopsisNumber].string
            //     startPosition = outline[currentOutlineCount].synopsis[theElement.dataset.synopsisNumber].position
            //     length = outline[currentOutlineCount].synopsis[theElement.dataset.synopsisNumber].range.length

            // }else{

                shownLine = outline[currentOutlineCount].stringForDisplay.replace(/^#*\s*/, "")
                line = outline[currentOutlineCount].line.string
                startPosition = outline[currentOutlineCount].line.position
                length = outline[currentOutlineCount].line.range.length
            
            // }
            
            let resultingLine = line.replace(shownLine, newContent)
            if (shownLine == ""){
                resultingLine = line + newContent
            }

            if (theElement.classList.contains("heading") && !resultingLine.startsWith(".") && !resultingLine.startsWith("INT") && !resultingLine.startsWith("EXT")){
                resultingLine = "." + resultingLine
            }

            actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
            Beat.call("Beat.replaceRange(" + startPosition + ", " + (length - 1) + ", `" + resultingLine + "`)")

        }else{

            // $id("printButton").innerHTML = "YUP. And the element is " + theElement.id + ", " + theElement.classList

            if(!theElement) theElement = $(".isBeingEdited")

            theElement.draggable = initialDraggability
            // if([...theElement.classList].includes("synopsis")){
            //     theElement.style.height = "auto"
            // }
            //setTimeout(function(){
                theElement.classList.remove("isBeingEdited")
            //}, 500) //this is so thatif I doubleclick another synopsis, it won't rearrange on the first click
            document.getElementById("editBox").remove()
        }

        // document.addEventListener('keydown', checkWhatKeyGotPressed)
        toggleCaptureKeypresses(true)
        youAreHere()

    }
    //recalculateHeights()
    console.timeEnd("exitEdit")
    mylog("end of exitedit")
}

function editBoxListen(someoneJustPressed){

    mylog()
    
    if (someoneJustPressed.key == "Enter" && (event.shiftKey || event.altKey)){
        if ([...theElement.classList].includes("synopsis")){
            event.preventDefault()
            document.execCommand('insertLineBreak')
            makeCloneSourceEquallyHigh()
            return
        }else{
        // if (theElement.nodeName == "DIV"){
            event.stopImmediatePropagation()
            // event.preventDefault()
            return
        }
    }

    // make function to reconfigure editbox with new size, then re-enable the below 

    //ALLOW ZOOMING while editing:
        if (event.metaKey && event.ctrlKey && (someoneJustPressed.key == "=" || someoneJustPressed.key == "+" || someoneJustPressed.key == "-" || someoneJustPressed.code == "Digit0")){
            event.preventDefault(); changeIndexCardHeight(someoneJustPressed.key); 
            makeCloneSourceEqualPeriod()
            return
        }
        if (event.metaKey && (someoneJustPressed.key == "=" || someoneJustPressed.key == "+" || someoneJustPressed.key == "-" || someoneJustPressed.code == "Digit0")){
            $(".editBox").style.display = "none"
            let redraw = $(".editBox").getBoundingClientRect()
            
            event.preventDefault(); zoomSizes(someoneJustPressed.key)
            setTimeout(makeCloneSourceEqualPeriod, 120)
            return
        }

    //Don't mute UNDO
    if (someoneJustPressed.key == "z" && (event.metaKey)){
        //event.preventDefault()
        //event.stopImmediatePropagation()
        return
    }
        
    if (someoneJustPressed.key == "Enter"){event.preventDefault(); exitEdit(theElement, true); return}
    if (someoneJustPressed.key == "Escape"){event.preventDefault(); exitEdit(theElement, false); return}

    if ([...theElement.classList].includes("synopsis")) {makeCloneSourceEquallyHigh()}
}

function makeCloneSourceEquallyHigh(){

    mylog("makingCloneSourceEquallyHigh" + $(".editBox").getBoundingClientRect().height + "px")
    mylog("before changing, height of original was " + theElement.style.height)

    theElement.style.height = ($(".editBox").getBoundingClientRect().height + 2) + "px"

}

function makeCloneSourceEqualPeriod(){

let editBox = $(".editBox")
let elementCSS = window.getComputedStyle(theElement)

editBox.style.height = (theElement.getBoundingClientRect().height + 2) + "px"
editBox.style.width = (theElement.getBoundingClientRect().width + 2) + "px"
editBox.style.top = (theElement.getBoundingClientRect().top) + "px"
editBox.style.left = (theElement.getBoundingClientRect().left) + "px"

editBox.style.fontSize = elementCSS.fontSize
editBox.style.lineHeight = elementCSS.lineHeight

editBox.style.display = "unset"
}


function insertLineBreak(){

    let currentPosition = window.getSelection().anchorOffset

    let textToEdit = $id("editBox").innerHTML
    let editedText = textToEdit.slice(0, currentPosition) + "<br>" + textToEdit.slice(currentPosition);

    $id("editBox").innerHTML = editedText

    //put caret in place

    let range = document.createRange()
    let sel = window.getSelection()

    sel.setPosition($id("editBox"), currentPosition)

}

function findOutlineCountFor(theElement){

    mylog("findOutlineCount" + theElement.classList)

    let elementWithOutlineCount = theElement
    let currentOutlineCount = elementWithOutlineCount.id.replace(/:.*/, "")

    mylog("half way through, we have this: " + currentOutlineCount)

    if (!currentOutlineCount) {
        elementWithOutlineCount = elementWithOutlineCount.parentNode        
        currentOutlineCount = elementWithOutlineCount.id.replace(/:.*/, "")
        // Beat.call("Beat.alert('"+elementWithOutlineCount.classList + "', '" + currentOutlineCount +"')")
    }

    mylog ("returning")
    return currentOutlineCount
}

</script><style>

#actioncontainer{

    height: 30px;

    background: transparent;
    border-radius: 3px;
    
}

</style>

<script>

function findEnclosingCardElementFor(element){

    if(!element)return false
    mylog()

    element = element.closest(".scene, .section")

    return element || false
}

function addElement(theClickedThing, whatToAdd, beforeInsteadOfAfter){

    if(!theClickedThing) theClickedThing = $(".isSelected") || $id("youAreHere").closest(".scene, .section")
    if(!theClickedThing) return

    if(["addScene", "addSection"].includes(theClickedThing.id)){
        alertThis("Sorry, you tried to add a scene using the old method. Please add scenes from the context menu instead.")
    }

    mylog("add: " + whatToAdd + "to: " + theClickedThing.classList)

    let sceneLine = outline[theClickedThing.closest(".scene, .section").getAttribute("data-my-id")]
    let locationAfter = sceneLine.sceneEnd + 1
        if(sceneLine.typeAsString == "Section"){
                    locationAfter = outline[outline.indexOf(sceneLine) + 1]?.sceneStart || sceneLine.sceneEnd // to put it after synopsis if present
                }
        if(beforeInsteadOfAfter){
            locationAfter = sceneLine.line.range.location
        }

    switch (whatToAdd) {
        case "scene":
        
            addString = "\\n.NEW SCENE\\n"

            break;

        case "section":
                
            let numberOfHashtags = outline[theClickedThing.closest(".section").dataset.myId].line.string.match(/^(#*)/)        
                addString = `${"#".repeat(numberOfHashtags[0].length)}NEW SECTION\\n`
    
            break;
    
        default:

            console.log("ERROR: addElement got no whatToAdd")
            return
            break;
    }

    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    
    let doThis =`
        Beat.addString("\\n${addString}\\n", ${locationAfter})
        Beat.custom.checkBlankLines(${locationAfter + 3})
        Beat.scrollTo(${locationAfter})
        Beat.custom.blinkTheLine(${locationAfter})
    `
    Beat.call(doThis)
    
}

function demoteSection(section){

    if(!section) section = Array.from($$(".section.isSelected"))?.at(-1)
    if(!section || section.classList.contains("level1")) return

    startIndex = section.dataset.line
    if(!startIndex)return

    Beat.call(`
        Beat.replaceRange(${startIndex}, 1, "")
    `)

}

function promoteSection(section){

    if(!section) section = Array.from($$(".section.isSelected"))?.at(-1)
    if(!section || ["level6", "level7", "level8", "level9"].some(level => section.classList.contains(level))) return

    startIndex = section.dataset.line
    if(!startIndex)return

    Beat.call(`
        Beat.addString("#", ${startIndex})
    `)

}


</script><style>

:root{
    --dragging-cursor-color: white;
    --dragging-cursor-color-on-light: blue;
}

.beingDragged{
    opacity: 0.2 !important;
    transform: scale(0.9) !important;

    transition: all 0.2s !important;
}

.level1.beingDragged{

    transform-origin: top center;

}

.indexcards .synopsis.beingDragged{
    opacity: 0.3 !important;
    transform: scale(1) !important;
}

#ghost .synopsis::before{
    display: none;
}

#dropDiv{
    position: relative;
    margin-left: 16px;
    height: 0px;
    width: calc(100% - 1) !important;
    background-color: none;
    border: 1px var(--dragging-cursor-color) solid !important;
    border-radius: 0px !important;

    pointer-events: all !important;

    transition: all 0.2s !important; 

    z-index: 9999 !important;

    /* outline: 300px solid rgba(120,255,0,0.4) */
}

#dropDiv::after{
    height: 40px;
    content: " ";
    width: 100%;
    background: transparent;
    display: block;
    position: absolute;
    bottom: -20px

}

#dropDiv.actDrop::after{

    height: 80vh;
    width: 60px;
    top: 0;
    left: -30px;

}

#dropDiv.dropZone{
    height: 0px !important;
    margin-top: 20px;
    margin-bottom: 20px;
    transition: all 0.2s !important;

    pointer-events: all !important;
    z-index: 9999 !important;
}

#dropDiv.synopsisDrag{
    position: relative;
    height: 0;
    margin-top: calc(7px * var(--fontSizeFactor))  !important;
    margin-bottom:  calc(7px * var(--fontSizeFactor))  !important;
    padding: 0 !important;
    margin-left: 11px !important;
    margin-right: 0px !important;
    
    border: 1px var(--dragging-cursor-color-on-light) solid !important;
    color: black !important;

    z-index: 9999 !important;
    overflow: visible !important;

    font-size: calc(11px * var(--fontSizeFactor)) !important;
    font-weight: bold !important;
    line-height: calc(2* 12px * var(--fontSizeFactor)) !important;

    opacity: 1;

    pointer-events: all !important;
}

#dropDiv.actDrop{

    top: -10px;
    margin-right: 16px;
    width: 0px !important;
    height: 80% !important;

}

#dropDiv::before{

    position: absolute;
    content: " ";
    height: 4px;
    width: 4px;
    border: 2px var(--dragging-cursor-color) solid !important;
    border-radius: 50%;
    left: -7px;
    top: -4px;
}

#dropDiv.actDrop::before{

    left: -4px;
    top: -7px;

}

#dropDiv.synopsisDrag::before{
    position: absolute;
    border-color: var(--dragging-cursor-color-on-light) !important;
    left: -7px;
    top: -4px;
}

.indexcards .level1>.sectiontext+.dropZone{
    transform: translateY(calc( -2px - var(--indexCardHeight) + 16px * (var(--fontSizeFactor)))) !important;
    min-width: 200px !important;
}

.ghost {
    position: absolute;
    transform: scale(0.9); 
    opacity: 0.85;    
}

#ghost .isSelected {
    background-image: transparent !important;
}

#ghost .scene::before,
#ghost .arrowForIndexCards {
    display: none;
}

.shrinkToNone{
    transform: scale(0) !important;
    margin: 0px 0px 0px 0px !important;
    border: 0px !important;
    transition: all 0.5s !important;
}

.longerAnimation,
.longerAnimation * {
    transition-delay: 0ms !important;
    transition:  0.5s !important;
}

.level1.mustAnimate{
    transition: all 0.2s !important;
}

.scene.mustAnimate{
    transition: all 0.2s !important;
}

.locateme{
    border: 3px solid red !important;
    background-color: gold !important;
}

</style>

<script>

var previouslyDraggedOverElement = false
var beforeOrAfter, previousBeforeOrAfter
var previousDropZonePosition
var dropTookPlace
var closeBoneyardAfter = false

var sectionLevelDrag

var rangeStart, rangeEnd //selects the text to be moved BEFORE sending to plugin!

var dropDivCloserTimer

var elementBeforeDropDiv

function onDragStart(e) {

    if(weAreCurrentlyEditingText){return}

    e.stopPropagation()
    collapseNote()

    // Beat.call("Beat.onTextChangeDisabled = true")
    // Beat.call("Beat.onOutlineChangeDisabled = true")
	// Beat.call("Beat.onSelectionChangeDisabled = true")

    dropTookPlace = false 
    beforeOrAfter = false
    previousBeforeOrAfter = false
    
	if(!e){ //this is really unlikely to occur
        mylog("returning from onDragStart because no event")
        return}  
        
    mylog("onDragStart: " + e.target.classList)

    //don't drag scene dots in index card mode for sections
    if(documentSetting.indexCardMode && e.target.classList.contains('scene') && ![...e.target.parentNode.classList].includes('isExpanded')){
        Beat.call("Beat.alert('Not allowed', 'Moving scene dots around in this view would be quite insecure and finicky. So no.')")
        return
    }

    //if dragging just one, avoid dragging others than the one you actually try to drag
    if(!e.target.classList.contains('isSelected')){
        deselectAllElements()
        e.target.classList.add('isSelected')
    } 

    //check so that all selected items are of the same kind!
    let draggedObjectTypes = [] 
    $$(".isSelected").forEach(element => {
        //draggedObjectTypes.push(Array.from(element.classList).filter(cl => ["section", "scene", "synopsis"].includes(cl)))
        let filteredClasses = Array.from(element.classList).filter(cl => ["section", "scene", "synopsis"].includes(cl))
            if (filteredClasses.length > 0) {
            draggedObjectTypes.push(filteredClasses[0])
            }
    })
    if(!draggedObjectTypes.every(val => {return val === draggedObjectTypes[0]})){
        alertThis("Can not move different element types at once.")
        return
    }



    //set first and last scene of the bunch //dec 2022 WHAT FOR?
        let selectedScenes = document.querySelectorAll('.isSelected')
        // let firstElement = (selectedScenes.length > 0) ? Number(selectedScenes[0].id) : Number(e.target.id)
        // let lastElement = (selectedScenes.length > 0) ? Number(selectedScenes[selectedScenes.length-1].id) : Number(e.target.id)
        let firstElement = Number(selectedScenes[0].id)
        let lastElement = Number(selectedScenes[selectedScenes.length-1].id)
        if (selectedScenes[0].classList.contains("synopsis")){
            firstElement = Number(selectedScenes[0].id.replace(/_.*/, "").replace(/^s/, ""))
            lastElement = Number(selectedScenes[selectedScenes.length-1].id.replace(/_.*/, "").replace(/^s/, ""))
        }

    //now: some logic to stop omitted scenes from moving
        if((outline[firstElement].omitted == 1 || outline[lastElement].omitted == 1)
            ||
            (selectedScenes[0].classList.contains("synopsis") && outline[firstElement].synopsis &&
                (outline[firstElement].synopsis[selectedScenes[0].dataset.synopsisNumber]?.string.includes("/*") || outline[firstElement].synopsis[selectedScenes[0].dataset.synopsisNumber]?.string.includes("*/") 
                ||outline[firstElement].synopsis[selectedScenes[0].dataset.synopsisNumber]?.omitted)
                )
            ){
            e.stopPropagation()
            e.preventDefault()
            deselectAllElements ()
            onDragEnd(e)
            Beat.call("Beat.alert('Lines need to be unhidden before moving', 'You are trying to move a block where the first or last lines or parts thereof are marked as hidden.\\n\\nDue to how Fountain handles omission marks this might well open a giant can of worms, so you need to unhide them to move them around.')")//\\n\\nFun fact: Hidden stuff WITHIN a block is fine, as long as the first or last scenes or lines are not.')")
            return
        }

    //Next up: check if we're dragging sections and adjust the selection!
    sectionLevelDrag = false
    if (selectedScenes[0].classList.contains("section")){
        //if only one is selected:
        if (firstElement == lastElement){

            $id(firstElement).classList.add('isSelected')
            sectionLevelDrag = true
            let thisSectionsDepth = [...$id(firstElement).classList].join(" ")
            thisSectionsDepth = (thisSectionsDepth.match(/level(\d)/))[1]

            while (outline[lastElement + 1] && 
                !(outline[lastElement + 1].typeAsString == "Section" && 
                [...$id(lastElement + 1).classList].join(" ").match(/level(\d)/)[1] <= thisSectionsDepth)){
                    lastElement ++
                    a = $id(lastElement)
                    if (a){a.classList.add("isSelected")}
            }
        //but now, if more than one is somewhow selected
        }else{
            for (i = firstElement + 1; i<lastElement; i++){
                if (outline[i].typeAsString == "Section"){
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements ()
                    onDragEnd(e)
                    Beat.call("Beat.alert('Can only move single sequences at a time', 'To move a sequence, grab its sequence header and move all scenes at once.\\n\\nTo move a subset of the sequence select the desired scenes and move them separately.')")
                    return
                }
            }
        }
        //also check if range of selected stuff is not a full section + all contents
        if(outline[lastElement + 1] && outline[lastElement +1].typeAsString != "Section"){
            e.stopPropagation()
            e.preventDefault()
            deselectAllElements ()
            onDragEnd(e)
            Beat.call("Beat.alert('Can only move entire sequences', 'To move a sequence, grab its sequence header and move all scenes at once.\\n\\nTo move a subset of the sequence select the desired scenes and move them separately.')")
            return
        }
    
    //if sectionDrag, we need to re-evaluate selectedScenes again:
        selectedScenes = $$('.isSelected')

    }  

    mylog("past checking if sectionDrag")
              
        // if (firstElement != lastElement){
        if (selectedScenes.length > 1){

            // if (outline[firstElement].typeAsString == "Synopse"){
            if (selectedScenes[0].classList.contains("synopsis")){
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements()
                    onDragEnd(e)
                    alertThis('Moving multiple synopsis is not allowed', 'Synopsis can only be moved one by one, so as not to risk splitting screenplay content that may be in between.\\n\\nPlease move synopsis one by one instead.')//, 'Also note that synopsis will intentionally be moved WITHOUT any other screenplay text such as action, dialog, etc.')
                    return   
                }
            
            for (i = firstElement; i < lastElement+1; i++){

                let elementToCheck = $id(i)

                if (outline[i].typeAsString == "Section" && !sectionLevelDrag){
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements ()
                    onDragEnd(e)
                    Beat.call("Beat.alert('Can not move section header as part of selected range', 'Either select the block of scenes you want to move, or grab a section header to move the entire section and everything in it.')")
                    return
                }

                if (!elementToCheck || !elementToCheck.classList.contains("isSelected")){

                    let reasonString = ""

                    if (outline[i].typeAsString == "Synopse"){mylog("synopsis so continuing"); continue}

                    if (outline[i].omitted == 1 && documentSetting.scenesAreProportional){reasonString = "It may look as if they are, but the range you are trying to move contains one or more hidden (omitted) scenes, which were not selected. \\n\\nSwitch to non-flexible mode (shortcut: F) to select the entire range."}
            
                    e.stopPropagation()
                    e.preventDefault()
                    deselectAllElements()
                    onDragEnd(e)
                    Beat.call(`Beat.alert('Can only move consequtive scenes!', '` + reasonString + `')`)
                    return
                }
            }
        }

	//remove the you are here indicator before dragging starts for cosmetic reasons
    if($id('youAreHere')){$id('youAreHere').remove()}

    //NOW: Time to start dragging

    previouslyDraggedOverElement = e.target

    $id("flexiContainer").classList.add("drag")

    makeGhost(e, selectedScenes, "dragstart")
    
    //disable hovering of scenes for cosmetic reasons
        let elements = $$(".scene")
        for (element of elements){
            element.classList.add("noHover")
        }

    //un-uglify the ghost image
        elements = $$("#ghost .scene, #ghost .synopsis")
        for (element of elements){
            element.classList.remove("isSelected")
            element.classList.remove("beingDragged")
        }
}

function onDragEnd(e, cancelButton){
	
    mylog("onDragEnd")

    altIsBeingPressed = false //to avoid reappearing buttons after copy-drag
    $id("flexiContainer").classList.remove("drag")
    flexiContainer.classList.remove("not-allowed")
    Beat.call(`
        Beat.setSelectedRange(${rangeStart},0)
        `)
    document.getElementById("flexiContainer").classList.add("positionRelative") //for Notes to scroll again -- disabled for Ghost Image
    let allActs = $$(".level1")
        for (act of allActs) act.style.pointerEvents = "none" // makes ACTS unclickable again)

    if (dropTookPlace && !cancelButton){
        mylog("returning from onDragEnd because dropTookPlace")
        return} 
    
    // The rest of this function handles an illegal or cancelled drop (ESC, or wrong place):
    mylog("ESCAPED or ILLEGAL DROP")

    actualChangesToScriptInProgress = false //this is for the errorhandler to know what was happening

    if (document.getElementById("ghost")){document.getElementById("ghost").remove()}
    closeDropZone()

    if (closeBoneyardAfter){$id("flexiContainer").classList.add("boneyardIsClosed")}
    
    let elements = document.querySelectorAll(".scene")
        for (element of elements){
            element.classList.remove("noHover", "beingDragged")       
        }

    elements = document.querySelectorAll(".section")
        for (element of elements){
            element.classList.remove("noHover", "beingDragged") 
        }

    elements = document.querySelectorAll(".synopsis")
        for (element of elements){
            element.classList.remove("noHover", "beingDragged") 
        }

        deselectAllElements()

}

function onDragEnter(e) {

    e.preventDefault()
    e.stopPropagation()
    
    let draggedOver = e.target
    let draggedFrom = previouslyDraggedOverElement

	mylog("onDragEnter: " + draggedOver.id + " (from " + draggedFrom.id + ")")

    //eliminates error if dragging from outside the plugin
        if(!document.getElementById("ghost")){ 
            mylog("leaving onDragEnter because no #ghost")
            return
        } 

    // first: un-collapse the boneyard if hovering it
        if (draggedOver.classList.contains("boneyard") && $id("flexiContainer").classList.contains("boneyardIsClosed")){
            $id("flexiContainer").classList.remove("boneyardIsClosed")
            closeBoneyardAfter = true
        }

    // setting areas that will keep any active dropDiv alive
        if (draggedOver.id == "dropDiv") return
        if (draggedOver.classList.contains("level1") && !$id("ghost").firstChild.classList.contains("synopsis")) return

    // disallow drop next to the object being dragged
    if ([...draggedOver.classList].includes("beingDragged") || draggedFrom && [...draggedFrom.classList].includes("beingDragged")){
        closeDropZone()
        return
    }
}

function onDragLeave(e) {

    flexiContainer.classList.toggle("not-allowed", false)   

    e.preventDefault()
    e.stopPropagation()

}

function closeDropZone(timer){

    mylog("from " + closeDropZone.caller.name)

    //re-hide expanded synopsiscontainers
        let emptyContainers = $$(".temporarilyShowSynopsisContainer")
        for (let container of emptyContainers){
            container.classList.remove("temporarilyShowSynopsisContainer")
        }

    previousDropZonePosition = false
    previouslyDraggedOverElement = false
    previousBeforeOrAfter = false
    
    if(!$id("dropDiv")) {
        mylog("there was no dropdiv to close, duh")
        return
    }

    if(!timer || timer == 0){clearTimeout(dropDivCloserTimer)}

    dropDivCloserTimer = setTimeout(function() {
        $id("dropDiv")?.remove()
            //mylog("removal fired and executed")
        }, timer || 0)
    
    mylog("done closing the DropZone")
}

function onDragOver(e) {
    
    e.preventDefault()
    e.stopPropagation()

    // Don't let anything be dragged into FTOutliner from outside
        if(!document.getElementById("ghost")){
            mylog("CANCELLING because no #ghost")
            return
        } 

    let draggedOver = e.target

    // // be generous when draggedover is boneyard
    //     //this allows it to pass the gatekeeper below, 
    //     //but helps only for sections. 
    //     if (draggedOver.classList.contains("boneyard")){
    //         draggedOver = $(".boneyard").lastChild
    //         mylog("changing to lastchild bc dragging over empty boneyard")
    //     }

    // setting areas that will cancel any avtive dropDiv
        if (draggedOver.id == "dropDiv") return 
        //if (draggedOver.classList.contains("level1") && !$id("ghost").firstChild.classList.contains("synopsis")) return

        //fri 13 -- just re-allowed dragging over level1

    //Gatekeeper for synopsis, which will send us away. So all below this statement is NOT synopsis
        if($id("ghost").firstChild.classList.contains("synopsis")){ 
            //if(draggedOver != previouslyDraggedOverElement){
                onDragOverForSynopsis(e, draggedOver, previouslyDraggedOverElement)
                    previouslyDraggedOverElement = draggedOver
                    previousBeforeOrAfter = beforeOrAfter
            //}       
            return
        }

    //Gatekeeper for section, which will send us away. So all below this statement is NOT section either
        if($id("ghost").firstChild.classList.contains("section")){ //gatekeeper for section, all below this line is NOT section
            if(draggedOver != previouslyDraggedOverElement){
                onDragOverForSections(e, draggedOver)
                    previouslyDraggedOverElement = draggedOver
                    previousBeforeOrAfter = beforeOrAfter
            }       
            return
        }

    //Only scenes remain -- so now let's send us away no matter what
        onDragOverForScenes(e, draggedOver)
        previouslyDraggedOverElement = draggedOver
        previousBeforeOrAfter = beforeOrAfter
    
}

function onDragOverForSynopsis(e, draggedOver, previouslyDraggedOverElement){

    mylog ("now: " + draggedOver.classList)
    mylog ("prev: " + previouslyDraggedOverElement?.classList)

    //expand scene dots and return
    if (draggedOver.classList.contains("scene") &&
        !draggedOver.closest(".section")?.classList.contains("isExpanded") &&
        documentSetting.indexCardMode){
            draggedOver.closest(".section")?.classList.add("isExpanded")
            return
    }
    //expand section and return
    if (draggedOver.classList.contains("section-heading") &&
             draggedOver.closest(".section").classList.contains("collapsedSection")) {
        draggedOver.closest(".section").classList.remove("collapsedSection")
        return
    }
    //when dragging synopsis in non-index mode, to show droppable area
    if (draggedOver.classList.contains("scene") || draggedOver.classList.contains("sceneheading")){
        draggedOver.closest(".scene").classList.add("temporarilyShowSynopsisContainer")
        return
    }
    //if Drop-Div open and hovered, do nothing
    if (draggedOver.classList.contains("dropDiv")) {
        return
    }

    //set behavior
    let theBehavior

    if (draggedOver.classList.contains("synopsiscontainer")){
        theBehavior = "synopsiscontainer"
    }else if (draggedOver.classList.contains("synopsis")
         && !draggedOver.classList.contains("beingDragged")){
            theBehavior = "synopsis"
    }else{
        closeDropZone()
        return
    }

    if (theBehavior == "synopsiscontainer"){

        if(draggedOver.lastChild?.classList.contains("beingDragged")){
            mylog("disallowing drop in container that ends with dragged synopsis")
            return
        }
        
        if($id("dropDiv")) $id("dropDiv").remove()

        let dropDiv = document.createElement('div')

            dropDiv.id = "dropDiv"
            dropDiv.classList.add("synopsisDrag")
            dropDiv.innerHTML = ""

            let closestSceneOrSection = draggedOver.closest(".scene, .section, .faux") || 0
                dropDiv.dataset.insertBeforeScene = Number(draggedOver.lastChild?.id) + 1 || closestSceneOrSection.id + 1
            
                dropDiv.dataset.dropSynopsisHere = draggedOver.lastChild?.dataset.lineEnd || draggedOver.closest(".scene, .section").dataset.lineEnd
            
                mylog("EMPTY container, so setting dropSynopsisHere to " + dropDiv.dataset.dropSynopsisHere)
                //For now dragging synopsis works like this: 
                //if there is a dataset.dropSynopsisHere, synopsis will be dropped there. 

        closeDropZone()
        draggedOver.appendChild(dropDiv)

        mylog("dropdiv appended as child to container")
    }


    if(theBehavior == "synopsis"){

        beforeOrAfter = "afterend"

            let bounding = draggedOver.getBoundingClientRect()
            let y = e.clientY
                if (y - bounding.top < (bounding.bottom - bounding.top)/2) {beforeOrAfter = "beforebegin"}
            
            if (beforeOrAfter == "afterend" && draggedOver.nextSibling?.classList.contains("beingDragged")
                || beforeOrAfter == "beforebegin" && draggedOver.previousSibling?.classList.contains("beingDragged"))
                {
                    mylog("HOVERING SELF")
                    return
                }

        mylog("now lets create: " + beforeOrAfter)
        
        if($id("dropDiv")){$id("dropDiv").remove()}

        let dropDiv = document.createElement('div')

            dropDiv.id = "dropDiv"
            dropDiv.classList.add("synopsisDrag")
            dropDiv.innerHTML = ""

        closeDropZone()
        draggedOver.insertAdjacentElement(beforeOrAfter, dropDiv)

        dropDiv.dataset.insertBeforeScene = Number(draggedOver.id) + 1
        dropDiv.dataset.dropSynopsisHere = draggedOver.dataset.lineEnd
        mylog("setting dropSynopsisHere to " + dropDiv.dataset.dropSynopsisHere)
        if (beforeOrAfter == "beforebegin"){
            dropDiv.dataset.insertBeforeScene = Number(draggedOver.id)
            dropDiv.dataset.dropSynopsisHere = draggedOver.dataset.line
            mylog("setting dropSynopsisHere to " + dropDiv.dataset.dropSynopsisHere)
        }

        mylog("dropdiv appended as sibling " + beforeOrAfter + " of a synopsis")
    }

}

function onDragOverForSections(e, draggedOver){

    mylog ("onDragForSections: " + draggedOver.classList)
    
    //on top of already open DropDiv so goodbye
    if (draggedOver?.classList.contains("dropDiv")) { return }

    //making target a section if it isn't already
    if (!draggedOver?.classList.contains("section")){ draggedOver = draggedOver.closest(".section") }

    //bad target, so goodbye
    if (!draggedOver || draggedOver.classList.contains("flexiContainer")){
        closeDropZone()
        return
    }

    //disallow dragging an #ACT into the #BONEYARD
    if ($id("ghost").firstChild.classList.contains("level1") && draggedOver.classList.contains("boneyard")){
        flexiContainer.classList.toggle("not-allowed", true)   
        return
    }

    //after or before?
        beforeOrAfter = "afterend"
            let bounding = draggedOver.getBoundingClientRect()
            let y = e.clientY
                if (y - bounding.top < (bounding.bottom - bounding.top)/2) {beforeOrAfter = "beforebegin"}

    //although if dragging act, reconsider after and before (plus make draggedover an act too)
    let actDrag = false
        if ($id("ghost").firstChild.classList.contains("level1")){
            
            beforeOrAfter = "beforebegin"
                let x = e.clientX
                if (x - bounding.left > (bounding.right - bounding.left)/2) beforeOrAfter = "afterend"

            draggedOver = draggedOver.closest(".level1")
            actDrag = true
        }
        
    //don't open dropdiv if dropping next to myself
        if (beforeOrAfter == "afterend" && draggedOver.nextSibling?.classList.contains("beingDragged")
        || beforeOrAfter == "beforebegin" && draggedOver.previousSibling?.classList.contains("beingDragged")
        || draggedOver.classList.contains("beingDragged"))
        {
            mylog("hovering self so returning")
            return
        }

    //DROP DIV CREATION!
        mylog("now lets create the DropDiv: " + beforeOrAfter)
        
        $id("dropDiv")?.remove()
        
        let dropDiv = document.createElement('div')

            dropDiv.id = "dropDiv"
            dropDiv.classList.toggle("actDrop", actDrag)    
            dropDiv.innerHTML = ""

        
    //find place to insert the dropDiv
        let insertBeforeScene = Number(draggedOver.nextSibling?.id)

        if (!insertBeforeScene){
        insertBeforeScene = Number(draggedOver.id) + 1
            if(!actDrag){
                while(outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString != "Section"){
                    insertBeforeScene ++
                }
            }else{
                while(outline[insertBeforeScene] && outline[insertBeforeScene].sectionDepth != 1){
                    insertBeforeScene ++
                }
            }
        }

        dropDiv.dataset.insertBeforeScene = insertBeforeScene
            if (beforeOrAfter == "beforebegin"){
                dropDiv.dataset.insertBeforeScene = Number(draggedOver.id)
            }

    //now adjusting everything if draggedOver was level1 (fri 13)
    //but only if we are NOT dragging an entire act! (2023-01-05)
        if(draggedOver.classList.contains("level1") && !$id("ghost").firstChild.classList.contains("level1")){
                        
            // first correctly store drop index
            //dropDiv.dataset.insertBeforeScene = Number(draggedOver.id) + 1 //changed 2023-01-04
            dropDiv.dataset.insertBeforeScene = Number(draggedOver.id)
                if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section")){
                    dropDiv.dataset.insertBeforeScene = outline.length + 1
                    //this only works because boneyard must ALWAYS be last act in outline
                }

            // then: this nicely positions the insertion point
            if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section")){
                draggedOver = draggedOver.lastChild
                beforeOrAfter = "afterend"
            }else{

                dropDiv.dataset.insertBeforeScene = Number(draggedOver.id) + 1
                draggedOver = draggedOver.querySelector(".section-heading")
                beforeOrAfter = "afterend"
            }

        }


        closeDropZone()
        draggedOver.insertAdjacentElement(beforeOrAfter, dropDiv)
        dropDiv.classList.add("dropZone")

    mylog("dropdiv appended as sibling " + beforeOrAfter + " of a section")
}

function onDragOverForScenes(e, draggedOver){

    mylog ("onDragOverForScenes: " + draggedOver.classList)

    if (draggedOver.classList.contains("dropDiv")) {
        return
    }

    // Gatekeeper to throw out all invalid drop-places
        if (!draggedOver.classList.contains("scene") 
            && 
        !draggedOver.classList.contains("sceneheading")
            && 
        !draggedOver.classList.contains("section-heading")
            &&
        !draggedOver.classList.contains("synopsis")
            &&
        !draggedOver.classList.contains("level1") //re-allows level1 on Fri 13
            &&
        !draggedOver.classList.contains("synopsiscontainer"))
        {
            mylog("the gatekeeper: we hovered an invalid place")
            closeDropZone()
            return
        }

    // One more gatekeeper to avoid dropping above act header
    // removed Fri 13
        // if(draggedOver.classList.contains("section-heading") 
        //     &&
        //     draggedOver.closest(".section").classList.contains("level1")        
        // ){
        //     closeDropZone()
        //     return
        // }


    let hoveringSection = false

    if (draggedOver.classList.contains("synopsis") 
        || draggedOver.classList.contains("synopsiscontainer") ){
            draggedOver = draggedOver.closest(".scene") || draggedOver.closest(".section").querySelector(".section-heading")
    }

    if(draggedOver.classList.contains("section-heading") || draggedOver.classList.contains("boneyard"))
        {
        hoveringSection = true
    }else if (!draggedOver.classList.contains("scene")){
        // try {
            draggedOver = draggedOver.closest(".scene")
        // }catch{
        //     draggedOver = null
        //     closeDropZone(500)
        //     return
        // }
    }

    // if (!draggedOver || draggedOver.classList.contains("level1")){
    // re-allows level1 Fri 13
    if (!draggedOver){
        mylog("no draggedOver")
        // closeDropZone(500)
        closeDropZone()
        return
    }

    //expand scene dots
        if (draggedOver.parentNode?.classList.contains("section") &&
            !draggedOver.parentNode?.classList.contains("level1") &&
            !draggedOver.parentNode?.classList.contains("isExpanded") &&
            documentSetting.indexCardMode){
                draggedOver.closest(".section")?.classList.add("isExpanded")
                return
        }

    mylog("Now setting bounding for what we hover")
    // mylog("which by the way is a " + draggedOver.classList)
    // mylog("and hoveringsection is " + hoveringSection)

    //setting boundings -- simple, unless hovering section

    let bounding = draggedOver.getBoundingClientRect()

        if(hoveringSection && !draggedOver.closest(".section").classList.contains("level1")){
            
            let sectionbounding = {}

            let boundingForHeading = draggedOver.closest(".section").querySelector(".section-heading").getBoundingClientRect()
            sectionbounding.top = boundingForHeading.top
            sectionbounding.bottom = boundingForHeading.bottom

            if(documentSetting.indexCardMode && !draggedOver.closest(".section").classList.contains(".collapsedSection")){

                boundingForContainer = draggedOver.closest(".section").querySelector(".synopsiscontainer").getBoundingClientRect()
                sectionbounding.bottom = boundingForContainer.bottom
            }

            bounding = sectionbounding
        }else if(hoveringSection && draggedOver.closest(".section").classList.contains("level1")){
            draggedOver = draggedOver.closest(".level1")
        }

    //after or before?
        beforeOrAfter = "afterend"
            let y = e.clientY
                if (y - bounding.top < (bounding.bottom - bounding.top)/2) {beforeOrAfter = "beforebegin"}

    
    //don't open dropdiv if dropping next to myself
        if (beforeOrAfter == "afterend" && draggedOver.nextSibling?.classList.contains("beingDragged")
        || beforeOrAfter == "beforebegin" && draggedOver.previousSibling?.classList.contains("beingDragged")
        || draggedOver.classList.contains("beingDragged"))
        {
            mylog("hovering self so returning")
            return
        }

    //DROP DIV CREATION!
        mylog("now lets create the DropDiv: " + beforeOrAfter)
        
        let dropDiv = document.createElement('div')

        dropDiv.id = "dropDiv"    
        dropDiv.innerHTML = ""
            
        if($id("dropDiv")){$id("dropDiv").remove()}
        
    
    //inserting it before next sibling, or in lack thereof parents next sibling! 

    let insertBeforeScene = draggedOver.id //default if beforeOrAfter == beforebegin

    if(draggedOver.classList.contains("scene") && beforeOrAfter == "afterend"){
        insertBeforeScene = draggedOver.nextSibling?.id 
                                ||
                            draggedOver.closest(".section")?.nextSibling?.id
                            //this works for everything except last item before higher-level section
    }
    mylog("post first half: " + insertBeforeScene)

    if (hoveringSection){

        mylog("yes to hovering section[-heading]")

        insertBeforeScene = draggedOver.closest(".section").id

        if (beforeOrAfter == "afterend"){
            
            insertBeforeScene = Number(draggedOver.closest(".section").querySelector(".scene")?.id)
                                    ||
                                Number(draggedOver.closest(".section")?.nextSibling?.id)

            mylog("half way down in if, insertBefore... = " + insertBeforeScene)
        }
    }

    if (!insertBeforeScene) {
                insertBeforeScene = Number(draggedOver.closest(".section").id) + 1
                while(outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString != "Section"){
                    insertBeforeScene ++
                }
    }
    
    mylog("we are here" + draggedOver.classList)
    //now adjusting everything if draggedOver was level1 (fri 13)
    if(draggedOver.classList.contains("level1")){

            if (draggedOver.querySelector(".scene, .section") && !draggedOver.classList.contains("boneyard")){mylog(1); return}
            // so below this point only applies to empty acts, or boneyard regardless
            
            // first correctly store drop index
            insertBeforeScene = Number(draggedOver.id) + 1
                if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section, .orphanText")){
                    
                    insertBeforeScene = outline.length + 1
                    //this only works because boneyard must ALWAYS be last act in outline
                }

            // then: this nicely positions the insertion point
            // if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section, .orphanText")){
            if (draggedOver.classList.contains("boneyard") && draggedOver.querySelector(".scene, .section")){
                draggedOver = draggedOver.lastChild.lastChild || draggedOver.lastChild || draggedOver.querySelector(".section-heading")
            }else{
                draggedOver = draggedOver.querySelector(".section-heading")
            }
            beforeOrAfter = "afterend"

            hoveringSection = false //or else adjustments are made before creating the dropdiv
        }

    //inserting the new dropDiv -- waiting until counting siblings to not confuse things!
    if (hoveringSection){
        mylog("if hovering section")
        if(beforeOrAfter == "afterend"){
            closeDropZone()
            draggedOver.querySelector(".synopsiscontainer")?.insertAdjacentElement(beforeOrAfter, dropDiv)
        }else{
            closeDropZone()
            draggedOver.closest(".section")?.insertAdjacentElement(beforeOrAfter, dropDiv)
        }
    }else{
        mylog("else for hovering section")
        closeDropZone()
        mylog(beforeOrAfter + " and " + draggedOver.data + " from " + draggedOver.parentNode.classList + " below " + draggedOver.parentNode.parentNode.classList)
        draggedOver.insertAdjacentElement(beforeOrAfter, dropDiv)
    }

    mylog("next: sibling logic done")

    dropDiv.classList.add("dropZone")
    dropDiv.dataset.insertBeforeScene = insertBeforeScene

    mylog("dropdiv appended as sibling " + beforeOrAfter + " of a scene")
}

function onDrop(e){

    if(!$id("dropDiv")) return

    console.time("dropped")

    //End of gatekeeping

    mylog("moveTheScenes(" + e + ")")
    let synopsisDrag = false
        dropTookPlace = true
    
    let selectedScenes = document.querySelectorAll('.beingDragged')
        if (selectedScenes.length == 1 && selectedScenes[0].classList.contains("synopsis")){
            synopsisDrag = true
        }

    if(!synopsisDrag){

        firstScene = selectedScenes[0].id
        lastScene = selectedScenes[selectedScenes.length - 1].id

        insertBeforeScene = $id("dropDiv").getAttribute("data-insert-before-scene") // written into dropdiv at creation: dataset.beforeScene

        //check if we are dropping next to an omitted scene, and if so CANCEL! Added 2023-10-25 to avoid fountain logic issues
            let sceneBelowDroppedWasOmitted = (outline[insertBeforeScene - 1].omitted)
            let sceneAboveDroppedWasOmitted = (outline[insertBeforeScene]?.omitted)
                if(sceneBelowDroppedWasOmitted || sceneAboveDroppedWasOmitted){
                    Beat.call(`Beat.alert("Cannot drop immediately before or after an omitted (hidden) scene", "Due to the fountain logic for hiding scenes, dropping scenes adjacent to hidden ones is a very risky business that may end up hiding text you want to display, or showing text you dont.\\n\\nPlease manually unhide or delete the hidden scenes before moving scenes around.")`)
                    onDragEnd(false, true)
                    return                    
                }
    
    }else{

        if(selectedScenes[0].dataset.synopsisNumber){
            
            //new model:
            firstScene = selectedScenes[0].id
            lastScene = firstScene
            rangeStart = selectedScenes[0].dataset.line  //text TO BE moved
            rangeEnd = selectedScenes[0].dataset.lineEnd //text TO BE moved

        }

        insertBeforeScene = $id("dropDiv").getAttribute("data-insert-before-scene")
    }
    mylog("insert before" + insertBeforeScene)
    
    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    let synopsisMove = $id("dropDiv").dataset.dropSynopsisHere || null

    // alertThis(synopsisMove)
    // if(synopsisMove)Beat.call("Beat.scrollTo(" + synopsisMove + ")") 

    if(firstScene.includes("_")) firstScene = firstScene.replace(/_.*/, "").replace(/^s/, "")
    if(lastScene.includes("_")) lastScene = lastScene.replace(/_.*/, "").replace(/^s/, "")
    if(insertBeforeScene.includes("_")) insertBeforeScene = insertBeforeScene.replace(/_.*/, "").replace(/^s/, "")
    
    //new method of sending data: sending explicit range. Still sending "scenes" as a security measure though, in case used in the plugin code.
    //even newer, since 1.977: sending explicit drop-position for synopsis 
    //also sending makeCopy, which leaves the original in place!
    let makeCopy = altIsBeingPressed
    Beat.call("Beat.custom.moveScenes(" + firstScene + ", " + lastScene + ", " + insertBeforeScene + ", " + userDefault.warningsAreOn + "," + rangeStart + "," + rangeEnd + "," + synopsisMove + "," + makeCopy +")")
    rangeStart = false
    rangeEnd = false
}

function ifYesToMove(){ //this is visually-related stuff only and does not alter any actual data 
    
    console.timeEnd("dropped")

    mylog("Now shrinking the scenes.")

    flexiContainer.classList.add("wait")
    
    //Disallow dragging until the outline has updated!
        let allDraggables = $$("[draggable=true]")
        for (draggable of allDraggables) {
            draggable.draggable = false
            draggable.classList.add("usedToBeDraggable")
        }

    let secondClone = document.createElement("div")
    secondClone.id = "clone"
    let tmp = 0
    let cloneName

    let selectedScenes = document.querySelectorAll('.beingDragged')

    mylog("before loop")

    for (scene of selectedScenes){
        if (sectionLevelDrag && scene != selectedScenes[0]){continue}
        scene.classList.add("longerAnimation")
            tmp++; cloneName = "tmp" + tmp
            clone = scene.cloneNode(true)
            clone.id = cloneName
            clone.classList.add("countMeOut") //this is all a convoluted way when preserving open and collapsed sections... phew...
            clone.classList.add("longerAnimation", "shrinkToNone")
            clone.classList.remove("beingDragged", "isSelected")
            document.getElementById("dropDiv")?.insertAdjacentElement("beforebegin", clone)
            onlyToProvokeAnimation = document.getElementById(cloneName).getBoundingClientRect()         
            document.getElementById(cloneName).classList.remove("shrinkToNone")
        scene.classList.add("shrinkToNone")
    }
    setTimeout(function(){
        for (scene of selectedScenes){
            let redraw = scene.getBoundingClientRect()

            scene.style.opacity = "1"
            scene.style.height = "0"
            scene.style.minHeight = "0"
            scene.style.margin = "0"
        }
        
        if (closeBoneyardAfter){
            $id("flexiContainer").classList.add("boneyardIsClosed")
            closeBoneyardAfter = false
        }
    },500)

    mylog("after loop")

    closeDropZone()

    if($id("dropDiv")){

        $id("dropDiv").classList.remove("over")
        onlyToProvokeAnimation = $id("dropDiv").getBoundingClientRect()         
        $id("dropDiv").classList.add("longerAnimation")
        $id("dropDiv").classList.remove("dropZone")

    mylog("now remains only to remove ghost")
    }else{mylog("no dropDiv!!!")}

    if(!$id("ghost"))mylog("no ghost!!!")

    document.getElementById("ghost")?.remove()

    

    mylog("done")
}

function makeGhost(e, selectedScenes,icamefrom){

    mylog ("from " + icamefrom + " -- and with so many selected scenes: " + selectedScenes.length)

    $id("flexiContainer").classList.remove("positionRelative") //or else Ghost Image will be invisible
    if($id("ghost")){$id("ghost").remove()}
    let allActs = $$(".level1")
        for (act of allActs) act.style.pointerEvents = "all" // allows ACTS to set boundaries for droppable area (so that dropping on flexicontainer cancels)
    
    //set the ghost image
    let ghost = document.createElement("div")
        ghost.id = "ghost"
        ghost.classList.add("ghost")
        ghost.classList.add("isExpanded")
        ghost.style.top = (window.innerHeight * 2) + "px"
        ghost.style.width = window.getComputedStyle(selectedScenes[0]).getPropertyValue("width")

    //if no selected scenes, make the one dragged selected instead
        //let selectedScenes = document.querySelectorAll('.isSelected')
        if (selectedScenes.length < 1) {selectedScenes = [e.target]}
    
    for (scene of selectedScenes){
        clone = scene.cloneNode(true)
        clone.classList.remove("beingDragged")
        // clone.classList.remove("isSelected")

        if (scene.classList.contains("synopsis") && !scene.style.background){
            clone.style.background = "white"
            clone.style.color = "black"
        }
                
        if (sectionLevelDrag && scene == e.target){ //selects entire sequence if dragging a section head
            ghost.appendChild(clone)
        }
        else if (!sectionLevelDrag && ([...clone.classList].includes("scene") || [...clone.classList].includes("synopsis") )){
            ghost.appendChild(clone)
        } 
        
        scene.classList.add("beingDragged")
        scene.classList.remove("isSelected")
    }

    mylog("setting range to move")

    if (!ghost.firstChild?.classList.contains("synopsis")){ //determine range + highlight for SCENES/SECTIONS

        //highlight all text affected in move; also determining the correct movable range
        rangeStart = outline[selectedScenes[0].id].sceneStart
        rangeEnd = outline[selectedScenes[selectedScenes.length-1].id].sceneEnd

    }else{ //do the same if SYNOPSIS
        
        // if([...clone.classList].includes("synopsis") && !sectionLevelDrag){
        // if(ghost.firstChild?.classList.contains("synopsis")){
            
        if(ghost.firstChild.dataset.synopsisNumber){ //new model
            mylog("setting synopsis range, new model")

            rangeStart = ghost.firstChild.dataset.line  //this should be renamed position or index...
            rangeEnd = ghost.firstChild.dataset.lineEnd  

        }else{ //old model

            mylog("setting synopsis range, old model")

            rangeStart = outline[selectedScenes[0].id].sceneStart
            rangeEnd = outline[selectedScenes[selectedScenes.length-1].id].sceneStart + 
                outline[selectedScenes[selectedScenes.length-1].id].line.string.length + 1
        }

    }
        mylog("after fixing synopsis range")
        Beat.call("Beat.scrollTo(" + rangeStart + ")") 		
        Beat.call("Beat.setSelectedRange(" + rangeStart + ", " + (rangeEnd - rangeStart) + ")")

        // This is a debugging tool that will bring the text into the html for evaluation purposes!
            // globalStartTime = new Date()
            Beat.call("Beat.custom.sendTextToHTML(" + rangeStart + "," + rangeEnd+ ")") 
            // Beat.call("Beat.custom.sendTextToHTML()") 

        mylog("past setting ranges")

    
    //create ghost image
    $id("flexiContainer").appendChild(ghost)
    let offsetX = 20 // parseInt(window.getComputedStyle($id("ghost")).getPropertyValue("width")) * 0.9 // /2
    let offsetY = 0 // parseInt(window.getComputedStyle($id("ghost")).getPropertyValue("height")) * 0.9 /2
    mylog("before firstchild if")

    e.dataTransfer.setDragImage(document.getElementById("ghost"), offsetX, offsetY);
    
    mylog("end of ghost function")
}

function receiveText(allText, startIndex, endIndex){

    mylog("receiveText()")

    entireScreenplay = allText
    let selectedScreenplay = allText.substr(startIndex, endIndex-startIndex)

}

</script><!-- ================================================== -->
<!--      THIS IS ALL THE HARD-CODED HTML WE GET:       -->
<!-- ================================================== -->

<div id="flexiContainer" class="flexiContainer"></div> 
<div id="cover" class="blurWindow" style="display: none" onclick="closeNewMenu(); toggleTrackingContainer(true); storeAndClosePrintbox(false)"></div>
<!-- <pre id="dumpDiv" style="padding: 10px; bottom: 10px; left: 10px; border-radius: 5px; pointer-events: none; position: absolute; white-space: pre-wrap; background-color: rgba(255,255,255,0.7); font-size: 9px"></pre> -->

<div id="buttonRow">
	<div id="helpButton" class="bottomButton" onclick="mylog('clicked settingsButton'); toggleNewMenu('settingsMenu')"></div>
	<div id="printButton" class="bottomButton" onclick="mylog('clicked exportButton'); toggleNewMenu('exportMenu')"></div>
	<div id="infoField"></div>
	<div id="saturationSlider"><input type="range" min="0" max="100" value="50" class="slider" step="10" style="direction: rtl;" id="saturationRange" oninput="changeSaturation()"></div>
	<div id="indexCardButton" class="bottomButton" onclick="mylog('clicked indexCardButton'); toggleNewMenu('indexCardMenu')"></div>
	<div id="showStuffButton" class="bottomButton" onclick="mylog('clicked stuffButton'); toggleNewMenu('showStuffMenu')"></div>
	<div id="notesButton" class="bottomButton" onclick="mylog('clicked notesButton'); toggleNewMenu('notesMenu')"></div>
	<div id="characterButton" class="bottomButton" onclick="mylog('clicked TrackingButton'); toggleNewMenu('trackingMenu')"></div>
	<div id="zoomButton" class="bottomButton" onclick="mylog('clicked zoomButton'); toggleNewMenu('zoomMenu')"></div>
</div>
<div id="notepanelOpener" onclick="toggleNotepanel()"></div>

<div id="notepanel" class="">
	<div id="tabsRow">
		<div class="tab notetab selectedtab" onclick="cycleTabs(event.target)">Notes
		</div>
		<div class="tab dialogtab" onclick="cycleTabs(event.target)">Dialogue
		</div>
		<div class="tab scenestab" onclick="cycleTabs(event.target)">Scenes
		</div>
		<div class="closetab" onclick="toggleNotepanel()">×
		</div>
	</div>
	<div id="notepanelbuttons">
	</div>
	<div id="dialogpanelbuttons">
		<div class="hasSelect dropDownSpan">
			<select id="allDialogFor" class="colorDropdown" onchange="showCharacterBubbles()">
				<option></option>
			</select>
		</div>
		<div id="dialogSearchIcon" class="dialogSearchIcon"></div>
		<input id="dialogsearch" class="dialogsearch" type="text" spellcheck="false" placeholder="search for..." oninput="onlyShowMatchingDialogs()" onfocus="toggleCaptureKeypresses(false)" onblur="toggleCaptureKeypresses(true)" onkeydown="searchboxlisten(event)">
		<div id="clearSearchButton" onclick="clearSearchBox()">×</div>
	</div>
	<div id="scenespanelbuttons">
	</div>
	<div id="notepanelcontent" onscroll="setScrollShadow()">
	</div>
	<div id="dialogpanelcontent">
	</div>
	<div id="scenespanelcontent" class="scenespanelcontent" onclick="deselectAllScenepanelItems()" onscroll="setScrollShadow()">	
		<div id="dividerline"></div>
	</div>
	<div id="drag-bar" onmousedown="resizeNotepanel()" ondblclick="toggleNotepanel()"></div>
</div>

<!-- ================================================== -->
<!--      HERE ENDS THE HTML PART, JAVASCRIPT BELOW     -->
<!-- ================================================== -->

<script>

//MARK: - all the buttons are here

document.addEventListener("dblclick", function(event){
	event.preventDefault()
	event.stopPropagation()
	mylog(event)			
	editContent(event)
})

$id("flexiContainer").addEventListener("contextmenu", function(event){
	if(event.metaKey && event.altKey) return // so as not to get contextmenu when ctrl+alt+cmd is pressed
	event.preventDefault()
	event.stopPropagation()
	mylog(event)			
	displayContextMenu(event)
})
$id("notepanel").addEventListener("contextmenu", function(event){
	if(event.metaKey && event.altKey) return // so as not to get contextmenu when ctrl+alt+cmd is pressed
	event.preventDefault()
	event.stopPropagation()
	mylog(event)			
	displayContextMenu(event)
})

$id("flexiContainer").ondragstart = function(event){onDragStart(event)}
$id("flexiContainer").ondragend = function(event){onDragEnd(event)}
$id("flexiContainer").ondragenter = function(event){onDragEnter(event)}
$id("flexiContainer").ondragleave = function(event){onDragLeave(event)}
$id("flexiContainer").ondragover = function(event){onDragOver(event)}
$id("flexiContainer").ondrop = function(event){onDrop(event)}
$id("flexiContainer").onscroll = function(){flexiContainer.style.setProperty("--flexiScroll", flexiContainer.scrollTop) + "px"}
$id("flexiContainer").classList.add("positionRelative")

document.getElementById("indexCardButton").innerHTML = outlineIcon
document.getElementById("characterButton").innerHTML = funnelIcon + `<div id="selectedCharacterName"></div>`
document.getElementById("showStuffButton").innerHTML = showIcon
document.getElementById("helpButton").innerHTML = gearIcon
document.getElementById("printButton").innerHTML = printerIcon
document.getElementById("notesButton").innerHTML = noteIcon
document.getElementById("zoomButton").innerHTML = zoomIcon
document.getElementById("dialogSearchIcon").innerHTML = searchIcon
document.getElementById("saturationSlider").innerHTML += paletteIcon

if(!document.createElement('dialog').showModal){
	alertThis("Please update your Safari browser", "Beat plugins use WebKit to run, and FTOutliner uses features that were introduced with Webkit version 613.1.17 (which corresponds to Safari 15.4). \\n\\nPlease update your Safari to at least that version, or you may experience unexpected behavior from FTOutliner.")
}

// GLOBAL UI VARIABLES

	let smallTypeTimer //= null; //setting initial timer to avoid errors	
	let fullTypeTimer //= null;
	var settingsContainerVisibility = 0;
	var trackingContainerVisibility = 0;
	var helpContainerVisibility = 0;
	var notesAreDisplayed = false;
	var markersAreDisplayed = false;
	var synopsisAreDisplayed = false;
	var beatsAreDisplayed = false;
	var scenesAreHidden = false;
	var currentZoomLevel;

	var settingsContainer = document.getElementById('settings');
	var trackingContainer = document.getElementById('tracking');
	var helpContainer = document.getElementById('helpWindow');
	var coverContainer = document.getElementById('cover');
	var theRoot = document.querySelector(':root');
	var blockOrNone = ['block', 'none'];

	var classListArray = []

	var contextMenuIsOpen = false

	var logArray=[]

// GLOBAL DEFAULT VARIABLES

	var showSceneLengths, showSceneNumbers, showPageNumbers, realTimeIsOn

// GLOBAL DOCUMENT-RELATED VARIABLES

	var outline, pages
	var heightFactor = 10 //initial value if all else fails

	var currentSectionDepth;
	var previousSectionDepth;
	var lastIndexOfScene;
	var currentLine;

	var lengthOfScene = [];
	var lengthOfSceneInEights = [];
	var outlineElementNumber
	var actNumber, endElement
	var location, length 

	var omittedNumber

	var firstLineThatIsNoSynopsis = 0
	var selectedNote = -1
	var previouslyHovered

	var someoneResizedTheWindow = debounce(function() {

		theRoot.style.setProperty('--theDocumentWidth', window.innerWidth)
		theRoot.style.setProperty('--theDocumentHeight', window.innerHeight)
		saveCurrentState()
		recalculateHeights("from someoneResizedTheWindow")
		if(beatsAreDisplayed){toggleDisplayBeats(); toggleDisplayBeats()}
	}, 150);

//	EVENTLISTENER ON LOAD: FETCH DATA FROM PLUGIN, THEN BUILD THE COMPLETE OUTLINE:

window.addEventListener('load', function () {

	flexiContainer.classList.add("focused") //in order to correctly switch focus between main app and plugin right from the start
	setAllEventlisteners()
	getSettings(true) //true means startup, which will trigger the showWelcomeWindow function
	
	Beat.call("Beat.custom.updateEntireOutline()")
	
})

function launchWelcomeDialog(ftoutlinerVersion){
	
	//MOVED THE WELCOME WINDOW TO THE HTML CODE in order to hopefully circumvent weirdness where both windows loaded it

	let showWelcome = userDefault["dontShowWelcomeWindowFor" + ftoutlinerVersion?.replace(".", "")]
		
 	if(!showWelcome){
		Beat.call(`Beat.custom.displaySecondWindow("Welcome", "welcomewindow.html", 800, 650, false)`)
	}
}

//	EVENTLISTENERS FOR keypresses and such
function setAllEventlisteners(){

	window.onerror = function(message, source, lineno, colno, error) {
		mylog("===== ERROR =====", true)
		}

	toggleCaptureKeypresses(true)

	document.addEventListener("mouseup", somethingWasClicked)
	window.addEventListener("resize", someoneResizedTheWindow)
	window.addEventListener("focus", function () {
			flexiContainer.classList.add("focused")	
			if(userDefault.realTimeIsOn == 1) return
			document.getElementById('outOfSyncDiv').style.display = "none";
			firstRun()//should provide loc and len here!	
		});
	window.addEventListener("blur", function () {
			flexiContainer.classList.remove("focused")	
			deselectAllElements()
			collapseNote()
			closeContextMenu()
			saveCurrentState()
			releaseALT()
			if (document.querySelector(".sceneTitlePopup")){document.querySelector(".sceneTitlePopup").remove()}
		});	
	document.addEventListener("mouseover", hover)
	document.addEventListener("mouseleave", unhover) //was moouseout
}

function toggleCaptureKeypresses(on){

	if(on){
		// document.addEventListener("keydown", checkWhatKeyGotPressed)
		document.addEventListener("keydown", keypress)
		document.addEventListener("keyup", checkWhatKeyWasReleased)
	}else{
		// document.removeEventListener("keydown", checkWhatKeyGotPressed)
		document.removeEventListener("keydown", keypress)
		document.removeEventListener("keyup", checkWhatKeyWasReleased)
	}
}

function hover() {
	
	mylog("HOVERING " + event.target.classList)

	let element = event.target

	// $id("buttonRow").innerHTML = element.classList

	//Gatekeeping
		if (weAreCurrentlyEditingText){
			return
		}
		if (JSON.stringify(element.closest(".scene, .section")?.id) == previouslyHovered
			|| element.id == "hiddenSceneTitlePopup"){
				mylog("returning bc previously hovered: " + previouslyHovered)
				return
		}

	//Actual stuff before going to unhover: 
	//NOTEPANEL...
		if(element.classList.contains("notepanelNote") || element.classList.contains("notepanelReview")){
			panelNoteIsHovered(element)
			return
		}
	//BEATS...
		if(element.classList.contains("beat")){
			beatIsHovered(element)
			return
		}
		if(element.classList.contains("review")){
			highlightReviewInPanel(element)
			return
		}
	//markers...
		if(element.classList.contains("marker")){
			return
		}

	unhover()

	//Popping up scene name for small scenes
		if (element.closest(".scene")?.classList.contains("sluglineIsHidden") && !altIsBeingPressed){
			hiddenSlugPopup(element)
		}

	
	currentlyHoveredElement = element // keeps it in mind for ALT-pressing
	
}

function hiddenSlugPopup(element) {

	previouslyHovered = JSON.stringify(element.closest(".scene")?.id)
	currentlyHoveredElement = false

	// let x = parseInt(JSON.stringify(event.clientX))
	// let y = parseInt(JSON.stringify(event.clientY))
	let x = (event.clientX)
	let y = (event.clientY)
	// let y = parseInt(JSON.stringify(element.closest(".scene").getBoundingClientRect().top))
	let width = parseInt(JSON.stringify(element.closest(".scene").getBoundingClientRect().width)) + 20
	let color = window.getComputedStyle(element.closest(".scene")).getPropertyValue('background-color')

	if (x + width > window.innerWidth - 40){
		x = x - width + 20
	}

	let hiddenSceneTitlePopupDiv = document.createElement("div")
		hiddenSceneTitlePopupDiv.id = "hiddenSceneTitlePopup"
		hiddenSceneTitlePopupDiv.innerHTML = element.innerHTML
		hiddenSceneTitlePopupDiv.classList.add("clickThru")
		hiddenSceneTitlePopupDiv.classList.add("sceneTitlePopup")
		hiddenSceneTitlePopupDiv.style.left = (x + 10) + "px"
		// hiddenSceneTitlePopupDiv.style.top = (y - 22) + "px"
		hiddenSceneTitlePopupDiv.style.top = (y + 10) + "px"
		hiddenSceneTitlePopupDiv.style.maxWidth = width + "px"
		hiddenSceneTitlePopupDiv.style.backgroundColor = color
		
		flexiContainer.appendChild(hiddenSceneTitlePopupDiv)

	clearTimeout(popupTimer)
	let elementToGivePopup = $id('hiddenSceneTitlePopup')
	popupTimer = setTimeout(function(){
		elementToGivePopup.classList.add('revealPopup')
			setTimeout(function(){
				elementToGivePopup.classList.remove('revealPopup')
				// elementToGivePopup.remove()
			}, 3000)
		},400
	)
}

function unhover(){

	mylog()

	let element = event.target
	let relatedElement = event.relatedTarget

	if(relatedElement && ([...relatedElement.classList].includes("notepanelNote") || [...relatedElement.classList].includes("notepanelReview"))){
		panelNoteIsUnhovered(relatedElement)
	}

	if(relatedElement && (relatedElement.classList.contains("review"))){
		highlightReviewInPanel()
	}

	if(relatedElement && (relatedElement.classList.contains("beat"))){
		unhoverAllBeats()
	}
	
	previouslyHovered = false
	
	let elements = document.querySelectorAll(".sceneTitlePopup")
	for (i = elements.length - 1; i>-1; i--) {
		elements[i].remove()
	}
}

// MARK: - ========== UPDATING THE TIMELINE ==========

function __________TIMELINE (){}

var typeTimer

function firstRun(location, length){ 
	
	//Called AT STARTUP (and, if non-realtime, WHEN FOCUSED)
	Beat.log("firstRun called")
	mylog()

	weAreCurrentlyEditingText = false
	Beat.call("Beat.custom.updateEntireOutline(" + location + "," + length + ")")

}

function updateEntireOutline(json, location, length, absoluteLength, linesAsJson) {

	mylog()
	$$(".contextMenu").forEach(menu => menu.remove())
	toggleWaitState(true) // probably already turned on elsewhere, but for good measure
	
	// making data global:
		outline = json 
		lines = linesAsJson
		absoluteTextLength = absoluteLength
	
	if(outline.length < 1){displayEmptyScreenMessage(); return}
	
	//Pre-building the outline
		addSceneEnds()
		findPageDividers()

	//Building the outline!
		divMaker() 
		youAreHere(location, length) 
		
	//Post-building the outline: Add data to existing, already painted divs
		if (characterMenuList.selectedIndex != -1){
			collectCharacters()
			updateFilter()
		}
		collectNotes("updateEntireOutline")
		collectReviews()
		collectRevisionIndices()
		updateDialogPanel()
		updateScenePanel()
		updateSelectionInfo()

		toggleWaitState(false)	

		if(weAreCurrentlyEditingText){ // this is if update takes place when live editing outline text -- can this happen??
			exitEdit()
		}

	mylog("End of creating outline, now returning to idle")
}

function addSceneEnds(){

	mylog()

	function hierarchy(obj){
		let level = false
		if (obj.typeAsString == "Section"){level = Number(obj.sectionDepth)}
		if (obj.typeAsString == "Heading"){level = 100}
		if (obj.typeAsString == "Synopse"){level = 1000}
		return level 
	}

	//Insert SceneEnd value, which ends not at next arbitrary outline element, but one which is the same or higher! 
	for (let i = 0; i < outline.length; i++){

		let nextSameLevelObject = i + 1

		while ((nextSameLevelObject < outline.length) 
				&& 
				(hierarchy({...outline[nextSameLevelObject]}) > hierarchy({...outline[i]})
				||
				outline[nextSameLevelObject].omitted //THIS MAKES OMITTED SCENES LIVE INSIDE (AND MOVE WITH) THEIR PREVIOUS SCENES
				)){
			nextSameLevelObject++
		}
		
		outline[i].sceneEnd = (outline[nextSameLevelObject]) ? 
			outline[nextSameLevelObject].sceneStart - 1 : 
			absoluteTextLength
	}
}


function divMaker(){

	mylog()

	let startTime = new Date()

	let start = 0
	let end = outline.length
		// let's try to avoid crashes due to empty outline!
		// this will probably not work, I'm suspecting new outlines can now be pushed from the plugin asynchronosly?
			if (!outline || outline.length < 1) return 

	let newFlexi = document.createElement("div")
	let currentAct = 0
	let actLengths = []
	let actIndex = []
	let alternatePageNumber = 0

	let lowerLevelNum = -1

	for (num = start; num < end; num ++) {

		currentItem = outline[num]

		//first creating a FAUX ACT if doc does not start with a level 1 section
			if (num == 0 && (outline[num].typeAsString != "Section" || outline[num].sectionDepth > 1 /*|| outline[num].sceneStart > frontMatter*/)) {

				actLengths[currentAct] = 0
				currentAct ++
							
				let sectionDiv = document.createElement("div")
					sectionDiv.id = "-1"
					sectionDiv.classList.add("faux")
					sectionDiv.classList.add("section")
					sectionDiv.classList.add("level1")
					sectionDiv.classList.add("isExpanded")

					sectionDiv.dataset.line = 0
					sectionDiv.dataset.lineEnd = Math.max(currentItem.sceneStart - 1, 0)

					sectionDiv.dataset.lengthOfScene = currentItem.numberOfPages
					sectionDiv.dataset.inAct = "0"

				let sectionSynConDiv = document.createElement("div")
					sectionSynConDiv.id = "synopsisFor-1"
					sectionSynConDiv.classList.add("synopsiscontainer")
					sectionSynConDiv.dataset.line = 0
					
					sectionDiv.appendChild(sectionSynConDiv)
					newFlexi.appendChild(sectionDiv)

					let actlengthDiv = document.createElement("div")
						actlengthDiv.classList.add("showActLength")
						sectionDiv.appendChild(actlengthDiv)
					
				}
		
		let color
		switch(currentItem.typeAsString){

			case "Section":

				let parentSection = newFlexi

				if(currentItem.sectionDepth == 1){
					actLengths[currentAct] = currentItem.startsOnPage

					actIndex[currentAct] = currentItem.sceneStart
					currentAct ++
			
				}

				if(currentItem.sectionDepth > 1)lowerLevelNum ++

				for (let i = num; i > -1; i--){

					if (outline[i].typeAsString == "Section" && outline[i].sectionDepth < currentItem.sectionDepth){

						let allParents = newFlexi.querySelectorAll(".level" + outline[i].sectionDepth)
						parentSection = allParents[allParents.length - 1]

						break
					}
				}

				//below: when there is no initial act, put corresponding stuff inside faux act
					if(parentSection == newFlexi && outline[num].sectionDepth > 1){
						parentSection = newFlexi.querySelector(".faux")
					}		
			
				let sectionDiv = document.createElement("div")
					sectionDiv.id = num.toString()
					sectionDiv.dataset.myId = num.toString()
					sectionDiv.classList.add("section")
					sectionDiv.classList.add("level" + currentItem.sectionDepth)
					sectionDiv.dataset.line = currentItem.sceneStart
					sectionDiv.dataset.lineEnd = currentItem.sceneStart + currentItem.line.range.length
					sectionDiv.dataset.lengthOfScene = currentItem.numberOfPages
					sectionDiv.dataset.inAct = currentAct
					sectionDiv.dataset.uuid = currentItem.uuid
					sectionDiv.draggable = true

					color = currentItem.color
					if (color.includes("]") || color.includes('[') || color.split(" ").length > 1){
						color = color.replace(/(\]|\[|\s).*/, "")
					}

					if(color){
						if (color.match(/(#[A-F, 0-9]{6})/i)){
							sectionDiv.style.setProperty("--localColor", color)
						}else{
							sectionDiv.classList.add(color.toLowerCase())
							sectionDiv.style.setProperty("--localColor", `hsl(var(--${color.toLowerCase()}))`)
						}
					}

					if (currentItem.stringForDisplay?.toLowerCase() == "boneyard"
						&&
						currentItem.sectionDepth == 1){
						sectionDiv.classList.add("boneyard")
					}

					if(outlineBeforeUpdate && outline.length == outlineBeforeUpdate.length){
						let isExpanded = cardStateForScenes[num]
						let collapsedSection = cardStateForSections[num]
						let isPinned = $id(num.toString())?.classList.contains("wider")
						if(isExpanded)sectionDiv.classList.add("isExpanded")
						if(collapsedSection && currentItem.sectionDepth > 1)sectionDiv.classList.add("collapsedSection")
						if(isPinned)sectionDiv.classList.add("wider")
					}

				let sectionheaderDiv = document.createElement("div")
					sectionheaderDiv.classList.add("section-heading")
					sectionheaderDiv.dataset.line = currentItem.sceneStart

					if(currentItem.sectionDepth > 0){
						let sectionarrowDiv = document.createElement("div")
							sectionarrowDiv.classList.add("sectionArrow")
							sectionheaderDiv.appendChild(sectionarrowDiv) 

					let infoDiv = document.createElement("div")
						infoDiv.classList.add("sectionInfoDiv")
						sectionheaderDiv.appendChild(infoDiv)
					
					let pagenumberDiv = document.createElement("div")
						pagenumberDiv.classList.add("showSectionPageNumber")
						pagenumberDiv.innerHTML = "Pg " + Math.max(Math.floor(currentItem.startsOnPage), 1) + "."

					let sectionLengthDiv = document.createElement("div")
						sectionLengthDiv.classList.add("sectionLengths")
						sectionLengthDiv.innerHTML = "(--)"

					infoDiv.appendChild(pagenumberDiv)
					// pagenumberDiv.appendChild(sectionLengthDiv)
					infoDiv.appendChild(sectionLengthDiv)
					}

					if(loggingIsOn){sectionheaderDiv.innerHTML += currentItem.uuid + " -- "}
					sectionheaderDiv.innerHTML += currentItem.stringForDisplay.replace(/^#+/, "").replace(/</g, "&lt;")
					if(currentItem.sectionDepth == 1)sectionheaderDiv.innerHTML += `<span class='widerButton'>${pinIcon}</span><span class='widerButtonOn'>${pinPushedIcon}</span>`


				let sectionSynConDiv = document.createElement("div")
					sectionSynConDiv.id = "synopsisContainerFor" + num
					sectionSynConDiv.classList.add("synopsiscontainer")
					sectionSynConDiv.classList.add("noAnimation")
					sectionSynConDiv.dataset.line = currentItem.sceneStart
					
					if(currentItem.sectionDepth == 1){
						sectionSynConDiv.style.backgroundColor = "transparent"
					}

					if(currentItem.numberOfPages > 0){

						let orphanDiv = document.createElement("div")
							orphanDiv.classList.add("orphanText")
							orphanDiv.id = "orphanInside" + num
							orphanDiv.dataset.myId = "orphanInside" + num
							orphanDiv.dataset.line = (currentItem.sceneStart)
							orphanDiv.dataset.lengthOfScene = currentItem.numberOfPages	
						
						if(pageDividers[num]) insertDividersIn(orphanDiv)
						
						sectionDiv.appendChild(sectionheaderDiv)
						sectionDiv.appendChild(orphanDiv)
						orphanDiv.appendChild(sectionSynConDiv)

					}else{

						sectionDiv.appendChild(sectionheaderDiv)
						sectionDiv.appendChild(sectionSynConDiv)
					}

				parentSection.appendChild(sectionDiv)

				if(currentItem.sectionDepth == 1){
					actlengthDiv = document.createElement("div")
					actlengthDiv.classList.add("showActLength")
					sectionDiv.appendChild(actlengthDiv)
				}

				if(currentItem.synopsis && currentItem.synopsis.length > 0){ //this will put synopsis into place (for sections) for version 1.977 and on
					for (let synopsisItem of currentItem.synopsis){
						synopsisMaker(synopsisItem)
					}
				}

				break

			case "Heading":

				let allSections = newFlexi.querySelectorAll(".section")
				let lastSection = allSections[allSections.length - 1]
				let lockedString = ""
				let sceneNumber = currentItem.sceneNumber
					if (currentItem.omitted == 1){sceneNumber = "OMITTED"}
				
				if (/(?:#)(.+)(?:#){1}\s*$/.test(currentItem.string)){
					lockedString =  "<a id='padlockIcon' class='padlockIcon' style='transition: none'>" + padlockIcon + "</a>"			 	
				}

				let sceneDiv = document.createElement("div")
					sceneDiv.id = num.toString()
					sceneDiv.dataset.myId = num.toString()
					sceneDiv.classList.add("scene")
					if (currentItem.omitted == 1){
						sceneDiv.classList.add("isOmitted")
					}
					sceneDiv.dataset.uuid = currentItem.uuid
					sceneDiv.dataset.line = currentItem.sceneStart
					sceneDiv.dataset.lineEnd = currentItem.sceneStart + currentItem.line.range.length
					sceneDiv.dataset.lengthOfScene = currentItem.numberOfPages
					sceneDiv.dataset.inAct = currentAct
					sceneDiv.draggable = true

					color = currentItem.color
					if (color.includes("]") || color.includes('[') || color.split(" ").length > 1){
						color = color.replace(/(\]|\[|\s).*/, "")
					}

					sceneDiv.style.setProperty("--localColor", "#ddd")
					if(color){
						if (color.match(/(#[A-F, 0-9]{6})/i)){
							// sceneDiv.style.backgroundColor = color
							sceneDiv.style.setProperty("--localColor", color)
						}else{
							sceneDiv.classList.add(color.toLowerCase())
							sceneDiv.style.setProperty("--localColor", `hsl(var(--${color.toLowerCase()}))`)
						}
					}

					let ii = 1
					while(outline[num-ii] && outline[num - ii].typeAsString == "Synopse"){ii++}
					if(outline[num - ii] && outline[num - ii].typeAsString == "Section"){
						let scenearrowDiv = document.createElement("div")
							scenearrowDiv.classList.add("arrowForIndexCards")
							sceneDiv.appendChild(scenearrowDiv)
					}

				let sceneheadingDiv = document.createElement("div")
					sceneheadingDiv.classList.add("sceneheading")
					if ($id(num) && $id(num).classList.contains("sluglineIsHidden")){
						sceneDiv.classList.add("sluglineIsHidden")
					}
					sceneheadingDiv.dataset.line = currentItem.sceneStart
					if(color){
						sceneheadingDiv.classList.add(color.toLowerCase())
					}
				
				let sceneNumberSpan = document.createElement("SPAN")
					sceneNumberSpan.innerHTML = lockedString + sceneNumber + "&nbsp;"
					sceneNumberSpan.classList.add("showSceneNum")
					sceneheadingDiv.appendChild(sceneNumberSpan)
					
				let pageCountSpan = document.createElement("SPAN")
					pageCountSpan.innerHTML = numberIntoEights(currentItem.numberOfPages)
					pageCountSpan.classList.add("showSceneLength")

					sceneheadingDiv.appendChild(pageCountSpan)

				let sceneSynConDiv = document.createElement("div")
					sceneSynConDiv.id = "synopsisFor" + num
					sceneSynConDiv.classList.add("synopsiscontainer")
					sceneSynConDiv.dataset.line = currentItem.sceneStart

				sceneheadingDiv.innerHTML += "<span class='slugtext'>"
					// if(loggingIsOn){sceneheadingDiv.innerHTML += currentItem.sceneStart + ", " + currentItem.sceneEnd + " -- "}
					if(loggingIsOn){sceneheadingDiv.innerHTML += "#" + outline.indexOf(currentItem)}
				sceneheadingDiv.innerHTML += currentItem.stringForDisplay.toUpperCase().replace(/</g, "&lt;") + "</span>"
				sceneDiv.appendChild(sceneheadingDiv)
				sceneDiv.appendChild(sceneSynConDiv)

			if(currentItem.breakLines.length > 0) { addPageBreak(sceneDiv) }

				function addPageBreak(whereToAdd){

					for (breakLine of currentItem.breakLines){

					let blankDiv = document.createElement("div")
						blankDiv.id = "blankPageFor" + num + "_" + currentItem.breakLines.indexOf(breakLine)
						blankDiv.classList.add("blankPage")

					let distanceToPageBreak = 100 * (breakLine.startPageIncFraction - currentItem.startsOnPage - currentItem.positionOnPage) / (currentItem.numberOfPages)
						blankDiv.style.top = distanceToPageBreak + "%"

					let nextPageBeginsAt = (breakLine.fullpage + 1) - (currentItem.startsOnPage + currentItem.positionOnPage)
					let nextPageIsThisFarIn = 100 * nextPageBeginsAt / currentItem.numberOfPages
					let distanceToNextPageTop = nextPageIsThisFarIn - distanceToPageBreak

						blankDiv.style.height =  distanceToNextPageTop + "%"

					let nextActualScene = 1
						while(outline[num + nextActualScene] && outline[num + nextActualScene].typeAsString == "Synopse"){nextActualScene ++}
					blankDiv.dataset.line = breakLine.pageBreakIndex 
					blankDiv.dataset.length = outline[num + nextActualScene]?.sceneStart - 1

					whereToAdd.appendChild(blankDiv)

					}
				}

			if(pageDividers[num]) {insertDividersIn(sceneDiv)}

				function insertDividersIn(whereToAdd){

					for (let p = 0; p < pageDividers[num].length; p++){

						let reduceWhenFromTop = currentItem.positionOnPage == 0 ? 1 : 0 //or else scene starts one number too high
						let approxBreakPos = currentItem.sceneStart + ((currentItem.sceneEnd - currentItem.sceneStart) * pageDividers[num][p]/currentItem.numberOfPages) 

						let divider = document.createElement("div")
							divider.id = "divider" + num + "-" + p
							divider.classList.add("pageDivider")
							divider.innerHTML = Math.trunc(currentItem.startsOnPage + 1 + p - reduceWhenFromTop)
							divider.dataset.line = approxBreakPos

							divider.style.top = 100 * pageDividers[num][p]/currentItem.numberOfPages + "%"

						whereToAdd.appendChild(divider)

					}
				}

				lastSection.appendChild(sceneDiv)

				if(currentItem.synopsis && currentItem.synopsis.length > 0){ //this will put synopsis into place (for scenes) for version 1.977 and on
					for (let synopsisItem of currentItem.synopsis){
						synopsisMaker(synopsisItem)
					}
				}

				break

			case "Synopse":

				synopsisMaker(currentItem) 
				// This switch will put synopsis in place for Beat versions pre 1.977, which may or may not be too old to run FTOutliner anyway. 
				// For later versions, the following synopsisMaker function will be called from inside scene and section makers

				function synopsisMaker(currentItem){

				let allContainers = newFlexi.querySelectorAll(".synopsiscontainer")
				let lastContainer = allContainers[allContainers.length - 1]

				let synopsisDiv = document.createElement("div")
					synopsisDiv.id = num
					let synopsisNumber = false
						if(outline[num].synopsis){ 
							synopsisNumber = outline[num].synopsis.indexOf(currentItem)
							synopsisDiv.dataset.synopsisNumber = synopsisNumber
							synopsisDiv.id = "s" + num + "_" + (('000'+synopsisNumber).slice(-3)) // synopsisNumber
						}
					synopsisDiv.dataset.uuid = currentItem.uuid
					synopsisDiv.innerText = currentItem.stringForDisplay 
					synopsisDiv.classList.add("synopsis")
					synopsisDiv.dataset.sceneNumber = currentItem.sceneNumber //necessary?
					synopsisDiv.dataset.line = (synopsisNumber !== false) ? outline[num].synopsis[synopsisNumber].position : currentItem.sceneStart
					synopsisDiv.dataset.lineEnd = (synopsisNumber !== false) ? outline[num].synopsis[synopsisNumber].position + outline[num].synopsis[synopsisNumber].range.length : currentItem.sceneEnd
					synopsisDiv.draggable = true

					//Trying to catch Beat bug with left-over synopsis:
						//thisLine = lines.filter(line => line.uuid == currentItem.uuid)[0]
						// if (!thisLine || thisLine.typeAsString != "Synopse") return 
							//next two lines are for bug tracking purposes, if the previous line is turned off:
								// if (!thisLine) synopsisDiv.style.outline = "2px solid hotpink"
								// if (thisLine && thisLine.typeAsString != "Synopse") synopsisDiv.style.outline = "2px solid cyan"
					
					color = currentItem.color
						if (color?.includes("]") || color?.includes('[') || color?.split(" ").length > 1){
							color = color.replace(/(\]|\[|\s).*/, "")
						}
						if(color){
							if (color.match(/(#[A-F, 0-9]{6})/i)){
								synopsisDiv.style.setProperty("--localSynopsisColor", color)
							}else{
								synopsisDiv.classList.add(color.toLowerCase())
								synopsisDiv.style.setProperty("--localSynopsisColor", `hsl(var(--${color.toLowerCase()}))`)
							}
						}
					if (currentItem.omitted || (synopsisNumber !== false && outline[num].synopsis[synopsisNumber].omitted)){
						synopsisDiv.classList.add("isOmitted")
					}

				lastContainer.appendChild(synopsisDiv)
				}
		} 

		if(currentItem.numberOfPages){alternatePageNumber += Number(currentItem.numberOfPages)}

	}

	//BONEYARD-check to disallow any boneyard that is not last act
		let allActs = newFlexi.querySelectorAll(".level1")
		for (i = 0; i < allActs.length - 1; i++){
				allActs[i].classList.remove("boneyard")
			}		
	
	//add a temporary copy of notes etc to avoid blinkage
		if(flexiContainer.querySelectorAll(".faux, .section, .scene, .orphanText")?.length == newFlexi.querySelectorAll(".faux, .section, .scene, .orphanText")?.length){
			$$(".noteContainer, .marker, .review, .beat, .displayNumberOf").forEach(thingToPutBack => {
					let parentId = thingToPutBack.parentNode.dataset.myId || thingToPutBack.parentNode.id
					let placeToPut = newFlexi.querySelector(`[data-my-id = "${parentId}"]`) || newFlexi
						placeToPut.appendChild(thingToPutBack.cloneNode(true))
			})
		}

	//in case of dialog filtering going on, transfer what scenes are dimmed to avoid blinkage
		if($id("dialogsearch")?.value) {
			$$(".scene").forEach(scene => {
				let myId = scene.dataset.myId
				let newScene = newFlexi.querySelector(`[data-my-id = "${myId}"]`)
			
				if(newScene){ 
					if(scene.classList.contains("dimmedScene")) newScene.classList.add("dimmedScene")
				}
			})
		}

	//transfer any selections made in the outgoing outline to the new
		let selections = $$(".isSelected")
		for (let selection of selections){
			let uuid = selection.dataset.uuid
			let newSelection = newFlexi.querySelector(`[data-uuid = "${uuid}"]`)
			if(newSelection){
				newSelection.classList.add("isSelected")
			}
		}

	// recalling cardstates by UUID: 
	// 1. If outline already drawn, use existing values, 
	// 2. if not, use saved settings,
	// 3. if not in saved settings either, then default to all expanded, 
	let newSections = newFlexi.querySelectorAll(".section")
		for (let section of newSections){
			let uuid = section.dataset.uuid
			let oldSection = flexiContainer.querySelector(`[data-uuid = "${uuid}"]`)
			if(oldSection){
				["isExpanded", "collapsedSection", "wider"].forEach(className => {
					section.classList.toggle(className, oldSection.classList.contains(className))
				})
			}else{ //this should only happen on first draw
				savedValue = cardState.find(card => card.uuid == uuid) || {isExpanded: true, collapsedSection: false, wider: false};
				["isExpanded", "collapsedSection"].forEach(className => { //removed ".wider" bc no reason to widen anything on first draw
					section.classList.toggle(className, savedValue[className])
				})				
			}
		}

	newFlexi.querySelectorAll(".scene").forEach(
		scene => colorByPercentageInstead(scene)
	)
	
	//=============================================
	//THE BIG ONE: REPLACE OLD OUTLINE WITH THE NEW
	//=============================================
	let classesBefore = JSON.stringify(Array.from(flexiContainer.classList))
	$id("flexiContainer").innerHTML = newFlexi.innerHTML
	let classesAfter = JSON.stringify(Array.from(flexiContainer.classList))

	//post-adding fixes:

	actLengths.push(Array.from($$(".pageDivider")).at(-1)?.innerText) // takes the number from the last visible divider and adds to actLengths
	actIndex.push(currentItem.sceneEnd)  // index for last page number
	
	let allActPages = $$(".showActLength")
	for (let i = 0; i < allActPages.length; i++){

		let thisactlength = Array.from(allActPages[i]?.parentElement?.querySelectorAll(".pageDivider"))?.at(-1)?.innerText
							||
							allActPages[i-1]?.dataset.pageNumber // when no new line breaks in this act
							||
							1 // when no new line breaks anywhere

		allActPages[i].innerHTML = `Pg ${thisactlength}.`
		allActPages[i].dataset.line = actIndex[i+1]
		allActPages[i].dataset.pageNumber = thisactlength	
	}

	mylog("after act lengths")

	recalculateHeights()
	reevaluateColorContrast()
	updateAllSectionPageCounts()

}

function updateAllSectionPageCounts(){

	let accumulatedPages = 0
	let allSections = Array.from($$(".section"))

	$$(".section").forEach(section =>{

		accumulatedPages = 0

		section.querySelectorAll(".scene, .orphanText").forEach(element => {
			accumulatedPages += Number(element.dataset.lengthOfScene) || 0
		})

		if(section.querySelector(".sectionLengths")) section.querySelector(".sectionLengths").innerHTML = `<br/> (${numberIntoEights(accumulatedPages)})`
	})

	//after the loop, add last accumulation to last section:
	if (allSections.at(-1).querySelector(".sectionLengths")) {
		allSections.at(-1).querySelector(".sectionLengths").innerHTML = `<br/> (${numberIntoEights(accumulatedPages)})`
	}

}


function __________OUTLINE_GRAPHICS(){}

function colorByPercentageInstead(element){
	mylog()

	if(!documentSetting.colorByPercentage) return

	//let percentage = 100 * (scene.dataset.line - 1) / absoluteTextLength

	let scene = outline.find(scene => scene.uuid == element.dataset.uuid)
	let percentageNote = scene?.notes?.find(note => note.content.includes("%"))

	let color = "white"

	if (percentageNote){

		let percentage = Number(percentageNote.content.match(/(\d+)%/)?.[1]) * 1.2 //because 120° is green on the color wheel 

		color = `hsl(${percentage}, 100%, 50%)`
	}

	element.style.setProperty("--localColor", color)

}

function reevaluateColorContrast(){
	mylog()

	if(!userDefault.invertTextOnDark) {
		$$(".scene, .sceneheading, .section, .section-heading, .synopsis" ).forEach(item => item.style.color = "")	
		return
	}

	let hoveredObjects = $$(".scene:hover, .section:hover")
		hoveredObjects.forEach(obj => {obj.classList.add("noHover")})
	let selectedObjects = Array.from($$(".isSelected"))
		selectedObjects.forEach(obj => {obj.classList.remove(".isSelected")})
	let redraw = $id("flexiContainer").getBoundingClientRect() // trigger redraw to paint all elements correctly first

	allItems = $$(".sceneheading, .synopsis")
	
	for (let item of allItems){
		let styles = window.getComputedStyle(item.closest(".synopsis, .scene, .flexiContainer"))
		let $rgb = makeRGB(styles.backgroundColor)
		$rgb = $rgb.replace("rgb(", "").replace(")", "").split(",")
		let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
		item.style.color = (blackOrWhite > 128) ? "black" : "white"
		item.style.fill = (blackOrWhite > 128) ? "black" : "white"
	}
	
	allItems = $$(".section-heading:not(.level1 > .section-heading)")
		
	for (let item of allItems){
		let styles = window.getComputedStyle(item)
		let $rgb = makeRGB(styles.backgroundColor)
		$rgb = $rgb.replace("rgb(", "").replace(")", "").split(",")
		let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
		item.style.color = (blackOrWhite > 128) ? "black" : "white"
	}
	
	allItems = $$(".synopsis")
		
	for (let item of allItems){
		let styles = window.getComputedStyle(item)
		let $rgb
		if(styles.backgroundColor && styles.backgroundColor != "rgba(0, 0, 0, 0)"){
			$rgb = makeRGB(styles.backgroundColor)
		}else{
			let parentItem = item.closest(".scene")
			if (!parentItem && documentSetting.indexCardMode){parentItem = item.closest(".section")?.querySelector(".section-heading")}
			if (!parentItem && !documentSetting.indexCardMode){parentItem = item.closest(".level1")}
			if (!parentItem)return
			styles = window.getComputedStyle(parentItem)
			$rgb = makeRGB(styles.backgroundColor)
		}
			$rgb = $rgb.replace("rgb(", "").replace(")", "").split(",")
		
			let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
			item.style.color = (blackOrWhite > 128) ? "black" : "white"

	}

	hoveredObjects.forEach(obj => {obj.classList.remove("noHover")})
	selectedObjects.forEach(obj => {obj.classList.add(".isSelected")})
	mylog("exiting")

}

function blackOrWhite(rgb){

	let $rgb = rgb.replace("rgb(", "").replace(")", "").split(",")
		
	let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
	let colorOut = (blackOrWhite > 128) ? "black" : "white"


	return colorOut

}

function makeRGB(color){

	if (color == "" || color.substring(0,1) != "#") {return color}

    // This is simple because we know that every values is two 
    // hexadecimal digits.
    	rgbColors[0]=color.substring(1, 3)  // redValue
    	rgbColors[1]=color.substring(3, 5)  // greenValue
    	rgbColors[2]=color.substring(5, 7)  // blueValue

    	rgbColors[0]=parseInt(rgbColors[0], 16)
    	rgbColors[1]=parseInt(rgbColors[1], 16)
    	rgbColors[2]=parseInt(rgbColors[2], 16)
	

	color = "rgb(" + [...rgbColors] + ")"

  return color

}

function findPageDividers() {

	mylog()

	if(!outline || outline.length == 0) return

	// let scenesOnly = outline.filter(scene => {if(scene.typeAsString == "Heading") return scene})
	let scenesOnly = outline.filter(scene => {scene.typeAsString == "Heading"})
		pageDividers = []

	for (let i = 0; i < outline.length; i++) {

		const scene = outline[i]
		const previousScene = outline[i - 1] || null
		const nextScene = scenesOnly[scenesOnly.indexOf(outline[i]) + 1] || null
		// const nextScene = outline[i + 1] || null

		let absolutePos = scene.startsOnPage + scene.positionOnPage

		// Make sure omitted scenes do not get added to page count
			if (scene.omitted == true) {
				outline[i].numberOfPages = 0.0
				continue
			}
		
		// Finally add all dividers: 
			let numberOfDividers = ((nextScene?.startsOnPage - scene.startsOnPage 
									- (nextScene?.positionOnPage == 0 ? 1 : 0 ) // remove divider that should belong to next scene
									|| Math.floor(scene.positionOnPage + scene.numberOfPages)) // accounts for final scene of script which has no next
									+ (scene.positionOnPage == 0 ? 1 : 0)) 		// add divider if scene starts at top of page

			if (numberOfDividers > 0){
			
				pageDividers[i] = []

				for (let j = 0; j < numberOfDividers; j++) {

					let lengthToDivider = Math.ceil(absolutePos) - absolutePos + j
					pageDividers[i].push(lengthToDivider)

				}	
			}
	}
}

function putOntoScreen() {

	let theIndicatorIsInElement = $id("youAreHere")?.getAttribute('data-outlineElementCount')

	if (theIndicatorIsInElement && theIndicatorIsInElement > 0){
		if(isThisOffScreen($id(theIndicatorIsInElement))){
			scrollNicelyIntoView($id(theIndicatorIsInElement))
		}	
	}
}

function recalculateHeights(wherefrom){
	
	mylog()
	mylog("from: " + JSON.stringify(recalculateHeights.caller.name))
	mylog("OLD VALUE: " + getComputedStyle(document.documentElement).getPropertyValue('--heightFactor'))

	let theIndicator = $id("youAreHere")

	let allScenes = $$(".scene, .orphanText")
	let allSections = $$(".section")
	let allActs = $$(".level1:not(.boneyard)")
	
	if ((allScenes.length == 0 && allSections.length == 0) || !outline || outline.length == 0){
		mylog("returns from recalculateHeights because no scenes and no sections")
		return} 

	if (documentSetting.indexCardMode) {
		mylog("indexCardMode was discovered so fine.")
		let referenceForWidth = allSections[0]
		let referenceForHeight = 0
		theRoot.style.setProperty('--indexReferenceForHeight', "auto")
		
		//set height of cards first
		let indexHeight = "calc(22px * var(--fontSizeFactor) + " + indexCardHeight + " * 15px * var(--fontSizeFactor))" 
		theRoot.style.setProperty('--indexCardHeight', indexHeight)

		if ($(".altYouAreHere")) {$(".altYouAreHere").classList.remove("altYouAreHere")}
		putOntoScreen()
		if(theIndicator){theIndicator.style.top = "calc(16px * var(--fontSizeFactor))"}

		//then set height of act lanes
		if (!documentSetting.oneColumnOutline){
			for (act of allActs){
				referenceForHeight = Math.max(referenceForHeight, Number(act.getBoundingClientRect().bottom) - Number(act.getBoundingClientRect().top))
				}
			theRoot.style.setProperty('--indexReferenceForHeight', referenceForHeight + "px")
		}
		
		return
	}

	if(!documentSetting.scenesAreProportional){ //would be better if this were a class instead! 
				
		if(theIndicator){
			let a = getComputedStyle(theRoot).getPropertyValue('--fixedHeight')
			let theIndicatorPosition = "calc(var(--fixedHeight) * var(--fontSizeFactor) * 2 / 3)"
				if (a = "auto"){theIndicatorPosition = "calc(11px * var(--fontSizeFactor))"}
			theIndicator.style.top = theIndicatorPosition
		}

		putOntoScreen()
		return	
	}
	
	// The rest is for proportional only 
	//==================================

	console.time("recalculateHeights")

	//new section-height-collector
		let newSectionHeights = []
		let newSceneHeights = []
		for (act of allActs){

			if (act.classList.contains(".boneyard")) break

			let sectionsInAct = act.querySelectorAll(".section-heading") //this includes the act itself
			let scenesInAct = act.querySelectorAll(".scene, .orphanText")
			let sectionHeightForAct = 0
			for (sec of sectionsInAct) {

				let measures = window.getComputedStyle(sec)
				sectionHeightForAct += sec.getBoundingClientRect().height + parseInt(measures.marginBottom) + parseInt(measures.marginTop)
			}
			let sceneHeightForAct = 0
			for (scn of scenesInAct){

				sceneHeightForAct += Number(scn.dataset.lengthOfScene)
								
				scn.style.minHeight = ""
				scn.style.setProperty("--flexibleHeight", scn.dataset.lengthOfScene + "px")

			}
			newSectionHeights.push(sectionHeightForAct)
			newSceneHeights.push(sceneHeightForAct)
		}

	let theLongestAct = Math.max(...newSceneHeights)
	let theMostSections = Math.max(...newSectionHeights)
	
	let whichActHasLongestScenes = newSceneHeights.indexOf(theLongestAct)
	let whichActHasMostSections = newSectionHeights.indexOf(theMostSections)
	
	let windowHeight = $id('flexiContainer').getBoundingClientRect().height

	let spaceToBreatheAndForPageNumbers = 40 //was 80 before removing margins
	let newSpaceToDistribute = windowHeight - spaceToBreatheAndForPageNumbers

		unDistributableHeight = windowHeight - newSpaceToDistribute //only used for exporting
	
	let scenesHaveMoreSpace = (newSpaceToDistribute - newSectionHeights[whichActHasLongestScenes] - theLongestAct) / theLongestAct
	let sectionsHaveMoreSpace = (newSpaceToDistribute - (theMostSections) - newSceneHeights[whichActHasMostSections]) / newSceneHeights[whichActHasMostSections]
	
	let heightFactor =  Math.min(scenesHaveMoreSpace, sectionsHaveMoreSpace)
		paperHeightFactor = 72 * (29.7 / 2.54) * heightFactor / (windowHeight - 260) //was-160, and before that -120 
		theRoot.style.setProperty('--heightFactor', heightFactor);
		theRoot.style.setProperty('--paperHeightFactor', paperHeightFactor);
	
		mylog("HeightFactor, NEW VALUE: " + heightFactor + "")
		
		setTimeout(hideSlugFor, 150)

		if(theIndicator){positionTheIndicator(theIndicator)}

		mylog("exiting recalculateHeights()")
		putOntoScreen()

	//let outTime = new Date()
	console.timeEnd("recalculateHeights")
}

function positionTheIndicator(){
	
	mylog()

	let theIndicator = $id("youAreHere")
	if(!theIndicator)return

		let theIndicatorPercentage
	
		let theIndicatorIsInElement = theIndicator.getAttribute('data-outlineElementCount');
		theIndicatorPercentage = Number(theIndicator.getAttribute('data-percentageIntoScene'));

			// let theIndicatorParentHeight = Number(parseInt(window.getComputedStyle(theIndicator.parentNode).getPropertyValue("height")));
			let theIndicatorParentHeight = parseInt(theIndicator.parentNode.getBoundingClientRect().height) - 2.5;
			let theIndicatorPosition = theIndicatorParentHeight * theIndicatorPercentage
			if (theIndicatorPercentage == -1) {theIndicatorPosition = 11 * currentZoomLevel}
			theIndicator.style.top = theIndicatorPosition + "px"

			if (theIndicatorIsInElement){
			if(isThisOffScreen($id(theIndicatorIsInElement))){
				scrollNicelyIntoView($id(theIndicatorIsInElement))
			}	
		}

	if(currentParentScroll){
		
		let a = $id(theIndicatorIsInElement).querySelector(".synopsiscontainer")
			a.scrollTo({left: 0, top: currentParentScroll, behavior: "instant"})
	}
}

function hideSlugFor(entries){
	
	if (documentSetting.indexCardMode || $id("flexiContainer").classList.contains("nonProportionalMode")) {
		$$(".sluglineIsHidden").forEach(item => {item.classList.remove("sluglineIsHidden")})
		$$(".animateOpacity").forEach(item => {item.classList.remove("animateOpacity")})
		return
	}
	
	$$(".scene").forEach(scene => {
		
		let trueOrFalse = (Number(scene.getBoundingClientRect().height) < (11.5 * currentZoomLevel))

			scene.classList.toggle("animateOpacity", trueOrFalse)
			scene.classList.toggle("sluglineIsHidden", trueOrFalse)
		
	})
}

function youAreHere(location, length, positionChangeOnly){
	mylog("youAreHere: " + location + "...")
	mylog("...and we are editing text is: " + weAreCurrentlyEditingText)

	if(location == 0 ){location = -999} //hacky way to avoid errors when no location at all, yet process when zero

	if(fullTypeTimer || !location || !outline || outline.length < 1 || weAreCurrentlyEditingText){
		if(document.getElementById('youAreHere')){document.getElementById('youAreHere').remove()}
		mylog("CANCELING YOU ARE HERE")
		return
	}

	let whichSceneAreWeIn = 0
		while ((outline[whichSceneAreWeIn + 1]) && outline[whichSceneAreWeIn + 1].line.position - 0 <= location){ 		
			whichSceneAreWeIn ++
		}

		//This was added to keep the scroll of enclosing index card when selecting a synopsis (2022-07-02)
		currentParentScroll = $id(whichSceneAreWeIn)?.closest(".scene, .section")?.querySelector(".synopsiscontainer")?.scrollTop

		if(document.getElementById('youAreHere')){
			document.getElementById('youAreHere').remove()
		}

		if (outline[whichSceneAreWeIn].typeAsString != "Synopse"){
			currentParentScroll = false
		}
		while(outline[whichSceneAreWeIn].omitted && documentSetting.scenesAreProportional){
			whichSceneAreWeIn--
			if(whichSceneAreWeIn < 0){whichSceneAreWeIn = 0; break}
		}

		mylog("we are in... " + whichSceneAreWeIn)
		
	let whichSceneNumberAreWeIn = outline[whichSceneAreWeIn].sceneNumber
		
	let thisScenesBeginning = outline[whichSceneAreWeIn].sceneStart
		if(outline[whichSceneAreWeIn].sceneNumber.includes("OMITTED")){
			thisScenesBeginning = outline[whichSceneAreWeIn].line.position
		} //if we need to fix the sceneNumber for later use?
		
	let thisScenesEnd = outline[whichSceneAreWeIn].sceneEnd
		if(outline[whichSceneAreWeIn].sceneNumber.includes("OMITTED") && outline[whichSceneAreWeIn + 1]){
			thisScenesEnd = outline[whichSceneAreWeIn+1].line.position - 1
		} //if we need to fix the sceneNumber for later use?
		if(outline[whichSceneAreWeIn].typeAsString == "Section"){
			if (outline[whichSceneAreWeIn + 1]){thisScenesEnd = outline[whichSceneAreWeIn + 1].line.position - 1} //so not end of entire sequence
		}
		
	//First, setting place to put indicator, so we can change it if we need to go into orphan text
	let placeToPutIndicator = $id(whichSceneAreWeIn)
	mylog("we shall now put indicator in " + whichSceneAreWeIn)
		
	var percentageIntoScene = (location - thisScenesBeginning) / (thisScenesEnd - thisScenesBeginning); // must also fix end position in plugin before delivering JSON
	
		// killed // if (pageBreaks[whichSceneAreWeIn]){

		// 	percentageIntoScene = percentageIntoScene * pageBreaks[whichSceneAreWeIn]/outline[whichSceneAreWeIn].numberOfPages
		// }

		if(!outline[whichSceneAreWeIn].sceneNumber || outline[whichSceneAreWeIn].typeAsString == "Section"){
			
			percentageIntoScene = -1
			
			//BUT: the following is to allow traveling you-are-here in "orphan text" after section 
			if (outline[whichSceneAreWeIn].typeAsString == "Section"
			&& outline[whichSceneAreWeIn].numberOfPages > 0 
			&& location > thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length
			&& documentSetting.scenesAreProportional){

				if(outline[whichSceneAreWeIn + 1]){//for all orphan texts that does not end the document

					let nextElement = 1
					while (outline[whichSceneAreWeIn + nextElement] && outline[whichSceneAreWeIn + nextElement].typeAsString == "Synopse"){nextElement++}
										
					try{
						percentageIntoScene = (location - (thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)) / (outline[whichSceneAreWeIn + nextElement].sceneStart - 1 - thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)
					}catch{
						mylog("inside catch")
						percentageIntoScene = (location - (thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)) / (absoluteTextLength - thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)
					}
					
					mylog("before put in orphan")
					placeToPutIndicator = placeToPutIndicator.querySelector(".orphanText")
				}else{ //the special case where there is no more outline elements after the section, just orphan text

					percentageIntoScene = (location - (thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)) / (outline[whichSceneAreWeIn].sceneEnd - thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)
					placeToPutIndicator = placeToPutIndicator.querySelector(".orphanText")
				}
			}
		}

		let weReOnPage = placeToPutIndicator.querySelectorAll(".pageDivider")
		//while (!weReOnPage && whichSceneAreWeIn > -1) weReOnPage = 
		
		// let theIndicatorHTML = "<div " + 
		// "id='youAreHere' " +
		// "class='indicator' " +
		// "data-percentageIntoScene='" + percentageIntoScene + "' " +
		// "data-outlineElementCount='" + whichSceneAreWeIn + "' " +
		// "data-theSceneNumber = '" + whichSceneNumberAreWeIn + "' " + 
		// ">"+"<p>"+ location + //" (" + outline[whichSceneAreWeIn].typeAsString + ")" + 
		// "</p></div>"

		let theIndicatorDiv = document.createElement("div")
			theIndicatorDiv.id = "youAreHere"
			theIndicatorDiv.classList.add("indicator")
			theIndicatorDiv.dataset.location = location
			theIndicatorDiv.setAttribute("data-percentageIntoScene", percentageIntoScene)
			theIndicatorDiv.setAttribute("data-outlineElementCount", whichSceneAreWeIn)
			theIndicatorDiv.setAttribute("data-theSceneNumber", whichSceneNumberAreWeIn)
			theIndicatorDiv.innerHTML = "<p>"+ location + /*" (" + outline[whichSceneAreWeIn].typeAsString + ")" + */ "</p>"
		
		if(placeToPutIndicator){
			// placeToPutIndicator.innerHTML += theIndicatorHTML
			placeToPutIndicator.appendChild(theIndicatorDiv)
		}

	mylog("End of indicator placement")
	if(positionChangeOnly){
		if($id("youAreHere")) {positionTheIndicator($id("youAreHere"))}
	}else{
		recalculateHeights("from youAreHere")
	}

	updateDialogPanelSelection()

}

function numberIntoEights(theNumber) {

	let theFraction = Math.floor((theNumber - Math.floor(theNumber))*8);
	
	let theNumberInEights = theFraction + "/8";
	if(theNumberInEights == "0/8" && Math.floor(theNumber) > 0){theNumberInEights = "pgs"; if (Math.floor(theNumber)==1){theNumberInEights = "pg"}}
	
	if (Math.floor(theNumber) > 0){theNumberInEights = 	Math.floor(theNumber)+" " + theNumberInEights};
	
	return theNumberInEights;

}

// MARK: - UI RELATED

function __________UI_RELATED_STUFF (){}

function getSettings(startup = false){

	mylog()

	//TODO: The problem here is that values that are note stored already will be undefined.
	// We need to check for that and set defaults instead.

	//Step 1: getting User Defaults
	Beat.callAndWait(() => {
        let ftoutlinerObject = Beat.getUserDefault("ftoutlinerObject") || {}
        	return ftoutlinerObject
    	})
    	.then(
			response => { 
				Object.assign( userDefault, JSON.parse(response) )
				getDocumentSettings() //brings us to step two
			},
        	error => { console.log("Error retrieving userDefault") }
    )

	//Step 2: getting Document Settings
		function getDocumentSettings(){	
			Beat.callAndWait(() => {
				let ftoutlinerObject = Beat.getDocumentSetting("ftoutlinerObject") || {}
				return ftoutlinerObject
				})
				.then(
					response => { 
						Object.assign( documentSetting, JSON.parse(response))
						applySettings()

						getVersionNumber()
					},
					error => { console.log("Error retrieving documentSetting") }
			)
		}

	//Step 3: getting the current version number!
		function getVersionNumber(){	
				Beat.callAndWait(() => {
					let ftoutlinerVersion = Beat.getUserDefault("ftoutlinerVersion") || {}
					return ftoutlinerVersion
					})
					.then(
						response => { 
							
							if(startup){ launchWelcomeDialog(response) }
						
						},
						error => { console.log("Error retrieving version number") }
				)
			}

	//no more code can go here because of synchronicity!

}


function applySettings(){

	//TODO: Check to see that all defaults are really present here!


	let knownDocumentSettingDefaults = {
		scenesAreProportional: true,

		showSynopsisInScenes: false, 
		showPageDividers: false, 
		notesAreDisplayed: false,
		markersAreDisplayed: false,
		beatsAreDisplayed: false,
		reviewsAreDisplayed: false,
		allowMarkerTextInAllViews: false,
		colorByPercentage: false,

	//tracking settings
		trackingIncludesSynopsis: true,

	//Advanced Settings
		showMultipleSceneLines: false, 
		showMultipleSectionLines: false, 
		allowLowerCaseSections: false, 
		showLengthsInSections: false, 
		showSelectionInfo: false,
		showRevisions: false,

	//indexCard Stuff
		showLengths: "none", 
		showNumbers: "inline", 
		showPages: "inline", 
		oneColumnOutline: false, 
		currentZoomLevel: 1,
		
		indexCardHeight: 5,
		cardState: [],
		
		indexCardMode: false,
		showVerticals: false, 
		autoWiden: false, 
		widenedColumnsGetAutoHeight: false, 

	//UI stuff
		greyonly: false, 
		boneyardIsClosed: true, 
		notepanel: false, 
		notepanelWidth: "200",

		outdoor: 0,
		saturation: 50,

		windowSize: {	
			x: 0, 
			y: 0, 
			width: 0, 
			height: 0
		},
	}

	let knownUserDefaults = {
		loggingIsOn: false, 
		realTimeIsOn: true, 
		colorScheme: "Beat", 
		warningsAreOn: true, 
		invertTextOnDark: true,
		excludeVoiceOvers: false,

		timeOfDayObject: knownTimesOfDayObject,
	}

	Object.keys(knownDocumentSettingDefaults)
		.filter(key => !(key in documentSetting))
  		.forEach(key => {
    		console.log("Didn't find " + key + " in documentSetting, so setting it to default value '" + knownDocumentSettingDefaults[key] + "'.");
    		documentSetting[key] = knownDocumentSettingDefaults[key];
  		});

	Object.keys(knownUserDefaults)
		.filter(key => !(key in userDefault) || userDefault[key] == undefined || userDefault[key] == null)
  		.forEach(key => {
			console.log("Didn't find " + key + " in userDefault, so setting it to default value '" + knownUserDefaults[key] + "'.");
			userDefault[key] = knownUserDefaults[key];
  		});

	Object.keys(documentSetting)
		.filter(key => !(key in knownDocumentSettingDefaults))
  		.forEach(key => {
			console.log("Found " + key + " in documentSetting, but it is not a known default. FIX THIS!")
  		});

	Object.keys(userDefault)
		.filter(key => !(key in knownUserDefaults))
  		.forEach(key => {
			console.log("Found " + key + " in userDefault, but it is not a known default. FIX THIS!")
  		});

	$id("flexiContainer").classList.toggle("dualSceneLines", documentSetting.showMultipleSceneLines)
	$id("flexiContainer").classList.toggle("dualSectionLines", documentSetting.showMultipleSectionLines)
	$id("flexiContainer").classList.toggle("allowLowerCaseSections", documentSetting.allowLowerCaseSections)
	$id("flexiContainer").classList.toggle("showLengthsInSections", documentSetting.showLengthsInSections)
	$id("flexiContainer").classList.toggle("allowMarkerTextInAllViews", documentSetting.allowMarkerTextInAllViews)
	
	$id("flexiContainer").classList.toggle("showPageDividers", documentSetting.showPageDividers)
	
	$id("flexiContainer").classList.toggle("verticals", documentSetting.showVerticals)
	$id("flexiContainer").classList.toggle("autoWiden", documentSetting.autoWiden)
	$id("flexiContainer").classList.toggle("widenedColumnsGetAutoHeight", documentSetting.widenedColumnsGetAutoHeight)
	
	//RESETTING THE NOTE PANEL
		$id("flexiContainer").classList.toggle("notepanelIsExpanded", documentSetting.notepanel)
		$id("notepanel").classList.toggle("expanded", documentSetting.notepanel)
		theRoot.style.setProperty('--note-panel-width', documentSetting.notepanelWidth + "px")
			$$("#notepanel .tab").forEach(tab => {
				// tab.classList.remove("selectedtab")
				tab.classList.toggle("selectedtab", tab.classList.contains(documentSetting.selectedPanelTab))
			})
		if(documentSetting.notepanel) cycleTabs($(`.${documentSetting.selectedPanelTab}`) || false)
	
	//HIGH CONTRAST STUFF
		document.documentElement.setAttribute('data-outdoors', documentSetting.outdoor)
		document.documentElement.style.setProperty('--saturation', documentSetting.saturation + "%")
		$id("saturationRange").value = documentSetting.saturation

	//DOCUMENT SETTINGS

		//calling toggleProportional will mess up indexCardMode, se setting proportional by hand instead
		//toggleProportional(documentSetting.scenesAreProportional)
			flexiContainer.classList.toggle("nonProportionalMode", !documentSetting.scenesAreProportional)
			document.getElementById("indexCardButton").innerHTML = documentSetting.scenesAreProportional ? outlineIcon : fixedIcon

		//One-column
			flexiContainer.style.display = documentSetting.oneColumnOutline ? "inline-block" : "flex"

		//notes and such -- will be toggled below, inside toggleIndexCards	
			notesAreDisplayed = documentSetting.notesAreDisplayed || false
			markersAreDisplayed = documentSetting.markersAreDisplayed || false
			beatsAreDisplayed = documentSetting.beatsAreDisplayed || false
			reviewsAreDisplayed = documentSetting.reviewsAreDisplayed || false
	
		// indexCardMode -- now shoitched *twice* because once will reverse setting
		// Note: The parameter is only used during applySettings to allow setting mode in spite of no elements yet.
			toggleIndexCardMode(true)
			toggleIndexCardMode(true)

			toggleShowRevisions(documentSetting.showRevisions)

		//Zoom
			zoomSizes(null, documentSetting.currentZoomLevel || 1)

		//TODO: this one is currently unclear -- aren't they set with defaults above?
			showSceneLengths = documentSetting.showSceneLengths || "inline"
			showSceneNumbers = documentSetting.showSceneNumbers || "inline"
			showPageNumbers = documentSetting.showPageNumbers || "inline"
			// currentZoomLevel = documentSetting.currentZoomLevel || 1
			indexCardHeight = documentSetting.indexCardHeight || 5
		
		
		


		$id("flexiContainer").classList.toggle("greyonly", documentSetting.greyonly)
		$id("flexiContainer").classList.toggle("showSynopsisInScenes", documentSetting.showSynopsisInScenes)
		$id("flexiContainer").classList.toggle("boneyardIsClosed", documentSetting.boneyardIsClosed)
		
		cardState = documentSetting.cardState || []

		documentName = documentSetting.documentName
		documentSubName = documentSetting.documentSubName
		documentAuthor = documentSetting.documentAuthor

//TODO: we should remove these and check boxes on menu opens instead. 
//we are currently using some checkboxes as reference to what is on and off, but they should rather reflect values in usersettings etc!

	//Apply the correct checkbox states on open:

		for ([key, value] of Object.entries(userDefault)){					
			let button = document.getElementById("buttonFor-" + key)
				if(button){ 
					if(value == true) button.setAttribute("checked", true) 
				}
		}

	//Apply the correct checkbox states on open:
		for ([key, value] of Object.entries(documentSetting)){					
			let button = document.getElementById("buttonFor-" + key)
				if(button){ 
					if(value == true) button.setAttribute("checked", true) 
				}
		}

	//NOW EXECUTING SOM STUFF BASED ON THE DEFAULTS WE GOT!

		document.documentElement.setAttribute('data-theme', userDefault.colorScheme)

		theRoot.style.setProperty('--showSceneLength', showSceneLengths);
		theRoot.style.setProperty('--showSceneNum', showSceneNumbers);
		theRoot.style.setProperty('--showPageNum', showPageNumbers);
		// theRoot.style.setProperty('--fontSizeFactor', currentZoomLevel)

		// Beat.call(
		// 	`Beat.custom.setWindowSize(${documentSetting.windowSize.x}, ${documentSetting.windowSize.y}, ${documentSetting.windowSize.width}, ${documentSetting.windowSize.height})`
		// )

		firstRun()

		setAllButtons()
		recalculateHeights("from applySettings")
		mylog("DONE getting defaults")

}

function saveCurrentState() {

	mylog()

	rememberCardState()

	Object.assign(documentSetting, {
		
		showNumbers: showSceneNumbers,
		showLengths: showSceneLengths,
		showPages: showPageNumbers,
		currentZoomLevel: currentZoomLevel,
		notepanelWidth: parseInt(getComputedStyle(theRoot).getPropertyValue('--note-panel-width')),

		noteButtonGreen: $id("noteButtonGreen")? $id("noteButtonGreen").checked : true,
		noteButtonYellow: $id("noteButtonYellow")? $id("noteButtonYellow").checked : true,
		noteButtonRed: $id("noteButtonRed")? $id("noteButtonRed").checked : true,
		noteButtonMagenta: $id("noteButtonMagenta")? $id("noteButtonMagenta").checked : true,
		noteButtonPurple: $id("noteButtonPurple")? $id("noteButtonPurple").checked : true,
		noteButtonReview: $id("noteButtonReview")? $id("noteButtonReview").checked : false,

		indexCardHeight: indexCardHeight,

		cardState: cardState,

		notesAreDisplayed: notesAreDisplayed,
		markersAreDisplayed: markersAreDisplayed,
		beatsAreDisplayed: beatsAreDisplayed,
		reviewsAreDisplayed: reviewsAreDisplayed,

		greyonly: ($id("flexiContainer").classList.contains("greyonly")),
		notepanel: ($id("notepanel").classList.contains("expanded")),
		showSynopsisInScenes: ($id("flexiContainer").classList.contains("showSynopsisInScenes")),
		showMultipleSceneLines: ($id("flexiContainer").classList.contains("dualSceneLines")),
		showMultipleSectionLines: ($id("flexiContainer").classList.contains("dualSectionLines")),
		allowLowerCaseSections: ($id("flexiContainer").classList.contains("allowLowerCaseSections")),
		showMultiplewLowerCaseSections: ($id("flexiContainer").classList.contains("verticals")),
		showPageDividers: ($id("flexiContainer").classList.contains("showPageDividers")),

		// documentName: (documentName || false),
		// documentSubName: (documentSubName || false),
		// documentAuthor: (documentAuthor || false),

		boneyardIsClosed: ($id("flexiContainer").classList.contains("boneyardIsClosed")),

		// Values below this point are self-referencing and thus not needed to be explicitly included
		// ideally, we should move other values down to this category, by referencing the documentSetting object in the code instead of the variables themselves
		// such as from above: scenesAreProportinal, showSceneNumbers etc etc.
			//trackingIncludesSynopsis: documentSetting.trackingIncludesSynopsis,
			//showRevisions: documentSetting.showRevisions

	})

	Object.assign(userDefault, {

		realTimeUpdates: realTimeIsOn,		
		loggingIsOn: loggingIsOn,
		
		//AGAIN, these are self-referencing and thus not needed to be saved:
			//colorScheme: colorScheme,
			// ftoutlinerVersion: userDefault.ftoutlinerVersion,
			// excludeVoiceOvers: userDefault.excludeVoiceOvers

	})

	// ACTUALLY WRITING THE SETTINGS TO THE DOCUMENT

		userDefaultString = JSON.stringify(userDefault)
		Beat.call((userDefaultString) => {Beat.setUserDefault("ftoutlinerObject", userDefaultString)}, userDefaultString)
		documentSettingString = JSON.stringify(documentSetting)
		Beat.call((documentSettingString) => {Beat.setDocumentSetting("ftoutlinerObject", documentSettingString)}, documentSettingString)

		// if($id("dumpDiv")) $id("dumpDiv").innerHTML = JSON.stringify(documentSetting, null, 2)
	
	if(!isFullScreen)Beat.call("Beat.custom.saveWindowSize()")
	
	// Logging current classlist of FlexiContainer to dumpDiv
		if($id("dumpDiv")) $id("dumpDiv").innerHTML = [...flexiContainer.classList].toString().replaceAll(",", "<br>")

		console.log("end of save")

}

function toggleDocumentSetting(settingKey){

	let settingValue = documentSetting[settingKey]
		if (typeof settingValue === "boolean") documentSetting[settingKey] = !settingValue
		else return

	applySettings()
	recalculateHeights()
	saveCurrentState()

}

function forceRestart(){

		saveCurrentState()
		Beat.call("Beat.custom.reloadCode()")
		return
	
}

//===============================
function __________LISTENING (){}

function openSettingsWindow(){

	Beat.call(() => Beat.custom.displaySecondWindow("Advanced Settings", "settingswindow.html", 700, 800))

}

function openPrintWindow(){

  let allCSS = '';
  
  // Loop through all stylesheets
  for (let i = 0; i < document.styleSheets.length; i++) {
    const styleSheet = document.styleSheets[i];
    
    // // Handle CORS issues by skipping external stylesheets
    // if (styleSheet.href && styleSheet.href.indexOf(window.location.origin) === -1) {
    //   continue;
    // }
    
    // Loop through all CSS rules
    try {
      const cssRules = styleSheet.cssRules || styleSheet.rules; // cssRules for modern browsers, rules for older versions
      for (let j = 0; j < cssRules.length; j++) {
        allCSS += cssRules[j].cssText + '\n';
      }
    } catch (e) {
      console.warn('Could not read stylesheet:', e);
    }
  }

  	allCSS = "<style>" + allCSS + "</style>"

	let html = JSON.stringify(allCSS + flexiContainer.outerHTML)

	Beat.call((html) => Beat.custom.displaySecondWindow("Print Preview", "printWindow.html", 1200, 800, false, html), html)

}

function escapeWasPressed(){

	if(errorHasFired){return}

		if ($id("advancedSettings".open)) {$id("advancedSettings").close(); return}
		if ($id("menu")){closeNewMenu(); return false}
		// if ($id("dialogpanelcontent") && $id("notepanel").classList.contains("expanded")) {unShowCharacterBubbles(); toggleNotepanel(); return}
		if (helpContainerVisibility == 1) {toggleHelpContainer(); return false}
		if (settingsContainerVisibility == 1) {toggleSettingsContainer(); return false}
		if (trackingContainerVisibility == 1) {toggleTrackingContainer(); return false}
		if ($id('aboutBox')){toggleTrackingContainer(true); return false}
		if ($id('textContainer')){toggleTrackingContainer(true); return false}
		if ($(".contextMenu")) { $$(".contextMenu").forEach(menu => menu.remove()) ; return false }
		if ($(".wider")) {$(".wider").classList.remove("wider"); return false}
		if ($('.expandedReview')) {collapseReviews(); return false}
		if ($id('expandedNote')) {collapseNote(); return false}
		if (aBeatIsHovered) {unhoverAllBeats(); return false}
		if (beatsAreDisplayed) {toggleDisplayBeats(); return false}
		if ($id("notepanel").classList.contains("expanded")){toggleNotepanel(); return false}
		if ($id("flexiContainer").classList.contains("uncolorAllScenesBut")){muteColors(); return false}
		if (characterMenuList?.selectedIndex != -1) {deselectAllCharacters(); return false}
		if (notesAreDisplayed) {toggleDisplayNotes(); return false}
	
}
	
function checkWhatKeyWasReleased(someoneJustReleased){
	mylog()
	if (someoneJustReleased.key == "Alt") releaseALT()	
}

function releaseALT(){

	altIsBeingPressed = false
	previouslyHovered = false
	document.getElementById("printButton").innerHTML = printerIcon

}

function somethingWasClicked() {
	mylog("--------------------")

	let theButton = event.button
	let rightClick = (event.ctrlKey && !event.metaKey && !event.altKey) || theButton == 2
		if(rightClick || event.target.closest(".contextMenu")){
			return
		}

	mylog("flexiContainer classList at time of click: \n" + $id("flexiContainer").classList)

	if(event.target.closest(".bottomButton") 
		|| event.target.classList.contains("displayNumberOf")
		|| event.target.classList.contains("trashNote")
		){mylog("return out of clicked"); return}
	if($id("synEditBox")) return

	let theClickedThing = event.target
	let length

	let a = [...theClickedThing.classList]

	if (a.includes("arrowForIndexCards") || a.includes("sectionArrow")){
		anArrowWasClicked(theClickedThing); 
		return	
	}

	if (a.includes("generalButtonStyle")){
		mylog("returns because .generalButtonStyle")
		return
	}

	if (a.includes("synopsiscontainer")){
		theClickedThing = theClickedThing.parentNode
		a = [...theClickedThing.classList]
	}

	if (a.includes("boneyard") || (a.includes("section-heading") && theClickedThing.closest(".section").classList.contains("boneyard"))){

		$id("flexiContainer").classList.toggle("boneyardIsClosed")
		return

	}

	if (a.includes("widerButton") || a.includes("widerButtonOn")) {makeWider(theClickedThing)}

	mylog("before if(event.altKey)")

	if(event.altKey && !event.metaKey){

		muteColors(theClickedThing, event.shiftKey) 
		//NOTE: sending literal clicked thing here, so can be either scene or sceneheading!
		return
		
	}

	let gotoIndex = Math.max(parseInt(theClickedThing.getAttribute("data-line")), 0.1) //why?

	//All note-clicking scenarios
		if (["expandedNote", "notepanelNote", "note"].some(className => theClickedThing.classList.contains(className))) {

			if(theClickedThing.classList.contains("note") && userDefault.oldNoteBehavior != true) return

			let length = theClickedThing.closest(".expandedNote, .notepanelNote, .note").dataset.length
			let color = window.getComputedStyle(theClickedThing.closest(".expandedNote, .notepanelNote, .note")).backgroundColor || "#888"
			gotoIndex = parseInt(theClickedThing.getAttribute("data-line"))		
			goto(gotoIndex, theClickedThing, length, rgbToHex(color))
			return
		}
	
	switch(theClickedThing.id){
		case "expandedNote":
		case "notepanelNote":
			// length = theClickedThing.closest(".expandedNote, .notepanelNote, .note").dataset.length
			// gotoIndex = parseInt(theClickedThing.getAttribute("data-line"))		
			// goto(gotoIndex, theClickedThing, length)
			return
		case "cover": 
			if (settingsContainerVisibility==1){
				toggleSettingsContainer()
			}
		case "buttonRow":
			if ($id("menu")){
				$id("menu").remove()
			}
			$id("printbox")?.remove()
			// if (trackingContainerVisibility==1){
				toggleTrackingContainer(true)
			// }
			return
		// case "flexiContainer":
		// 	if($(".wider"))makeWider($(".wider"))
	}

	//ADDED TO FIX WHAT CONSIDERS CLICKED when in Index Card Mode
	//this is redundant now, right?
		if (documentSetting.indexCardMode && [...theClickedThing.classList].includes("synopsiscontainer")){
			while(theClickedThing.parentNode 
				&& 
				(![...theClickedThing.classList].includes("scene") && ![...theClickedThing.classList].includes("section")))
				{
				theClickedThing = theClickedThing.parentNode
			}
		}

		//Yes: This is needed
		if (documentSetting.indexCardMode && [...theClickedThing.classList].includes("section")){
			while(theClickedThing.firstChild && ![...theClickedThing.classList].includes("section-heading")){
				theClickedThing = theClickedThing.firstChild
			}
		}
	
	 if(theClickedThing.id != "cycleNoteForwardMenuItem" && theClickedThing.id != "cycleNoteBackwardMenuItem"){
		collapseNote()
	}
	
	if (rightClick || contextMenuIsOpen) {
			x = event.clientX
			y = event.clientY

		contextMenu(theClickedThing, x, y, rightClick)
		mylog("back from contexMenu() into SomethingWasClicked()")
		mylog("whereto?")
		return false
	}

	// LOGIC TO SELECT AND DESELECT CLICKED ELEMENT(S)

	if (a.includes("section-heading")) {theClickedThing = theClickedThing.parentNode; a = [...theClickedThing.classList]}
	if (a.includes("sceneheading")) {theClickedThing = theClickedThing.parentNode; a = [...theClickedThing.classList]}

	if (event.metaKey && !event.altKey){
		if (a.includes("isSelected")) {
			theClickedThing.classList.remove('isSelected')
			updateSelectionInfo()
			return
		}

		if (a.includes("scene") || a.includes("section") || a.includes("synopsis")) {
			theClickedThing.classList.add('isSelected')
		}
		updateSelectionInfo()
		if(!documentSetting.clickingFocusesEditor) return
	}

	if (event.shiftKey){
		let alreadySelectedElements = $$(".isSelected")
		if (alreadySelectedElements.length == 0){
				if ($id("youAreHere")) {
					let setCurrentElementToStartElement = $id("youAreHere").parentNode.id
					$id(setCurrentElementToStartElement).classList.add("isSelected")
				}else{
					theClickedThing.classList.add('isSelected')
					updateSelectionInfo()
					return
				}
			//updateSelectionInfo()
		}

		if (a.includes("synopsis")){

			let allSynopsis = Array.from($$(".synopsis"))
			let justSelectedSynopsis = allSynopsis.indexOf(theClickedThing)
			let firstSynopsis = allSynopsis.indexOf(alreadySelectedElements[0])
			let lastSynopsis = allSynopsis.indexOf(alreadySelectedElements[alreadySelectedElements.length - 1])
			
			if (justSelectedSynopsis < firstSynopsis){
				for (let selectThis = justSelectedSynopsis; selectThis < firstSynopsis; selectThis++ ){
					allSynopsis[selectThis]?.classList.add("isSelected")
				}
			}
			if (justSelectedSynopsis > lastSynopsis){
				for (let selectThis = lastSynopsis; selectThis < justSelectedSynopsis + 1; selectThis++ ){
					allSynopsis[selectThis]?.classList.add("isSelected")
				}
			}
			if (firstSynopsis < justSelectedSynopsis && justSelectedSynopsis < lastSynopsis){
				let selectThis = justSelectedSynopsis
				do {
					allSynopsis[selectThis]?.classList.add("isSelected")
					selectThis --
				} while(!allSynopsis[selectThis]?.classList.contains("isSelected"))
			}
			return
		}

		let closestPredecessor = -1
		let closestSuccessor = -1
		let thisOne = Number(theClickedThing.id)

		for (element of alreadySelectedElements){
			a = Number(element.id)

			if (a < thisOne){closestPredecessor = a;}
			if (a > thisOne){closestSuccessor = a; break}
		}

		if (closestPredecessor < 0) {

			for (i = thisOne; i <= closestSuccessor; i++){
				let selectThis = $id(i)
				if (selectThis){
					if (![...selectThis.classList].includes("dimmedScene") && ![...selectThis.classList].includes("dimmedSection") && ![...selectThis.classList].includes("synopsis")){
						if (!(documentSetting.scenesAreProportional && [...selectThis.classList].includes("isOmitted"))){
							selectThis.classList.add('isSelected')
						}
					}
				}
			}
		}else{
			for (i = closestPredecessor; i <= thisOne; i++){				
				let selectThis = $id(i)
				if (selectThis){
					if (![...selectThis.classList].includes("dimmedScene") && ![...selectThis.classList].includes("dimmedSection") && ![...selectThis.classList].includes("synopsis")){
						if (!(documentSetting.scenesAreProportional && [...selectThis.classList].includes("isOmitted"))){
							selectThis.classList.add('isSelected')
						}
					}
				}
			}
		}
		updateSelectionInfo()
		return
	}

	if(documentSetting.clickingFocusesEditor){
		if(!theClickedThing.closest(".scene, .section, .synopsis")) deselectAllElements()
	}else{
		deselectAllElements()
	}

	//Finally: if the clicked thing was an outline element, let's go there!

	// if([...theClickedThing.classList].includes('note')){	
	// 	length = theClickedThing.innerHTML.replace(/\<br\>/g, "\n").length + 5
	// }
	if (theClickedThing.classList.contains("review")){
		expandReview(theClickedThing)
		length = parseInt(theClickedThing.getAttribute("data-length")) + 1
	}else{
		expandReview()
	}


	if (a.includes("revision")){

		length = theClickedThing.dataset.length + 1
		
	}

	if(theClickedThing.classList.contains('scene') || theClickedThing.classList.contains('sceneheading') || theClickedThing.classList.contains('synopsis') ){
		theClickedThing.classList.add('isSelected')
	} //because every click also counts as a first selection
	if(theClickedThing.classList.contains("section-heading") || theClickedThing.classList.contains("section")){
		theClickedThing.closest(".section").classList.add("isSelected")
	}

	updateSelectionInfo()

	// setTimeout(makeWider(theClickedThing),210)

	mylog("end of sthWasClicked -- " + theClickedThing.classList)

		//Behavior depending on settings:

		//Clicking a scene immediately focuses Editor
		if(documentSetting.clickingFocusesEditor && !event.metaKey){
			if (theClickedThing.closest(".scene, .section, .synopsis")){
				Beat.call("Beat.focusEditor()") 
			}
		}

	if (gotoIndex) {goto(gotoIndex, theClickedThing, length)}
	mylog("now returning")
}

var selectionInfo = {}

function updateSelectionInfo(){

	if(!documentSetting.showSelectionInfo) return
	if(!$$(".isSelected, .dimmedScene, .dimmedSection, .uncolorAllScenesBut")) return

	let selectionInfo = {}
		selectionInfo.length = 0
		selectionInfo.numberOfScenes = $$(".scene.isSelected").length
		selectionInfo.numberOfSections = $$(".section.isSelected").length

		$id("infoField").style.backgroundColor = "" //resets color if set previously
		$id("infoField").style.opacity = "" //resets opacity if set previously

	let measurableStuff = $$(".scene.isSelected, .orphan.isSelected, .section.isSelected")
	let actionWord = "selected scene" + (measurableStuff.length > 1 ? "s" : "")

	if (measurableStuff.length == 0 && $(".dimmedScene, .dimmedSection")) {
		measurableStuff = $$(".scene:not(.dimmedScene), .section:not(.dimmedSection)")
		actionWord = "scene" + (measurableStuff.length > 1 ? "s" : "") + " with " + $id("characterMenuList")?.selectedOptions[0]?.value
	}else if (measurableStuff.length == 0 && flexiContainer.classList.contains("uncolorAllScenesBut")) {
		let color = colorsArray.find(color => flexiContainer.classList.contains(color.toLowerCase()))?.toLowerCase()
		measurableStuff = $$(".scene." + color)
		actionWord = color + " scene" + (measurableStuff.length > 1 ? "s" : "")
		$id("infoField").style.backgroundColor = "color-mix(in oklab, hsl(var(--" + color + ")), white 20%)"
		$id("infoField").style.opacity = "0.8"
	}

	measurableStuff.forEach(element => {
		
		selectionInfo.length += Number(element.dataset.lengthOfScene)

	})

	$id("infoField").innerHTML = measurableStuff.length > 0 ?
		`${selectionInfo.numberOfScenes || measurableStuff.length} ${actionWord}<br/>
		${numberIntoEights(selectionInfo.length).replace(/pg(s*)/, "")} pages total`
		: ""


}

function makeWider(theClickedThing, cycledWithKey, shift){

		theRoot.style.setProperty('--wider-width', $$(".level1").length/2);


		if (theClickedThing && theClickedThing.closest(".level1").classList.contains("wider")){
			let allWidened = $$(".wider")
			allWidened.forEach(element => {
				element.classList.remove("wider")
			})
			return
		}

		if (theClickedThing) {
			$(".wider")?.classList.remove("wider")
			theClickedThing.closest(".level1").classList.add("wider")
			return
		}

		if (!cycledWithKey) return

		let allActs = $$(".level1")
		let currentlyWidened = $(".wider") || null
			if(allActs.length = 0)return

		if(currentlyWidened && $(".isSelected")){
			$(".wider").classList.remove("wider")
			return
		}
	
		let value = [].indexOf.call(allActs, currentlyWidened)

		value += (shift ? -1 : 1) 
			if(value < -1)value = allActs.length - 1
			if(value > allActs.length - 1)value =  - 1
			// if(!currentlyWidened && $(".isSelected")){
			if($(".isSelected")){
				value = [].indexOf.call(allActs, $(".isSelected").closest(".level1"))
			}

		currentlyWidened?.classList.remove("wider")
		if(value > -1) allActs[value].classList.add("wider")

			
			// for (let i = 0; i < allActs.length; i++){
			// 	if (allActs[i].classList.contains("wider")) break
			// }
		
			// allActs[i].classList.remove("wider")

			// i++
			// if (i > allActs.length) i = 0
			// allActs[i].classList.add("wider")

		// }
	}

function walkTheOutline(e){

	mylog()

	let direction = (e.key == "ArrowDown") ? 1 : -1

	let selectedElements = $$(".isSelected")
	let startingElement

		if (selectedElements.length > 0) {
			if (direction == 1) {
				startingElement = selectedElements[selectedElements.length - 1].closest(".scene, .section");
				} else {
				startingElement = selectedElements[0].closest(".scene, .section");
			}
		} else {
			if (!$id("youAreHere")) return;
			startingElement = $id("youAreHere").closest(".scene, .section");
		}

	let gotoElement = Number(startingElement.id) + direction
		if (gotoElement < 0 || gotoElement > outline.length - 1) return

		if(!e.shiftKey)deselectAllElements()

		$id(gotoElement).classList.add("isSelected")
		updateSelectionInfo()

	let gotoIndex = $id(gotoElement).getAttribute("data-line")
	let theClickedThing = $id(gotoElement)
	let length = outline[gotoElement].line.string.length + 1
	let blinkColor = theClickedThing.style.backgroundColor

	goto(gotoIndex, theClickedThing, length, blinkColor)

}

function walkTheOutlineSideWays(e){

	if(documentSetting.oneColumnOutline || $$(".level1").length < 2) return

	let element = $$(".isSelected").length == 1 ? $(".isSelected") : ($id("youAreHere").closest(".scene, .section"))
	let direction = (e.key == "ArrowRight") ? 1 : -1

	let allColumns = $$(".level1")
	let thisColumn = element.closest(".level1")
	let thisColumnNumber = Array.from(allColumns).indexOf(thisColumn)

	let gotoColumn = thisColumnNumber + direction
		if(gotoColumn < 0 || gotoColumn > allColumns.length - 1) return

	let currentBoundings = element.getBoundingClientRect()

	// let gotoElement = Array.from(($$(".level1"))[gotoColumn].querySelectorAll(".scene, .section")).filter(element => element.getBoundingClientRect().top >= heightOnPage)[0]
	
	
	let gotoElement = Array.from($$(".level1")[gotoColumn].querySelectorAll(".scene, .section-heading")).filter(element => {
		gotoBoundings = element.getBoundingClientRect()
    	return 	gotoBoundings.top >= currentBoundings.top && gotoBoundings.top + gotoBoundings.height <= currentBoundings.top + currentBoundings.height //means gotoelement is inside current's boundaries
				||
				gotoBoundings.top <= currentBoundings.top && gotoBoundings.top + gotoBoundings.height >= currentBoundings.top + currentBoundings.height //means current element is inside gotoelement's boundaries
				||
				gotoBoundings.top >= currentBoundings.top //finally, means gotoelement is below current element
  	})[0]?.closest(".scene, .section");
	
	if(!gotoElement) gotoElement = Array.from($$(".level1")[gotoColumn].querySelectorAll(".scene, .section")).at(-1)
		if(!gotoElement) return

	if(!e.shiftKey)deselectAllElements()
	gotoElement.classList.add("isSelected")

	let gotoIndex = gotoElement.getAttribute("data-line")
	let length = outline[gotoElement.id].line.range.length
	// let blinkColor = gotoElement.style.backgroundColor	
	updateSelectionInfo()
	goto(gotoIndex, gotoElement, length)


}

let waitStateCounter = 0

function toggleWaitState(trueOrFalse){

	mylog("toggleWaitState: " + trueOrFalse)

	if (trueOrFalse) {
		waitStateCounter++
		console.log("waitStateCounter: " + waitStateCounter)
	}else{
		waitStateCounter = 0
		console.log("waitStateCounter was RESET.")
	}

	document.getElementById('outOfSyncDiv').style.display = trueOrFalse ? 'block' : "none"
	document.getElementById('outOfSyncDiv').classList.toggle('animate', trueOrFalse)
	document.getElementById('flexiContainer').classList.toggle('wait', trueOrFalse)



}

function __________TOGGLERS(){}

function advancedTogglers(classToToggle, buttonId, absolute){
	mylog()

	flexiContainer.classList.toggle(classToToggle)
	$id(buttonId).checked = flexiContainer.classList.contains(classToToggle)

	if(classToToggle=="dualSectionLines")recalculateHeights()

	saveCurrentState()

}

function setSharedScreen(){
	mylog()

	let availHeight = window.screen.availHeight
	let availWidth = window.screen.availWidth

	Beat.call(`Beat.custom.makeWindowsShareScreen(${availHeight}, ${availWidth})`)

}

function toggleFullScreen(){
	mylog()

	isFullScreen = !isFullScreen
	Beat.call(`Beat.custom.toggleFull()`)

}

function switchFocus(){
	mylog()

	if (flexiContainer.classList.contains("focused")){
		Beat.call(() => Beat.focusEditor())
	}else{
		Beat.call(() => Beat.custom.switchToHTML())
	}

}

function toggleExcludeVoiceOvers(){
	mylog()

	userDefault.excludeVoiceOvers = !userDefault.excludeVoiceOvers

	saveCurrentState()
	
	updateFilter()
	
	setAllButtons()
	firstRun()

}

function toggleIncludeSynopsis(){
	mylog()

	documentSetting.trackingIncludesSynopsis = !documentSetting.trackingIncludesSynopsis

	saveCurrentState()

	collectCharacters()

	setAllButtons()
	firstRun()

}

function toggleMultipleSceneLines(){
	mylog()

	documentSetting.showMultipleSceneLines = !documentSetting.showMultipleSceneLines
	flexiContainer.classList.toggle("dualSceneLines", documentSetting.showMultipleSceneLines)

	setAllButtons()
	saveCurrentState()

}

function toggleInvertText(){
	mylog()

	userDefault.invertTextOnDark = !userDefault.invertTextOnDark

	reevaluateColorContrast()
	setAllButtons()
	saveCurrentState()

}

function toggleOneColumnOutline() { 
	mylog()

	documentSetting.oneColumnOutline = !documentSetting.oneColumnOutline

	flexiContainer.style.display = documentSetting.oneColumnOutline ? "inline-block" : "flex"
	$id("flexiContainer").classList.toggle("oneColumnOutline", documentSetting.oneColumnOutline)
	
	setAllButtons()
	saveCurrentState()
	recalculateHeights("from ToggleOneColumnOutline") // or else, in index card mode, cards get the wildest sizes.

	if(notesAreDisplayed){toggleDisplayNotes(); toggleDisplayNotes()}
	if(markersAreDisplayed){toggleDisplayMarkers(); toggleDisplayMarkers()}
	if(beatsAreDisplayed){toggleDisplayBeats(); toggleDisplayBeats()}
	if(reviewsAreDisplayed){toggleDisplayReviews(); toggleDisplayReviews()}
}

function toggleIndexCardMode(firstrun){
	mylog()

	documentSetting.indexCardMode = !documentSetting.indexCardMode
	
	if(!firstrun){ // will allow changing in spite of empty flexicontainer when opening doc and restoring mode!
		if($$(".scene").length == 0 && $$(".section").length == 0){documentSetting.indexCardMode = false}
	}

	if (documentSetting.indexCardMode) {

			mylog("indexCards ON")

			if(!firstrun){ // or else sluglines will blink when changing values in settings dialog.
				$$(".sluglineIsHidden").forEach(element => {
					element.classList.remove("sluglineIsHidden")
				})
			}

			scenesWereProportionalBeforeIndexMode = (documentSetting.scenesAreProportional)
			documentSetting.scenesAreProportional = false
			flexiContainer.classList.remove("nonProportionalMode")
				
			flexiContainer.classList.add("indexcards")
			document.getElementById("indexCardButton").innerHTML = newIndexCardIcon
			
	}else{

			mylog("indexCards OFF")
			
			flexiContainer.classList.remove("indexcards")
			document.getElementById("indexCardButton").classList.remove("buttonIsActive")

			//turn back proportional to where it was before indexCards, and have icon redraw. 
				toggleProportional(scenesWereProportionalBeforeIndexMode)

	}

	if(firstrun) return

	setAllButtons()
	youAreHere()
	recalculateHeights("from toggleIndexCardMode")
	saveCurrentState()
	reevaluateColorContrast()

	if(notesAreDisplayed){toggleDisplayNotes(); toggleDisplayNotes()}
	if(markersAreDisplayed){toggleDisplayMarkers(); toggleDisplayMarkers()}
	if(beatsAreDisplayed){toggleDisplayBeats(); toggleDisplayBeats()}
	if(reviewsAreDisplayed){toggleDisplayReviews(); toggleDisplayReviews()}

	mylog("end cycling index card mode")
}
	
function toggleShowSceneNumbers() {
	mylog()
	
	if (showSceneNumbers == "inline") {
		theRoot.style.setProperty('--showSceneNum', 'none');	
		}else{
		theRoot.style.setProperty('--showSceneNum', 'inline');	
		}
		
	showSceneNumbers = theRoot.style.getPropertyValue('--showSceneNum');
	documentSetting.showSceneNumbers = showSceneNumbers

	setAllButtons()
	saveCurrentState()
}

function toggleShowPageNumbers() {
	mylog("toggleShowPageNumbers")
	if (showPageNumbers == "inline") {
		theRoot.style.setProperty('--showPageNum', 'none');	
		}else{
		theRoot.style.setProperty('--showPageNum', 'inline');	
		saveCurrentState()
	}
		
	showPageNumbers = theRoot.style.getPropertyValue('--showPageNum');
	documentSetting.showPageNumbers = showPageNumbers

	recalculateHeights()
	setAllButtons()
}

function toggleShowSceneLength() {
	mylog()
	
	if (showSceneLengths == "inline") {
		theRoot.style.setProperty('--showSceneLength', 'none');	
		}else{
		theRoot.style.setProperty('--showSceneLength', 'inline');	
	}
		
	showSceneLengths = theRoot.style.getPropertyValue('--showSceneLength'); //double-check: Do I still use this?
	documentSetting.showSceneLengths = showSceneLengths

	setAllButtons()
	saveCurrentState()
}

function toggleWarnings() {
	mylog()

	userDefault.warningsAreOn = !userDefault.warningsAreOn
		
	setAllButtons()
	saveCurrentState()
}

function toggleShowRevisions(absolute) {
	mylog()

  	documentSetting.showRevisions = typeof absolute === 'undefined' ? !documentSetting.showRevisions : absolute;

	if(documentSetting.showRevisions){
		collectRevisionIndices()
	}else{
		$$(".revision").forEach(revision => { revision.remove() })
	}
	
	setAllButtons()
}

function toggleDisplayNotes() {
	mylog()

	documentSetting.notesAreDisplayed = !documentSetting.notesAreDisplayed
	notesAreDisplayed = documentSetting.notesAreDisplayed
		
	if(notesAreDisplayed){
		collectNotes("toggleDisplayNotes")
	}else{
		collapseNote()
		let noteElements = $$(".noteContainer")
			noteElements.forEach(element => {element.remove()})
	}
	setAllButtons()
	//saveCurrentState()
}

function toggleDisplayMarkers() {
	mylog()

	documentSetting.markersAreDisplayed = !documentSetting.markersAreDisplayed
	markersAreDisplayed = documentSetting.markersAreDisplayed
	
	if(markersAreDisplayed){
		document.getElementById("flexiContainer").classList.add("markersAreDisplayed")
		collectNotes("toggleDisplayMarkers")
	}else{
		document.getElementById("flexiContainer").classList.remove("markersAreDisplayed")
		let currentMarkers = document.querySelectorAll(".marker")
        for (currentMarker of currentMarkers){currentMarker.remove()}
	}
	setAllButtons()
	//saveCurrentState()
}

function toggleDisplayReviews() {
	mylog()

	documentSetting.reviewsAreDisplayed = !documentSetting.reviewsAreDisplayed
	reviewsAreDisplayed = documentSetting.reviewsAreDisplayed

	if(reviewsAreDisplayed){
		flexiContainer.classList.add("reviewsAreDisplayed")
		collectReviews()
	}else{
		flexiContainer.classList.remove("reviewsAreDisplayed")
		let existingReviews = $$(".review")
		for (existingReview of existingReviews){existingReview.remove()}
	}

	setAllButtons()

}

function toggleDisplayBeats() {
	mylog()

	documentSetting.beatsAreDisplayed = !documentSetting.beatsAreDisplayed
	beatsAreDisplayed = documentSetting.beatsAreDisplayed
	
	if(documentSetting.beatsAreDisplayed){
		$("#flexiContainer").classList.add("beatsAreDisplayed")
		collectNotes("toggleDisplayBeats")
	}else{
		$("#flexiContainer").classList.remove("beatsAreDisplayed")
		let currentBeats = $$(".beat")
        for (currentBeat of currentBeats){currentBeat.remove()}
		let currentPaths = $$(".svgForBeats")
		for (currentPath of currentPaths){currentPath.remove()}
	}
	setAllButtons()
	//saveCurrentState()
	mylog("end of toggling Beats")
}

function toggleDisplaySynopsis() {
	mylog()

	if ($id("flexiContainer").classList.contains("indexcards")){return}

	document.getElementById("flexiContainer").classList.toggle("showSynopsisInScenes")
	documentSetting.showSynopsisInScenes = document.getElementById("flexiContainer").classList.contains("showSynopsisInScenes")

	setAllButtons()
}
	
function toggleSettingsContainer() { 
	mylog()

	if (trackingContainerVisibility == 1){toggleTrackingContainer()}
	if (helpContainerVisibility == 1){toggleHelpContainer()}

	settingsContainerVisibility = 1 - settingsContainerVisibility;
	settingsContainer.style.display = blockOrNone[1-settingsContainerVisibility];
	coverContainer.style.display = blockOrNone[1-settingsContainerVisibility];
}

function toggleHelpContainer() {
	mylog()

	closeNewMenu()

	if (trackingContainerVisibility == 1){toggleTrackingContainer()}
	if (settingsContainerVisibility == 1){toggleSettingsContainer()}

	helpContainerVisibility = 1 - helpContainerVisibility;
	helpContainer.style.display = blockOrNone[1-helpContainerVisibility];
	coverContainer.style.display = blockOrNone[1-helpContainerVisibility];
}

function toggleTrackingContainer(close) { 
	mylog()

	if (settingsContainerVisibility == 1){toggleSettingsContainer()}
	if (helpContainerVisibility == 1){toggleHelpContainer()}
	$id("aboutBox")?.remove()
	$("#textContainer")?.remove()

	if($id("menu")){$id("menu").remove()}

	trackingContainerVisibility = 1 - trackingContainerVisibility;
		if(close){trackingContainerVisibility = 0}

	if (trackingContainerVisibility == 1) {collectCharacters()}
	trackingContainer.style.display = blockOrNone[1-trackingContainerVisibility];
	coverContainer.style.display = blockOrNone[1-trackingContainerVisibility];
}

function toggleColorScheme() { 
	mylog()

	userDefault.colorScheme = 'FTOutlinerBeat'.replace(userDefault.colorScheme, "")
	document.documentElement.setAttribute('data-theme', userDefault.colorScheme)
	
	setAllButtons()
	saveCurrentState()
	reevaluateColorContrast()
	updateDialogPanel()
}

function outdoorMode(){
	mylog()

	documentSetting.outdoor = 1 - documentSetting.outdoor
	document.documentElement.setAttribute('data-outdoors', documentSetting.outdoor)

	setAllButtons()
	updateDialogPanel()
	reevaluateColorContrast()

}
	
function toggleProportional(absolute) { 
	mylog()

	if(documentSetting.indexCardMode){
		toggleIndexCardMode(); 
		if(typeof absolute === 'undefined'){
			return
		}
	}

	documentSetting.scenesAreProportional = typeof absolute === 'undefined' ? !documentSetting.scenesAreProportional : absolute;
	
	flexiContainer.classList.toggle("nonProportionalMode", !documentSetting.scenesAreProportional)
	document.getElementById("indexCardButton").innerHTML = documentSetting.scenesAreProportional ? outlineIcon : fixedIcon

	if(!documentSetting.scenesAreProportional){
		$$(".sluglineIsHidden").forEach(element => {
			element.classList.remove("sluglineIsHidden")
		})
	}

	if (documentSetting.notesAreDisplayed){
		toggleDisplayNotes()
		toggleDisplayNotes()
	}

	if (documentSetting.markersAreDisplayed){
		toggleDisplayMarkers()
		toggleDisplayMarkers()
	}

	if (documentSetting.beatsAreDisplayed){
		toggleDisplayBeats()
		toggleDisplayBeats()
	}

	if (documentSetting.reviewsAreDisplayed){
		toggleDisplayReviews()
		toggleDisplayReviews()
	}

	recalculateHeights("from ToggleProportional")

	setAllButtons()
	saveCurrentState()
	reevaluateColorContrast()
}

function toggleRealTime() {
	mylog()

	realTimeIsOn = 1 - realTimeIsOn;
	documentSetting.realTimeIsOn = realTimeIsOn

	setAllButtons()
}

function addShowHideBoneyard(){
	mylog()

	if(!$(".boneyard")){

		let doThis = `Beat.addString(\"\\n#BONEYARD\\n\\n===\\n\\n\", Beat.getText().length)`
		Beat.call(doThis)
		flexiContainer.classList.remove("boneyardIsClosed")
		return
	}

	flexiContainer.classList.toggle("boneyardIsClosed")
	setAllButtons()

}

var dialogTimeOut

function changeSaturation(){
	mylog()

	documentSetting.saturation = Number($id("saturationRange").value)
	document.documentElement.style.setProperty('--saturation', documentSetting.saturation + "%")

	if (dialogTimeOut) clearTimeout(dialogTimeOut)
		dialogTimeOut = setTimeout(() => {
			updateDialogPanel()
		}, 200);
	saveCurrentState()

}

function __________ACTIONS(){}

function goto(gotoIndex, theClickedThing, length = theClickedThing?.dataset.length, blinkColor = theClickedThing?.dataset.color){

	mylog("goto " + gotoIndex)

	let classes = [...theClickedThing.classList]
	if (classes.includes("sceneheading") || classes.includes("scene") || classes.includes("section") || classes.includes("synopsis")){
		Beat.call("Beat.scrollToScene(Beat.currentParser.sceneAtIndex(" + gotoIndex + "))")
	}
		
	//if (classes.includes("showActLength")){gotoIndex ++}
	gotoIndex = Math.min(gotoIndex, absoluteTextLength - 1)
	
	Beat.call("Beat.scrollTo(" + gotoIndex + ")") 

	if (classes.includes("pageDivider")) return
	if (classes.includes("location")) {
		gotoIndex = theClickedThing.dataset.startIndex
		length = theClickedThing.dataset.endIndex - theClickedThing.dataset.startIndex
	}

	let elementColor = window.getComputedStyle(theClickedThing).backgroundColor
	let textColor
	if ((classes.includes("scene") || classes.includes("revision")) && elementColor){
		let values = elementColor.replace(/rgb(a)*\(/, "").replace(")", "").split(",")
		let rgbAsHex = ""
		for (value of values){
			if (rgbAsHex.length == 6){break}
			let thisvalue = Number(value).toString(16).toUpperCase()
			thisvalue = thisvalue.length > 1 ? thisvalue : "0" + thisvalue
			rgbAsHex += thisvalue
		}
		blinkColor = "#" + rgbAsHex
		textColor = "#222222"
	}

	if (classes.includes("note") || classes.includes("expandedNote") || classes.includes("notepanelNote")){
		//blinkColor = rgbToHex(theClickedThing.dataset.color) || "#cccc55"
		//2023 commented out: length = Number(theClickedThing.dataset.length) + (Number(theClickedThing.dataset.inline)? 1 : 0)
		//alertThis(rgbToHex(theClickedThing.dataset.color))
	}

	blinkColor = blinkColor || "#888888"
	textColor = textColor || false

	let blinkLength = length || "Beat.currentParser.lineAtIndex(" + gotoIndex + ")?.string?.length + 1"
		Beat.call("Beat.custom.blinkTheLine(" + gotoIndex + "," + blinkLength + ", '" + blinkColor + "' , '" + textColor + "');")

	//Select the clicked thing in the editor
		if(documentSetting.clickingSelectsInEditor || (event.metaKey && event.ctrlKey && event.altKey)){		
			if (theClickedThing.closest(".scene, .section")){
				let lineOfScene = outline[theClickedThing.closest(".scene, .section, .synopsis").dataset.myId]
				Beat.call("Beat.setSelectedRange(" + lineOfScene.sceneStart + "," + (lineOfScene.sceneEnd - lineOfScene.sceneStart) + ")")
			}
		}

}

function rgbToHex(rgbString){

	let values = rgbString.replace(/rgb(a)*\(/, "").replace(")", "").split(",")
	let rgbAsHex = "#"
	for (value of values){
			if (rgbAsHex.length == 7){ break }
			let thisvalue = Number(value).toString(16).toUpperCase()
				thisvalue = thisvalue.length > 1 ? thisvalue : "0" + thisvalue
				rgbAsHex += thisvalue
		}
	return rgbAsHex
}

function selectAllElements(altWasPressed) {
	mylog("selectAllElements")
	let allElements = $$(".scene, .section")
	for (element of allElements){

		let docontinue = false

		if (![...element.classList].includes("dimmedScene") && ![...element.classList].includes("dimmedSection")){
			if(altWasPressed && [...element.classList].includes("section")){docontinue = true}

			
			if([...document.getElementById("flexiContainer").classList].includes("uncolorAllScenesBut")){
				docontinue = true
				for (let color of colorsArray){
					if([...document.getElementById("flexiContainer").classList].includes(color.toLowerCase()) && [...element.classList].includes(color.toLowerCase())){
						docontinue = false
					}
				}
			}

		if (docontinue){continue}
		element.classList.add("isSelected")
		}
	}
	updateSelectionInfo()
}

// Below is a function stolen from https://davidwalsh.name/javascript-debounce-function

// Returns a function, that, as long as it continues to be invoked, will not be triggered. 
// The function will be called after it stops being called for N milliseconds. 
// If `immediate` is passed, trigger the function on the leading edge, instead of the trailing.

function debounce(func, wait, immediate) { 
	//currently only used from somoneResizedTheWindow()
	
	var timeout;
	return function() {
		var context = this, args = arguments;
		var later = function() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};
		var callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
}

function changeIndexCardHeight(key){

	switch (key){
		case "=":
		case "+":
			//indexCardHeight = Math.min(4.5, Number(indexCardHeight) + 0.25) 
			indexCardHeight = Math.min(20, Number(indexCardHeight) + 1) 
		break;
		case "-":
			//indexCardHeight = Math.max(0.5, Number(indexCardHeight) - 0.25) 
			indexCardHeight = Math.max(0, Number(indexCardHeight) - 1) 
		break;
		case "0":
			indexCardHeight = 5
	}

	recalculateHeights("from changeIndexCardHeight")
	saveCurrentState()

	if (notesAreDisplayed){displayNotes()}
}

function zoomSizes(key, explicitLevel){

	currentZoomLevel = getComputedStyle(theRoot).getPropertyValue('--fontSizeFactor')

	switch (key){
		case "=":
		case "+":
			newZoomLevel = Math.min(2, Number(currentZoomLevel) + 0.2) 
		break;
		case "-":
			newZoomLevel = Math.max(0.4, Number(currentZoomLevel) - 0.2) 
		break;
		case "0":
			newZoomLevel = 1
		break;
		default:
			newZoomLevel = explicitLevel || 1
	}

	// if(!newZoomLevel) return //this can happen if we press a legal shortcut but with an extra modifier key. 

	theRoot.style.setProperty('--fontSizeFactor', newZoomLevel)
	currentZoomLevel = newZoomLevel

	setTimeout(() => {
		
		recalculateHeights("from zoomSizes")
	}, 300);
	saveCurrentState()

	if (notesAreDisplayed){displayNotes()}

}

function isThisOffScreen(element){

	mylog("======== determining off/onscreen for..." + element?.classList)

	if(!element) return

	let rect = element.getBoundingClientRect()

	// mylog("this is the element's measurements:")
	// mylog("rightmost point: " + (rect.x + rect.width))
	// mylog("topmost point: " + (rect.y))
	// mylog("window width: " + window.innerWidth)
	// mylog("window height: " + window.innerHeight)
	

	let result = (
		(rect.x + rect.width) < 0 
            || 
		(rect.y) < 20
            || 
		(rect.x > window.innerWidth 
			|| 
		rect.y + rect.height > (window.innerHeight - 70))
	)

	return result
}

function scrollNicelyIntoView(element, whichContainer){

	mylog("scrollNicely")

	if(weAreCurrentlyEditingText) return
	if(!element) return

	//Webkit 15.4
		// element.scrollIntoView("smooth", "center")
		// return

	if(!whichContainer) whichContainer = flexiContainer

		let elementRect = element.getBoundingClientRect()
		// let frameRect = document.getElementById("flexiContainer").getBoundingClientRect()
		let frameRect = whichContainer.getBoundingClientRect()
		// let currentScroll = document.getElementById("flexiContainer").scrollTop
		let currentScroll = whichContainer.scrollTop
		let currentBottom = frameRect.height + currentScroll

		
		let oldPos = elementRect.top
		let targetPos = currentScroll + oldPos - frameRect.bottom/2


		let diff = (targetPos - currentScroll) / 10
		let newPos = currentScroll

		if (targetPos > currentScroll){
			function stepUp() {
				newPos = newPos + diff
				// document.getElementById("flexiContainer").scrollTo(0, newPos)
				whichContainer.scrollTo(0, newPos)
				if (whichContainer == $id("dialogpanelcontent")) updateDialogPanelOnScroll()

				if (newPos < targetPos) {
					mylog("animating UP")
					window.requestAnimationFrame(stepUp)
				}
			}
			window.requestAnimationFrame(stepUp)
		}

		if (targetPos < currentScroll){
			function stepDown() {
				newPos = newPos + diff
				// document.getElementById("flexiContainer").scrollTo(0, newPos)
				whichContainer.scrollTo(0, newPos)
				if (whichContainer == $id("dialogpanelcontent")) updateDialogPanelOnScroll()

				if (newPos > targetPos) {
					mylog("animating DOWN")
					window.requestAnimationFrame(stepDown)
				}
			}
			window.requestAnimationFrame(stepDown)
		}
	
	if (whichContainer == $id("dialogpanelcontent")) setTimeout(function(){updateDialogPanelOnScroll()},0)
	mylog("scrollNicely is now done")
}

function __________ALERTS_AND_LOGS(){}

function alertThis(first, second){
	Beat.call("Beat.alert(`" + first + "`, `" + second + "`)")
}

function toggleConsole(){

	loggingIsOn = !loggingIsOn
	if($id("buttonForLogging")){$id("buttonForLogging").checked = loggingIsOn}

	flexiContainer.classList.toggle("loggingIsOn", loggingIsOn)

	if(loggingIsOn){Beat.call("Beat.openConsole()")}
	if(!loggingIsOn){firstRun()}

}

var anErrorHasOccured = false

// function mylog(text, noError, important, sameline){
function mylog(abstext, isError){

	if (anErrorHasOccured) return //don't log any more entries after the offending one

	text = JSON.parse(JSON.stringify(mylog.caller.name))
	text += abstext ? (":     " + abstext) : ""

	//this is a real time suck, so keep this off at all times if possible!
	if(loggingIsOn){
		// let log = "Beat.log(`" + text + "`)"
		// 	Beat.call(log)
			console.log(text)
	}

	//saving to the crashlog
		logArray.push(new Date().toLocaleString('sv-SE', { timeZone: 'Europe/Stockholm' }) + "." + new Date().getMilliseconds().toString().padStart(3, '0') + " -- " + text)
		while (logArray.length > 100){logArray.shift()}

		if(!isError){return}

	//The rest is when an error has indeed happened!

		anErrorHasOccured = true

		logArray = logArray.reverse() //so as to get offending command at the top, thankyouverymuch
		
		logArray.push(" ")
		logArray.push("____________________________________________________________")
		logArray.push(" ")
		logArray.push("flexiContainerclassList:")
		logArray.push(" ")
		logArray.push(Array.from(flexiContainer.classList).join("\n"))
		logArray.push(" ")
		logArray.push("____________________________________________________________")
		logArray.push(" ")
		logArray.push("Document Settings:")
		logArray.push(" ")
		for (var property in documentSetting) {
			if(["documentName", "documentSubName", "documentAuthor"].includes(property)){continue} //don't send user-related info
			logArray.push(property + ": " + documentSetting[property])
		}
		logArray.push("____________________________________________________________")
		logArray.push(" ")
		logArray.push("User Defaults:")
		logArray.push(" ")
		for (var property in userDefault) {
  			logArray.push(property + ": " + userDefault[property])
		}

		displayErrorMessage(logArray)


		console.log("🔴🔴🔴 FTOutliner had an error. Below is the stack trace:")
			(JSON.parse(JSON.stringify(logArray)))
		Beat.log("🔴🔴🔴 FTOutliner had an error. Below is the stack trace:")
		Beat.log(logArray.join("\n"))


}

</script>

	</body>
</html>
