<style>

#tracking * {

    line-height: 16px !important;
    white-space: normal;
}

#tracking *:focus{
    outline: none !important;
}

html[data-outdoors='1'] #flexiContainer .dimmedScene,
html[data-outdoors='1'] #flexiContainer.indexcards .dimmedScene > .sceneheading {

    border-color: #ddd !important;
    border-style: dotted !important;

}

html[data-outdoors='1'] #flexiContainer .dimmedScene > .sceneheading{

    color: #ddd !important;

}

#characterButton:is(.red, .orange, .yellow, .green, .teal, .cyan, .blue, .purple, .magenta, .pink, .brown, .grey, .black, .white) {
    background: none !important;
    opacity: 1 !important;
    transition: none !important;
}

#characterButton.red > svg path{
    fill: hsla(var(--red),100%) !important;
}
#characterButton.orange > svg path{
    fill: hsla(var(--orange),100%) !important;
}
#characterButton.yellow > svg path{
    fill: hsla(var(--yellow),100%) !important;
}
#characterButton.green > svg path{
    fill: hsla(var(--green),100%) !important;
}
#characterButton.teal > svg path{
    fill: hsla(var(--teal),100%) !important;
}
#characterButton.cyan > svg path{
    fill: hsla(var(--cyan),100%) !important;
}
#characterButton.blue > svg path{
    fill: hsla(var(--blue),100%) !important;
}
#characterButton.purple > svg path{
    fill: hsla(var(--purple),100%) !important;
}
#characterButton.magenta > svg path{
    fill: hsla(var(--magenta),100%) !important;
}
#characterButton.pink > svg path{
    fill: hsla(var(--pink),100%) !important;
}
#characterButton.brown > svg path{
    fill: hsla(var(--brown),100%) !important;
}
#characterButton.black > svg path{
    fill: hsla(var(--black),100%) !important;
}
#characterButton.white > svg path{
    fill: hsla(var(--white),100%) !important;
}
#characterButton.grey > svg path{
    fill: hsla(var(--grey),100%) !important;
}

.section:not(.level1).dimmedSection:hover>.section-heading:not(#flexiContainer.sectionCards .section-heading){
    background-color: rgba(40,40,40,1) !important;
}

.rightfloat{
    float: right;
    width: 50% !important;
    height: 100% !important; 
    padding-right: 0px !important;
}

#tracking button {
    text-align: right;
}

.buttonIsActive {
    opacity: 100% !important;
}

svg {
    transition: 0.2s !important;
    pointer-events: none; /* Or else the icon blocks itself from being clicked. Very weird. */
}

.buttonIsActive svg {
    transform: scale(0.7) translateY(2px) !important;
    pointer-events: none; /* Or else the icon blocks itself from being clicked. Very weird. */

}

#indexCardButton.buttonIsActive svg {
    transform: scale(1) translate(0px, 0px) !important;
}

.bullets {
    margin-left: 20px;
}

.bullets::before{
    content: "•";
    margin-left: -20px;
}

#upperframe, #trackingoutro{
    max-width: 560px;
    margin-left: auto;
	margin-right: auto;
}

#selectedCharacterName, #indexCardText{
    font-size: 9px;
    font-weight: 500;
    line-height: 10px;
    text-transform: uppercase;
    transform: translateY(calc(-100% - 23px)) translateX(calc(-50% + 16px));
    width: 60px !important;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none; /* Or else the icon blocks itself from being clicked. Very weird. */
}

#indexCardText{
    transform: translateY(calc(-100% - 29px)) translateX(calc(-50% + 16px));

}

#indexCardBkg{
    padding-left: 50px !important;
    padding-top: 3px !important;
    font-size: 9px;
    font-weight: 500;
    line-height: 12px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.4)

}

/*@todo remmed out all these SELECT stuffs*/

#selectlistparent{

    width: 50% ;
}

select, select * {
    
    height: 100% !important;
    width: 100% !important;
    border-radius: 6px !important;
    border: 1px inset;

    overflow-y: scroll;
    overflow-x: hidden;

    font-size: 14px !important;
	line-height: 18px !important;
	font-weight: 500;

    padding: 10px !important;

    list-style-position: outside;
    
}

#tracking select {

    min-height: 500px;

}

option {
    line-height: 20px !important;
    width: 100% !important;
    padding: 4px !important;
}

option:nth-of-type(even){
    background: #eee;

}

option:checked{
    background: #027aff !important;
    background-color: #027aff !important;
    border: 1px gold dotted
}

#tracking .normalWindowText{
    width: 50%;
    float: left;
    padding-right: 15px !important;
}

.normalWindowText li {
    list-style-position: outside !important;
}

ul {
    margin-left: -20px;
}

li {
    margin-top: 6px !important;
    display: list-item;
    list-style-position: outside !important;
}

#okbutton2, #deselectAllCharacters {
	font-size: 14px; 
    margin-top: 15px; 
    margin-bottom: 15px !important;
	padding: 5px 0px 5px auto;
}

.scriptTextInWindow {
    font-family:'Courier Prime','Courier New', Courier, monospace; 
    font-size: 13.5px !important;
    font-weight: bold;
    letter-spacing: -0.3px;
    padding-bottom: 0px !important;
    padding-top: 1px !important;
    line-height: 16px !important;
}

/* html[data-outdoors='1'] #flexiContainer .section.dimmedSection{

    color: purple
    
} */

html[data-outdoors='1'] .dimmedSection > .section-heading:not(#flexiContainer.indexCards .section-heading),
html[data-outdoors='1'] #flexiContainer .dimmedSection > .section-heading {

    color: #ddd !important;
    opacity: 1;
    border: 1px dotted #ddd !important;
    
}

</style>

<div id="tracking" class="settingsWindow" style="display: none;" onblur="toggleTrackingContainer()">
   
    <div id="selectlistparent" class="rightfloat" style="height: calc(100% - 40px) !important; text-align: right !important;">
    <select style="height: 100% !important;" multiple onchange="updateFilter()" id="characterMenuList"></select><br/>
    
    <button class="generalButtonStyle" id="deselectAllCharacters" onclick="deselectAllCharacters()">Deselect all</button>
        <!--p id="okbuttonpara2"-->
        <button class="generalButtonStyle" id="okbutton2" type="button" onclick="toggleTrackingContainer()">Close</button><!--/p-->

    </div>

    <div  id="trackertext"><p class="normalWindowText"><span class="headline"><br/>Track characters</span><br/><br/>

        Select characters in the list to highlight scenes where they appear.<br/><br/>
        CMD + click to select multiple.<br/><br/> 
        Selecting more than one name will highlight scenes where ALL characters are present.<br/><br/>
        
        
    </p>
    </div>
    
</div>

<script>

var iCameFromToggleCharacter = false
var iCameFromMenu = false
var scenesWithCharacters = []
var searchBoxDelay

var globalScenesWithDialog = []


function collectCharacters(preselectedCharacter) {

    // important note: when this was part of the plugin back-and-forth, the plugin ended this by calling updateFilter()
    // since I do not call updateFilter from the end of this function, be vigilant about whether this may case problems
    // (and no, I don't dare calling updateFilter from here, in case this function should be able to be called without)

    mylog()
    console.time("collectCharacters2023")

    if(!outline) return

    let removal = userDefault.excludeVoiceOvers ? /(\(.+\))$/ : ""
    let allCharacters2023 = lines.filter(line => line.typeAsString == "Character" && !line.omitted).map(line => 
        line.string.replace(/^\^*@*/, "")   /* removes dual dialog ^ or forced dialog @ */
        .replace(/\'/g, `’`)                /* replaces that pesky apostrophe that creates so much problems */
        .replace(removal, "").trim())       /* if characters with extensions count as the main character, remove the extension */ 

    //sort the characters by how many times they appear in the script
        const characterCounts = allCharacters2023.reduce((acc, val) => {
            if (!acc[val]) {
                acc[val] = 1;
            } else {
                acc[val]++;
            }
            return acc;
            }, []);

        const sortedCharacters = Object.keys(characterCounts).sort((a, b) => {
            return characterCounts[b] - characterCounts[a];
        });

    //collect all characters in each scene, with different options
        let outlineElementsWithCharactersDialogOnly = []
        let outlineElementsWithCharactersIncludingAction = []
        let outlineElementsWithCharactersInSynopsisOnly = []
        let scenesWithDialog2023 = []

        let outlineElementNumber = -1
        let trimmedName
        let wordsplitters = /[,.:;!?\)\(\s\")]+/ //for now, I have removed apostrophes \' from wordsplitters to catch names like O'Neil
        for (line of lines){

            //if (line.omitted) continue

            if (line.typeAsString == "Heading" || line.typeAsString == "Section"){
                outlineElementNumber ++
                outlineElementsWithCharactersDialogOnly[outlineElementNumber] = []
                outlineElementsWithCharactersIncludingAction[outlineElementNumber] = []
                outlineElementsWithCharactersInSynopsisOnly[outlineElementNumber] = []
                scenesWithDialog2023[outlineElementNumber] = []
            }
            
            if (line.typeAsString == "Character" && !line.omitted){
                trimmedName = line.string.replace(/^@/, "").toUpperCase().replace(removal, "").replace(/\'/, "’").trim() 
                if(sortedCharacters.some(character => character.toUpperCase() == trimmedName.toUpperCase())){
                    if (!outlineElementsWithCharactersDialogOnly[outlineElementNumber]?.includes(trimmedName)) {
                        outlineElementsWithCharactersDialogOnly[outlineElementNumber].push(trimmedName)
                    }
                    if (!outlineElementsWithCharactersIncludingAction[outlineElementNumber]?.includes(trimmedName)) {
                        outlineElementsWithCharactersIncludingAction[outlineElementNumber].push(trimmedName)
                    }
                }
                alsoCollectDialog()
            }
            if (line.typeAsString == "Action" && !line.omitted){
                sortedCharacters.forEach(character => {
                    apostrophedCharacter = character.replace(/’/g, `\'`) //replacing character BACK to normal apostrophe when comparing to avoid repeating for every word
                    if (compareThese(line.string, apostrophedCharacter)) { 
                        if (!outlineElementsWithCharactersIncludingAction[outlineElementNumber]?.includes(character)) {
                            outlineElementsWithCharactersIncludingAction[outlineElementNumber].push(character.toUpperCase());
                        }
                    }
                })
            }
            if (documentSetting.trackingIncludesSynopsis && line.typeAsString == "Synopse"){
                sortedCharacters.forEach(character => {
                    apostrophedCharacter = character.replace(/’/g, `\'`) //replacing character BACK to normal apostrophe when comparing to avoid repeating for every word
                    if (compareThese(line.string, apostrophedCharacter)) { 
                        if (!outlineElementsWithCharactersInSynopsisOnly[outlineElementNumber]?.includes(character)) {
                            outlineElementsWithCharactersInSynopsisOnly[outlineElementNumber].push(character);
                        }
                    }
                })
            }
        }

        function alsoCollectDialog(){

            if (!($id("notepanel").classList.contains("expanded") && $(".selectedtab").classList.contains("dialogtab"))) return

            let additionalLines = 0
            let currentLine = lines.indexOf(line)
        
            while (["Character", "Dialogue", "Parenthetical"].includes(lines[currentLine + additionalLines]?.typeAsString)){

                scenesWithDialog2023[outlineElementNumber].push({
                    "character": trimmedName,
                    "position": lines[currentLine + additionalLines].position,
					"string": lines[currentLine + additionalLines].string, 
					"typeAsString": lines[currentLine + additionalLines].typeAsString,
					"omitted": lines[currentLine + additionalLines].omitted,
					"currentLine": lines[currentLine + additionalLines],
                })
                additionalLines ++
            }
        }

        function compareThese(string, character){

            if (!string.toLowerCase().includes(character.toLowerCase())) return false //to avoid having to loop through all words if not even present

            // FIRST, if the character has multiple words, let not split the line but compare directly. 
            // This will demand at least one uppercase letter in the match (to avoid matching "OLD BROWN" with "his old brown hat")
            // which unfortunately means not matching "the third thug" in action with a speaking character "THE THIRD THUG"
            // This seems like a reasonable trade-off for now, and will catch "Dr. Zjivago" and "Sheila's mother", both of which are more important.
            if (character.includes(" ")){
                // if (string.toLowerCase().includes(character.toLowerCase)) return true
                const regex = new RegExp(character, 'i');
                const match = string.match(regex);
                    if (match && match[0] != match[0].toLowerCase()) {
                    return true;
                    }
            } 

            //THEN, more time-consuming word-by-word comparisons for single-word characters
            
            let words = string.split(wordsplitters)

            if (words.includes(character)) return true //spelling is exactly as once captured (text: McLaren, original: @McLaren)
            if (words.includes(toInitialsCase(character))) return true //spelling is like a name, regardless of case when captured. (text: Mclaren)
            if (words.includes(character.toUpperCase())) return true //character is typed in caps now but perhaps not when captured (text: MCLAREN)

            //Below is a test to see if we can also get McLaren as well as McLAREN, and if so at what cost?
            if (words.some(word => (word.charAt(0) + word.slice(1).toLowerCase()) === (character.charAt(0) + character.slice(1).toLowerCase()))) return true;

            return false
        }

    //Finally, here's an array with characters in both action AND synopsis
    let outlineElementsWithChactersAnywhere = 
        outlineElementsWithCharactersIncludingAction.map((characters, index) => 
            characters.concat(outlineElementsWithCharactersInSynopsisOnly[index])
        )

    console.timeEnd("collectCharacters2023")

    //For now, in order to be able to use old code, let's merge this into the old variable names! Aug 2023

        allCharacters = sortedCharacters
        globalAllCharacters = allCharacters
        scenesWithCharactersProxy = 
            // documentSetting.trackingIncludesSynopsis ? outlineElementsWithCharactersInSynopsisOnly : outlineElementsWithCharactersIncludingAction
            documentSetting.trackingIncludesSynopsis ? outlineElementsWithChactersAnywhere : outlineElementsWithCharactersIncludingAction

    //Here's the old code:
    //from here, we should potentially make it a new function called applycharactes

    if ((!scenesWithCharacters.length) || (scenesWithCharacters != scenesWithCharactersProxy)){

        let previouslySelectedCharacters = Array.of(preselectedCharacter) || null
        let reselectThese = []

        let itemNumber = 0
        scenesWithCharacters = scenesWithCharactersProxy //workaround to make this globally accessible

        //remember what characters in the menu were selected before
            if ($id("characterMenuList").selectedOptions){        
                previouslySelectedCharacters = Array.from($id("characterMenuList").selectedOptions)
                for (character of previouslySelectedCharacters){
                    reselectThese.push(character.value)
                }
            }

        //populating/re-populating the character menu and track dialog menu (in case something changed)
            $id("characterMenuList").innerHTML = "" 
            $id("allDialogFor").innerHTML = "<option class='menuitem' value='ALL'>ALL</option>" 

            for (item of allCharacters){
                
                itemNumber ++

                $id("characterMenuList").innerHTML += 
                    `<option class='menuitem' value='${item}'>
                        ${itemNumber<10 ? `(${itemNumber})  ` : `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`}
                        ${item}
                    </option>`

                $id("allDialogFor").innerHTML += `
                    <option class='menuitem' value="${item}">
                        ${item}
                    </option>`
            }

        //and reselect those we remembered previously
            if (reselectThese.length){
                for (character of reselectThese){
                    for (i = 0; i < characterMenuList.length; i++){
                        if (characterMenuList[i].value == character){
                            characterMenuList.options[i].selected = true;
                        }
                    }
                }
            }
    }

    if (iCameFromToggleCharacter && allCharacters.length > 0){
        toggleSoloCharacter(iCameFromToggleCharacter[0], iCameFromToggleCharacter[1])
    }

    if (iCameFromMenu){
        iCameFromMenu = false
        trackingMenu()
    }

    if(trackingContainerVisibility == 1){
        document.getElementById("characterMenuList").focus()
    }

    mylog("end of collect")

    // FINALLY, added for 2023 version:
    // make the dialog global so as to be available for the dialogpanel
        globalScenesWithDialog = scenesWithDialog2023

}

function alsoFillColorDropdown(){

    let dropdown = "<option>(None)</option>"
    let alreadySelected = false

    for (let color of colorsArray){
        if (color == "Remove Color" || color == "Special"){continue}

        if ($(".scene." + color.toLowerCase() + ", .section." + color.toLowerCase())){
            dropdown += "<option>" + color + "</option>"

            if ([...document.getElementById("flexiContainer").classList].includes(color.toLowerCase())){
                alreadySelected = color
            }
        }
    }

    document.getElementById("colorDropdown").innerHTML = dropdown   
    document.getElementById("colorDropdown").value = alreadySelected || "(None)"

}

function updateFilter(scenesWithCharactersProxy){

    mylog()    

    let allScenes = $$('.scene')
    let allSections = $$('.section')

    //if (scenesWithCharactersProxy) {scenesWithCharacters = scenesWithCharactersProxy} //again making it global

    let selectedCharacters = $id("characterMenuList").selectedOptions

    if (selectedCharacters.length){

        for (section of allSections){section.classList.add("dimmedSection")}
        for (scene of allScenes){scene.classList.add("dimmedScene")}
        
            for (i=0; i<outline.length; i++){
                //if (outline[i].typeAsString == "Heading" || outline[i].typeAsString == "Section"){
                    let num = i

                    let removeDim = false
                    if (scenesWithCharacters[num]){

                        
                        removeDim = true
                        for (currentCharacter of selectedCharacters){

                            if (!scenesWithCharacters[num].includes(currentCharacter.value.toUpperCase())) {
                            removeDim = false
                            }
                        }
                    }

                    if (removeDim == true){$id(i).classList.remove("dimmedScene")}
                    if (removeDim == true){$id(i).classList.remove("dimmedSection")}

                //}
            }
    }
    else
    {
        for (scene of allScenes){scene.classList.remove("dimmedScene")}
        for (section of allSections){section.classList.remove("dimmedSection")}
    }

    mylog("dimming is done")

    if (characterMenuList.selectedIndex == -1){
        document.getElementById("characterButton").classList.remove("buttonIsActive")
        document.getElementById("selectedCharacterName").innerHTML = ""
    }else{
        document.getElementById("characterButton").classList.add("buttonIsActive")

        let selectedCharacters = document.getElementById("characterMenuList").selectedOptions
        document.getElementById("selectedCharacterName").innerHTML = ""
        for (currentCharacter of selectedCharacters){
            document.getElementById("selectedCharacterName").innerHTML += currentCharacter.value + "<br/>"
        }
    }

    updateSelectionInfo()
    mylog("end of UpdateFilter")
}

function deselectAllCharacters() {
    characterMenuList.selectedIndex = -1; 
    if($id("trackingMenu")){trackingMenu()}
    updateFilter()
}

function toggleSoloCharacter(theKey, actualName) {
    mylog()
    mylog("theKey is " + theKey + "")

    if (!characterMenuList || characterMenuList.length == 0) {

        iCameFromToggleCharacter = [theKey, actualName]
        
        collectCharacters()
        return
    }

    if(actualName){

        for (theKey = 0; theKey < characterMenuList.length; theKey ++) {
            
            if (actualName.toUpperCase() == characterMenuList.options[theKey].value.toUpperCase()){
                theKey ++ //because soon to be reduced by one in the old code
                break
            }
        }
    }

    theKey -- //shifts one down to zero-based array, but shortcuts starting with 1

    if (event && (event.shiftKey || event.metaKey)){
        let a = characterMenuList.options[theKey].selected == false;
        characterMenuList.options[theKey].selected = a;
    }
    else
    {
        if (characterMenuList.selectedIndex != theKey){
            characterMenuList.selectedIndex = theKey 
            }else{
            characterMenuList.selectedIndex = -1; 
        }
    }
    iCameFromToggleCharacter = false

    mylog("exiting, just before sending to updateFilter()")

    if($id("trackingMenu")){trackingMenu()}
    updateFilter()
}

function simulateAltClick(){

    let theSelections = document.getElementById("colorDropdown").selectedOptions
    let theSelection = theSelections[0].value
    
    if ($id("flexiContainer").classList.contains("uncolorAllScenesBut")){
        muteColors()    
    } //i.e. if already on, this toggles it off before selecting new color

    if (theSelection != "(None)"){ //do not toggle on if user chose "none"
        muteColors($(`.scene.${theSelection.toLowerCase()}, .section.${theSelection.toLowerCase()}`))
    }

    deselectAllElements()

}


function muteColors(theClickedThing, shift){

    mylog(theClickedThing?.classList)
    // alertThis(theClickedThing.classList)
    
    if (!shift && $id("flexiContainer").classList.contains("uncolorAllScenesBut")){
        $id("flexiContainer").classList.remove("uncolorAllScenesBut")
        for (let color of colorsArray){
            if($id("flexiContainer").classList.contains(color.toLowerCase())){
                $id("flexiContainer").classList.remove(color.toLowerCase())
                $id("characterButton").classList.remove(color.toLowerCase())
            }
        }
        updateSelectionInfo()
        return
    }

    if(!theClickedThing || !theClickedThing.closest(".synopsis, .scene, .section")){
        mylog("returning bc no closest scene or section")
        return
    }
    
    $id("flexiContainer").classList.add("uncolorAllScenesBut")
    theClickedThing = theClickedThing.closest(".synopsis, .scene, .section")

    let foundOne = false

    for (let color of colorsArray){
        if(theClickedThing.classList.contains(color.toLowerCase())){
            document.getElementById("flexiContainer").classList.add(color.toLowerCase())
            document.getElementById("characterButton").classList.add(color.toLowerCase())
            foundOne = true
            break
        }
    }

    if (!foundOne && theClickedThing.classList.contains("synopsis")){
        
        theClickedThing = theClickedThing.closest(".scene, .section")
        muteColors(theClickedThing, true)
    }
    
    deselectAllElements()
    updateSelectionInfo()
}

function _____________(){}

function initiateCharacterBubbles(characterName = "ALL"){

    collectCharacters(characterName)

    //$id("allDialogFor").selectedIndex = 0

    showCharacterBubbles(characterName)

}

function unShowCharacterBubbles(){

    $$(".sceneChunk").forEach( chunk => { chunk.remove() }) 
    $$(".connectorcontainer").forEach( connector => { connector.remove() })
    $$(".displayNumberOf").forEach( numberof => { numberof.remove() })

    if(!$id("dialogsearch")?.value) {deselectAllCharacters()} //avoid blinkage: don't remove "dimmedScene" if filtering underway

    $$(".scene .orphan").forEach(element => {
        element.removeEventListener("mouseenter", function(){
            selectSceneChunk($id("dialogIn" + element.id)?.closest(".sceneChunk"))
            scrollNicelyIntoView($id("dialogIn" + element.id), $id("dialogpanelcontent"))
        })
    })

}

function selectSceneChunk(sceneChunk){

    if(!sceneChunk) return

    $$(".selectedSceneChunk").forEach(sceneChunk => {sceneChunk.classList.remove("selectedSceneChunk")})
    sceneChunk.classList.add("selectedSceneChunk")

}


function cycleBubbles(direction){ //send here: -1 or +1

    if(!$("#notepanel.expanded .dialogtab.selectedtab")){cycleTabs($(".dialogtab"))}

    let allChunks = Array.from($$(".dialogChunk"))
    if(!allChunks || allChunks.length == 0) {
        initiateCharacterBubbles()
        return
    }
    
    let selectedNumber = allChunks.indexOf($(".dialogChunk.selectedDialog"))
    if(selectedNumber < 0) return //no, make it current?
    
    selectedNumber += Number(direction)
    
    if (selectedNumber > allChunks.length - 1) selectedNumber = 0
    if (selectedNumber < 0) selectedNumber = allChunks.length - 1

    selectThisDialog(allChunks[selectedNumber].id, true) //if not true, no scroll

}

function selectThisDialog(dlgId, andScroll = false){

    let currentChunk = $(".hoveredSceneChunk")

    $$(".selectedDialog")?.forEach(element => {element.classList.remove("selectedDialog")})
    $$(".isHovered")?.forEach(element => {element.classList.remove("isHovered")})
    $$(".hoveredSceneChunk")?.forEach(chunk =>{chunk.classList.remove("hoveredSceneChunk")})

    $id(dlgId)?.classList.add("selectedDialog")
    $id(dlgId)?.closest(".sceneChunk").classList.add("isHovered")
    $id(dlgId)?.closest(".sceneChunk").classList.add("hoveredSceneChunk")
    
    $id($id(dlgId)?.closest(".sceneChunk").dataset.parentId)?.classList.add("isHovered")

    if($(".hoveredSceneChunk") != currentChunk) {
        createOrUpdateConnectorFor($(".hoveredSceneChunk"))
    }

    if(andScroll) { scrollNicelyIntoView($id(dlgId) || $(".hasCursor"), $id("dialogpanelcontent")) }

}



function updateDialogPanel(scenesWithDialog){

    if (!($id("notepanel").classList.contains("expanded") && $(".selectedtab")?.classList.contains("dialogtab"))){ return }

    let alreadySelected = $id("allDialogFor").selectedOptions[0]?.innerText.trim() || "ALL"

    collectCharacters()
    showCharacterBubbles(alreadySelected, true)
    updateDialogPanelSelection()

}

function showCharacterBubbles(characterName, redraw){

    mylog()

    console.time("bubbles")

    // re-select already selected character!
        if(characterName){
            $id("allDialogFor").selectedIndex = ([...$id("allDialogFor").options].map(option => option.value.toUpperCase())).indexOf(characterName) || 0
        }else{
            characterName = $id("allDialogFor").selectedOptions[0]?.innerText.trim() || "ALL"
        }
    
    let scrolledAmountBeforeRedraw = $id("dialogpanelcontent").scrollTop
    let allChunks = $$(".sceneChunk")
    
    //when chunks already present, clean up before doing anything else:
        if(allChunks.length > 0){  
            unShowCharacterBubbles()
        }

    //if no character is selected, loop all dialog, otherwise only loop dialog for selected character
        let selectedScenesWithDialog = characterName == "ALL" ? globalScenesWithDialog : globalScenesWithDialog.map(scene => scene.filter(line => line.character == characterName))
    
    for (let scene of selectedScenesWithDialog){

        let theId = selectedScenesWithDialog.indexOf(scene)
            
        // This PROBABLY helps against a bug PROBABLY caused by the scenes being updated from the plugin while this loop is running
            if(!$id(theId)) break 

        let orphanId
            if($id(theId)?.classList.contains("section")){
                orphanId = $id(theId).querySelector(".orphanText")?.id
            }

        if (scene.length == 0) continue

        let chunk = document.createElement("div")
            
            chunk.id = "dialogIn" + theId
            chunk.dataset.orphanId = orphanId
            chunk.dataset.parentId = theId
            chunk.style.color = $id(theId).querySelector(".sceneheading").style.color
            chunk.style.marginBottom = "3px"
            chunk.dataset.charactername = characterName
                chunk.onmouseenter = function(){
                    $id(chunk.dataset.parentId).classList.add('isHovered')
                    createOrUpdateConnectorFor(chunk) 
                }
                chunk.onmouseleave = function(){
                    $id(chunk.dataset.parentId).classList.remove('isHovered')
                    $$(".connector").forEach(connector => {connector.remove()})
                }
            chunk.classList.add("sceneChunk")
            chunk.style.width = "100%"
            if (outline[theId].omitted) chunk.classList.add("omitted")

            chunk.innerHTML = `<p class="chunkHeading"><span style="opacity: 0.4;">${(outline[theId].sceneNumber || "")} </span>&nbsp;${outline[theId].stringForDisplay}</p>`

            let createdChunks = []
            let chunkNumber = -1

            for (line of scene){

                
                if (line.typeAsString == "Character"){

                    chunkNumber ++

                    createdChunks[chunkNumber] = document.createElement("div")
                    createdChunks[chunkNumber].classList.add("dialogChunk")
                    createdChunks[chunkNumber].id = "dialog" + line.position
                    createdChunks[chunkNumber].dataset.line = line.position
                    createdChunks[chunkNumber].onclick = function(){selectThisDialog("dialog" + line.position)}

                    //continue
                }

                let omittedString = ""
                if(line.omitted) omittedString = " omitted"



                createdChunks[chunkNumber].innerHTML += `<p class="${line.typeAsString.toLowerCase()} ${omittedString}" data-line="${line.position}" data-end-pos="${line.position + line.string.length}" data-length="${line.string.length}"><span class="debug">${line.position}-${line.position + line.string.length}</span>${line.string}</p>`

                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\/\*(.*)\*\//g, "<span class='omitted'>$1</span>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\*\*\*(.*)\*\*\*/g, "<b><i>$1</i></b>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\*\*(.*)\*\*/g, "<b>$1</b>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\*(.*)\*/g, "<i>$1</i>")
                createdChunks[chunkNumber].innerHTML = createdChunks[chunkNumber].innerHTML.replace(/\_(.*)\_/g, "<u>$1</u>")

                //hack to update the endPos of the chunk for as long as we keep adding to it
                    createdChunks[chunkNumber].dataset.endPos = line.position + line.string.length
                    createdChunks[chunkNumber].querySelector(".debug").innerText = createdChunks[chunkNumber].dataset.line + "-" + createdChunks[chunkNumber].dataset.endPos
                
            }

            for (createdChunk of createdChunks){

                chunk.appendChild(createdChunk)

            }

            chunk.dataset.startPos = chunk.firstChild.data-line
            chunk.dataset.endPos = chunk.lastChild.data-line + chunk.lastChild.innerText.length

            //and the sceneChunk to the sidepanel:          
                $id("dialogpanelcontent").appendChild(chunk)

            if($id("dialogsearch").value) chunk.classList.add("displayNone")
                //chunkSizes = chunk.getBoundingClientRect()

        //add number of dialogs to corresponding scene

            let displayNumberOf = document.createElement("div")

            $id(orphanId || theId).appendChild(displayNumberOf)

                displayNumberOf.id = "displayNumberOf" + theId //chunk.id
                displayNumberOf.dataset.parentId = theId
                displayNumberOf.classList.add("displayNumberOf")
                displayNumberOf.classList.add("dontDim")
                displayNumberOf.style.position = "absolute"
                displayNumberOf.style.top = "50%"
                displayNumberOf.style.left = "50%"
                
                displayNumberOf.textContent = chunk.querySelectorAll(".dialogChunk").length

                displayNumberOf.onmouseenter = onmouseenterForDNO                
                    function onmouseenterForDNO(){
                        $id("dialogIn" + theId).classList.add("hoveredSceneChunk") 
                    }

                displayNumberOf.onmouseleave = onmouseleaveForDNO                
                    function onmouseleaveForDNO(){
                        $id("dialogIn" + theId).classList.remove("hoveredSceneChunk") 
                    }
                displayNumberOf.onclick = onclickForDNO                
                    function onclickForDNO(){
                        selectSceneChunk(chunk)
                        scrollNicelyIntoView(chunk.querySelector(".dialogChunk") || chunk, $id("dialogpanelcontent"))
                    }

        //must set color after "displaynumberof", or else getcomputedstyle delivers blank    
            chunk.style.setProperty("--localColor", window.getComputedStyle($id(theId)).backgroundColor)
            chunk.style.backgroundColor = "var(--localColor)"

    }

    $id("dialogpanelcontent").scrollTo({
        top: scrolledAmountBeforeRedraw,
        left: 0,
        behavior: 'instant'
        });

    $id("dialogpanelcontent").onscroll = function(){ updateDialogPanelOnScroll() }
    if($id("dialogsearch").value) onlyShowMatchingDialogs(true)

    console.timeEnd("bubbles")

}

function updateDialogPanelSelection(){

    if (!($id("notepanel").classList.contains("expanded") && $(".selectedtab")?.classList.contains("dialogtab"))){ return }

    let cursorPosition = Number($id("youAreHere").dataset.location)

    $$(".selectedDialog")?.forEach(element => {element.classList.remove("selectedDialog")})
    $$(".dialogChunk")?.forEach(element => {element.classList.remove("hasCursor")})

    let bestMatch = Array.from($$(".dialogChunk")).find(element => Number(element.dataset.line) <= cursorPosition && Number(element.dataset.endPos) >= cursorPosition)
    let bestMatchClosestChunk = bestMatch?.closest(".dialogChunk")
        //console.log(cursorPosition, bestMatch?.dataset.line, bestMatch?.dataset.endPos, bestMatchClosestChunk?.textContent)
        bestMatchClosestChunk?.classList.add("selectedDialog", "hasCursor")

    scrollNicelyIntoView($(".hasCursor"), $id("dialogpanelcontent"))

}

function updateDialogPanelOnScroll(){

    let hoveredChunk = $(".sceneChunk.hoveredSceneChunk, .sceneChunk:hover")

    let elementSizes = hoveredChunk?.querySelector(".chunkHeading").getBoundingClientRect()
        if(elementSizes && $id("connector")){
            let chunkCorner = Math.min(Math.max((elementSizes.top + elementSizes.height/2), $id("dialogpanelcontent").getBoundingClientRect().top), $id("dialogpanelcontent").getBoundingClientRect().bottom)

            $id("connector")?.style.setProperty("--chunkCorner", chunkCorner + "px")
            $id("connector")?.style.setProperty("--containerHeight", ($id("connectorcontainer").getBoundingClientRect().height) + "px")
        }

        if((elementSizes?.top < 0 || elementSizes?.top > $id("dialogpanelcontent").getBoundingClientRect().height) && $id("connector")) $id("connector").remove()

    $$(".chunkHeading").forEach(head =>{ head.classList.toggle("isStuck", head.offsetTop > 0) })

}

function createOrUpdateConnectorFor(element){

    if(!element) return

    let delay = ($id(element.closest(".sceneChunk").dataset.parentId).classList.contains("isOmitted")) ? 250 : 0

    setTimeout(() => {

        if(!$(".connectorcontainer")){

            let connectorcontainer = document.createElement("div")
                connectorcontainer.id = "connectorcontainer"
                connectorcontainer.classList.add("connectorcontainer")
                connectorcontainer.style.position = "absolute"
                connectorcontainer.style.top = "0px"
                connectorcontainer.style.left = "0px"
                connectorcontainer.style.right = "0px"
                connectorcontainer.style.bottom = "0px"
                connectorcontainer.style.pointerEvents = "none"
                connectorcontainer.style.zIndex = "99999"
            document.body.appendChild(connectorcontainer)
        }

        let connector = $id("connector") || document.createElement("div")
            
            // let elementSizes = element.getBoundingClientRect()
            let elementSizes = element.querySelector(".chunkHeading").getBoundingClientRect()
            let connectedScene = $id(element.closest(".sceneChunk").dataset.parentId)
                if (connectedScene.classList.contains("section")) connectedScene = connectedScene.querySelector(".section-heading")
            let connectedSceneSizes = /*connectedScene.querySelector(".sceneheading")?.getBoundingClientRect() ||*/ connectedScene.getBoundingClientRect()
            let nextSceneSizes = {top: 0}
            let nextVisibleScene
                if (window.getComputedStyle(connectedScene).display == "none"){
                    nextVisibleScene = connectedScene
                    while ($id(Number(nextVisibleScene.id) + 1) && window.getComputedStyle(nextVisibleScene).display == "none") {
                        nextVisibleScene = $id(Number(nextVisibleScene.id) + 1)
                    }
                    nextSceneSizes = nextVisibleScene?.getBoundingClientRect()
                }
                connectedScene.classList.add("isHovered")

                connector.id = "connector"
                connector.classList.add("connector")
                connector.dataset.parentId = element.closest(".sceneChunk").dataset.parentId
                
                connector.style.position = "absolute"
                connector.style.left = (elementSizes.right) + 3 + "px" //was 18
                connector.style.width = ((connectedSceneSizes.left || nextSceneSizes.left) - flexiContainer.getBoundingClientRect().left + 14) + "px"
                connector.style.setProperty("--maxHeightOfDot", Math.max(Math.min(connectedSceneSizes.height - 2, 8), 0.1) + "px")

                // let chunkCorner = (elementSizes.top + elementSizes.height/2)
                let chunkCorner = Math.min(Math.max((elementSizes.top + elementSizes.height/2), $id("dialogpanelcontent").getBoundingClientRect().top), $id("dialogpanelcontent").getBoundingClientRect().bottom)
                
                connector.style.setProperty("--chunkCorner", chunkCorner + "px")
                connector.style.setProperty("--sceneCorner", ((connectedSceneSizes.top + connectedSceneSizes.height/2) || nextSceneSizes.top) + 0 + "px")
                connector.style.setProperty("--containerHeight", (connectorcontainer.getBoundingClientRect().height) + "px")
                connector.style.setProperty("--localColor", connectedScene.style.getPropertyValue("--localColor") || window.getComputedStyle(connectedScene).backgroundColor)
                
                connector.setAttribute("viewBox", "-100 -100 1100 1100")

                connector.innerHTML = `<svg height="100%" width="100%" viewBox="0 0 1000 1000" preserveAspectRatio="none" vector-effect="non-scaling-stroke">
                    <g>
                        <!--circle class="bottomdot" cx="0" cy="0" r="8px" vector-effect="non-scaling-stroke" /-->
                        <path class="bottomstroke" stroke-dasharray="1,4" stroke-linecap="round" d="M0,0 C900,0 100,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                        <path class="topstroke" stroke-dasharray="1,4" stroke-linecap="round" d="M0,0 C900,0 100,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                    </g></svg>`

                if(!$id("connector")) connectorcontainer.appendChild(connector)

    }, delay)

}

function searchboxlisten(){

    mylog(event)

    let keypress = event.key

    if(keypress == "Escape"){
        event.preventDefault()
        event.stopPropagation()
        clearSearchBox()
    }

}

function clearSearchBox(){

    $id("dialogsearch").value = ""
    $id("allDialogFor").focus()
    onlyShowMatchingDialogs(true)
}

function onlyShowMatchingDialogs(nodelay){

    let delay = nodelay ? 0 : 500

    if(searchBoxDelay)clearTimeout(searchBoxDelay)
    searchBoxDelay = setTimeout(() => {

        let searchstring = $id("dialogsearch").value

        $$("#dialogpanelcontent :is(.sceneChunk, .dialogChunk)").forEach(dialog => {

            //remove non-searchable text such as debug numbers and character names
                dialog.querySelectorAll(".debug, .character, .parenthetical").forEach(debug => {debug.remove()})

            //and at last: remove the scene heading text from being evaluated!
                let textToEvaluate = Array.from(dialog.querySelectorAll(":not(.chunkHeading)")).map(element => element.innerText).join(" ")

            // dialog.classList.toggle("displayNone", !dialog.innerText.toLowerCase().includes(searchstring.toLowerCase())) 
                dialog.classList.toggle("displayNone", !textToEvaluate.toLowerCase().includes(searchstring.toLowerCase())) 
                $id(dialog.closest(".sceneChunk").dataset.parentId).classList.toggle("dimmedScene", dialog.closest(".sceneChunk").classList.contains("displayNone"))
        })

        $$("#dialogpanelcontent :is(.dialogChunk:not(.displayNone)) p").forEach(dialog => {
            
            //remove old match
            dialog.innerHTML = dialog.innerHTML.replace(/\<span class\=\"searchFound\"\>(.*?)\<\/span\>/g, "$1")

            //add new match
                if(searchstring.length > 0) {

                    //split the dialog.innerHTML into two, the chunkheading and the rest
                    dialogHeader = dialog.querySelector(".chunkHeading")?.outerHTML

                    const text = dialog.textContent;
                    const regex = new RegExp(`(${searchstring})`, 'gi');
                    const matches = text.match(regex) || [];

                    if (matches.length) {
                        const newHTML = text.replace(regex, `<span class="searchFound">$1</span>`);
                        dialog.innerHTML = newHTML;
                    }
                }                
        })

        $$(".connector").forEach(connector => {connector.remove()})

        let provokeRedraw = $id("dialogpanelcontent").getBoundingClientRect()
            
    }, delay);

}

function __________HELPERS__________(){} 

function toCamelCase(string){

    let words = string.split(" ")
    let camelCase = words[0].toLowerCase()

    for (let i = 1; i < words.length; i++){
        camelCase += words[i].charAt(0).toUpperCase() + words[i].slice(1).toLowerCase()
    }

    return camelCase
}

function toInitialsCase(string){

    let words = string.split(" ")
    let output = ""

    for (word of words){
        output += " " + word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    }

    return output.trim()
}

</script>

<style>

    .searchFound{

        background: yellow;
        border: 0px solid yellow;
        border-top-width: 3px;
        border-bottom-width: 1px;
        box-shadow: 0px 0px 0px 1px hsl(60, 100%, 40%);

        white-space: inherit;
        z-index: -99;

    }

    .displayNone{

        display: none !important;

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .section:not(.dontDim, .level1, .special) > .section-heading{     */
    body:has(.displayNumberOf) .section:not(:has(.orphanText > .dontDim), .level1, .special) > .section-heading{    
        /* background: hsl(var(--paperBehindInk), 0.05) !important; */
        background: hsl(0, 0%, 100%, 0.05) !important;
    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .section:not(.dontDim) > .section-heading{ */
        body:has(.displayNumberOf) .section:not(:has(.orphanText > .dontDim)) > .section-heading{
        color: transparent !important; /*hsl(var(--paperBehindInk), 0.05) !important;*/
        border: none;
    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .dimmedSection,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .section{ */
    body:has(.displayNumberOf) .dimmedSection,
    body:has(.displayNumberOf) .section{

        /* border-color: hsl(var(--paperBehindInk), 0.05) !important; */
        border-color: hsl(0, 0%, 100%, 0.05) !important;
        color: transparent !important;

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene:has(.dontDim){ */
        body:has(.displayNumberOf) .scene:has(.dontDim){

        outline: 2px transparent solid
        /*THIS IS THE WEIRDEST HACK: without this, the :has(:not(.dontDim)) on next line will affect stuff WITH .dontDim too */

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene:not(:has(.dontDim)),
    body:has(#notepanel.expanded .dialogtab.selectedtab) .scene:not(:has(.dontDim)) > .sceneheading,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.dimmedScene,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.dimmedScene > .sceneheading,
    body:has(#notepanel.expanded .dialogtab.selectedtab) .dimmedSection > .section-heading{ */
    body:has(.displayNumberOf) .scene:not(:has(.dontDim)),
    body:has(.displayNumberOf) .scene:not(:has(.dontDim)) > .sceneheading,
    body:has(.displayNumberOf) .scene.dimmedScene,
    body:has(.displayNumberOf) .scene.dimmedScene > .sceneheading,
    body:has(.displayNumberOf) .dimmedSection > .section-heading{

        /* --localColor: hsl(var(--paperBehindInk)) !important; */
        --localColor: hsl(var(0, 0%, 100%)) !important;
        
        border: 1px solid transparent !important;
        color: transparent !important;
        opacity: 0.05 !important;

        box-shadow: none !important;

    }

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.isHovered{ */
    body:has(.displayNumberOf) .section:is(.isSelected, .isHovered) > .section-heading,
    body:has(.displayNumberOf) .scene:is(.isSelected, .isHovered){
        
        border-color: black;
        /* border: 1px solid hsl(var(--inkOnPaper)); */
        box-shadow: /*inset 0 calc(12px * var(--fontSizeFactor)) 0 2px hsl(var(--inkOnPaper)),*/
        /* inset 0 0 0 2px hsl(var(--inkOnPaper)); */
        inset 0 0 0 1.5px hsl(0, 0%, 0%),
        /*inset*/ 0 0 0 0.5px hsl(0, 0%, 0%);
        /* background-image: -webkit-linear-gradient(top, rgba(20,20,20,0.60), rgba(20,20,20,0.60) 100%) !important; */
        /* color: white; */
        
    }
    
    body:has(.displayNumberOf):not(:has(.nonProportionalMode, .indexcards)) .scene.isOmitted{
    
        display: block !important;

        opacity: 0 !important;
        height: 0px !important;
        margin-top: 0px !important;

        transition: 200ms !important;
    }

    body:has(.displayNumberOf):not(:has(.nonProportionalMode, .indexcards)) .scene.isOmitted:is(.isSelected, .isHovered){
        
        opacity: 1 !important;
        margin-top: 1px !important;
        height: calc(14px * var(--fontSizeFactor)) !important;

    }
    /* body:has(.displayNumberOf):has(.scene.isHovered) .scene:not(.isHovered){

        opacity: 0.7

    } */

    /* body:has(#notepanel.expanded .dialogtab.selectedtab) .scene.isHovered > .sceneheading{ */
    body:has(.displayNumberOf) .scene.isHovered > .sceneheading{

        /* color: white !important;
        background: hsl(var(--inkOnPaper)); */

    }
    
    .sceneChunk{

        font-family: 'Courier Prime', 'Courier New', Courier, monospace;
    
        background: var(--menu-background);
        /* border: 1px solid hsla(var(--inkOnPaper), 0.4); */
        border: 1px solid hsla(0, 0%, 0%, 0.4);
        border-radius: 3px;

        padding: 4px;
        margin-bottom: 1px;
        
        z-index: 9996; 

        position: relative !important;
        display: block;
        opacity: 1 !important;
        visibility: visible !important;

        left: 0px !important;
        width: auto !important;

    }

    .sceneChunk.omitted{

        background-image:
			repeating-linear-gradient(
			-45deg,
			/* hsl(var(--paperBehindInk),0.4) 0px, */
			hsl(0, 0%, 100%,0.4) 0px,
			/* hsl(var(--paperBehindInk),0.4) 3px,  */
			hsl(0, 0%, 100%,0.4) 3px, 
			/* rgba(0,0,0,.3) 0px,
			rgba(0,0,0,.3) 3px,  */
			transparent 3px,
			transparent 6px
            )
            /* , linear-gradient(hsl(var(--paperBehindInk), .4), hsl(var(--paperBehindInk), .4)) */
            , linear-gradient(hsl(0, 0%, 100%, .4), hsl(0, 0%, 100%, .4))
            , linear-gradient(var(--localColor), var(--localColor))
            !important;

    }

    .sceneChunk > .chunkHeading {


        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: calc(11px * var(--fontSizeFactor)) !important;
        font-weight: bold;

        max-height: calc(18px * var(--fontSizeFactor));
        overflow: hidden !important;
        text-overflow: ellipsis;

        white-space: nowrap !important;
        word-wrap: none;

        width: calc(100% + 8px);

        margin-left: -4px;
        margin-top: -4px;
        padding: 3px 8px 1px 8px;
        margin-bottom: -1px;

        /*}*/

        position: sticky;
        top: 0;
        background: var(--localColor);
        /* background: linear-gradient(to bottom, var(--localColor) calc(100% - 5px), transparent 100%); */
        
    }
    
    .sceneChunk > .chunkHeading.isStuck{
        
        box-shadow: 0 2px 8px #333;

    }

    #dialogpanelcontent .sceneChunk:hover,
    #dialogpanelcontent .hoveredSceneChunk{

        /* box-shadow: 0 0 0 2px inset hsla(var(--inkOnPaper), 1); */
        box-shadow: 0 0 0 2px inset hsla(0, 0%, 0%, 1);
        /* border-color: hsl(var(--inkOnPaper)) */
        border-color: hsl(0, 0%, 0%)
        /* background-image: -webkit-linear-gradient(top, hsla(var(--inkOnPaper), 1), hsla(var(--inkOnPaper), 1) 100%) !important; */
    }

    #dialogpanelcontent .sceneChunk:hover > .chunkHeading,
    #dialogpanelcontent .hoveredSceneChunk > .chunkHeading{

        /* background-image: -webkit-linear-gradient(top, hsla(var(--inkOnPaper), 1), hsla(var(--inkOnPaper), 1) 100%) !important; */
        background-image: -webkit-linear-gradient(top, hsla(0, 0%, 0%, 1), hsla(0, 0%, 0%, 1) 100%) !important;
        /* color: hsl(var(--paperBehindInk)); */
        color: hsl(0, 0%, 100%);

    }

    #dialogpanelcontent .selectedSceneChunk{

        /* box-shadow: 0 0 0 3px inset hsl(var(--inkOnPaper)); */
        box-shadow: 0 0 0 3px inset hsl(0, 0%, 100%);

    }

    #dialogpanelcontent .selectedSceneChunk > .chunkHeading{

        /* background-image: -webkit-linear-gradient(top, hsl(var(--inkOnPaper)), hsl(var(--inkOnPaper)) 100%) !important; */
        background-image: -webkit-linear-gradient(top, hsl(0, 0%, 0%), hsl(0, 0%, 0%) 100%) !important;
        color: hsl(0, 0%, 100%);

    }

    .displayNumberOf {

        position: absolute;
        height: 18px;
        width: auto;
        min-width: 28px;
        padding: 0px 4px 2.5px 4px;
        
        opacity: 0.8;
        
        background: hsl(var(--inkOnPaper));
        border: 2px solid hsl(var(--paperBehindInk));
        border-radius: 15px;
        
        color: hsl(var(--paperBehindInk));
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-weight: bold;
        font-size: 9px;
        line-height: 14px;
        text-align: center;

        z-index: 9997;

        translate: -50% calc(-50% - 16px);
        overflow: visible;
    }

    .displayNumberOf::before,
    .displayNumberOf::after{

        content: "";
        position: absolute;
        bottom: 0px;
        left: 30%;
        width: 0px;
        height: 0px;
        border: 3px solid transparent;
        border-top-color: hsl(var(--inkOnPaper));
        border-left-color: hsl(var(--inkOnPaper));

        translate: 0 5.5px;
        rotate: 5deg;
        
        z-index: 10000;
    }

    .displayNumberOf::after{

        border-width: 4px;
        border-top-color: hsl(var(--paperBehindInk));
        border-left-color: hsl(var(--paperBehindInk));
        translate: -2px 9.5px;

        z-index: -9998

    }

    .scene:is(:hover, .isSelected) > .displayNumberOf{

        scale: 1.2;
        opacity: 1;

    }

    .parentIndicator{
        
        display: none;
    
    }

    .connector{

        z-index: 9997;
        overflow: visible !important;
        min-height: 0 !important;

        top: min(var(--sceneCorner), var(--chunkCorner));
        height: abs(calc(var(--sceneCorner) - var(--chunkCorner)));

        outline: 5px solid transparent; 

        transform: scaleY(sign(var(--sceneCorner) - calc(var(--chunkCorner))));
        transform-origin: center center;

        /* transition: 0.1s; */

        pointer-events: none !important;
        /* filter: drop-shadow(-3px -1px 3px rgba(0,0,0,0.3)) */


    }

    .connector svg {

        display: block;

        overflow: visible !important;
        stroke-width: 2px;
        /* stroke: hsl(var(--inkOnPaper)); */
        stroke: hsl(0, 0%, 0%);

        fill: none;

        margin: 0 !important;
        padding: 0 !important;

        top: inherit !important;
        bottom:inherit !important;
        min-height: 0 !important;


        height: 100%;

        z-index: -999;

        clip-path: polygon(0% -10%, 0% -10%, 0% 110%, 0 110%);
        animation: offset 0.2s linear forwards;

    } 

    @keyframes offset {
      to { clip-path: polygon(0% -10px, 100% -10px, 100% calc(100% + 10px), 0 calc(100% + 10px)); }
    }
    @keyframes offset-half {
      to { clip-path: polygon(0% -10px, 75% -10px, 75% calc(100% + 10px), 0 calc(100% + 10px)); }
    }

    .connector::before, 
    .connector::after{

        content: "";
        position: absolute;
        
        background: var(--localColor);
        /* border: 2px solid hsl(var(--inkOnPaper)); */
        border: 2px solid hsl(0, 0%, 0%);
        width: 8px;
        height: 8px;
        border-radius: 50%;

        z-index: -99 !important;
        
    }

    .connector::before{

        top: -6px;
        left: -10px;

    }

    .connector::after{

        /* bottom: -6px; */
        /* bottom: calc(-6px); */
        bottom: calc(var(--maxHeightOfDot) / -2 - 2px);
        right: -10px;
        max-height: var(--maxHeightOfDot);

        clip-path: polygon(75% -10%, 75% -10%, 75% 110%, 75% 110%);
        animation: offset-half 0.1s linear forwards;
        animation-delay: 0.1s;


    }

    svg .bottomstroke{
        stroke-width: 4px;
    }
    svg .topstroke{
        stroke: var(--localColor);
    }

    /* .sceneChunk:hover,
    .sceneChunk:has(.selectedDialog){

        transition: scale 0.2s;

    }

    #dialogpanelcontent:has(.sceneChunk:hover) .sceneChunk:not(:hover, .selectedDialog){

        opacity: 0.8 !important

    } */

    #flexiContainer:has(.sceneChunk:hover) .sceneChunk:not(:hover){

    }

    /* .sceneChunk .chunkHeading{


        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: calc(11px * var(--fontSizeFactor)) !important;
        font-weight: bold;

        max-height: calc(18px * var(--fontSizeFactor));
        overflow: hidden !important;
        text-overflow: ellipsis;

        white-space: nowrap !important;
        word-wrap: none;

        width: calc(100% + 8px);

        margin-left: -4px;
        margin-top: -4px;
        padding: 3px 8px 2px 8px;
        margin-bottom: -2px;

    } */

    .dialogChunk {

        white-space: normal !important;
        word-wrap: break-word !important;

        /* background: linear-gradient(hsla(var(--paperBehindInk), 0.60), hsla(var(--paperBehindInk), 0.60)), var(--localColor); */
        background: linear-gradient(hsla(0, 0%, 100%, 0.60), hsla(0, 0%, 100%, 0.60)), var(--localColor);
        /* border: 1px solid hsla(var(--inkOnPaper), 0.3); */
        border: 1px solid hsla(0, 0%, 0%, 0.3);
        /* color: hsl(var(--inkOnPaper)); */
        color: hsl(0, 0%, 0%);
        border-radius: 3px;
        width: 100%;
        
        padding: calc(5px * var(--fontSizeFactor));
        padding-top: calc(7px * var(--fontSizeFactor));
        padding-bottom: calc(4px * var(--fontSizeFactor));

        z-index: 2 !important

    }

    .dialogChunk:not(:first-child){
        
        margin-top: 3px !important; 

    }

    .dialogChunk:hover,
    .dialogChunk.selectedDialog{
        background-color: inherit;
        /* background-image: linear-gradient(hsla(var(--paperBehindInk), 1), hsla(var(--paperBehindInk), 1)) ; */
        background-image: linear-gradient(hsla(0, 0%, 100%, 1), hsla(0, 0%, 100%, 1)) ;
        /* color: hsl(var(--inkOnPaper)) !important; */
        color: hsl(0, 0, 0%) !important;

        transition: scale 0.2s;

        z-index: 9999 !important;

    }

    .dialogChunk.hasCursor{

        box-shadow: 0px 0px 0px 2px red ;

    }

    .sceneChunk p{

        font-family: 'Courier Prime', 'Courier New', Courier, monospace;
        color: inherit;

        white-space: normal !important;
        word-wrap: break-word;

    }

    #dialogpanelcontent .dialogChunk p{

        font-size: calc(10px * var(--fontSizeFactor)) !important;

    }

    .dialogChunk p.character{

        padding-left: 9ch !important;

    }

    body:not(:has(#allDialogFor option:checked[value="ALL"])) .dialogChunk p.character{

        display: none;
        outline: 3px solid orange

    }

    .dialogChunk p.parenthetical{
        
        padding-left: 6ch !important;

    }

    .dialogChunk i{

        white-space: normal;
        word-wrap: break-word;
        font-style: italic;

    }

    .dialogChunk b{

        white-space: normal;
        word-wrap: break-word;
        font-weight: bold;

    }

    .dialogChunk:has(:not(.omitted)) :is(p, span).omitted,
    .dialogChunk:not(:has(:not(.omitted)))
    {

        text-decoration: line-through;
        white-space: normal;
        word-wrap: break-word;

        z-index: -1 !important;

        /* color: hsla(var(--inkOnPaper), 0.5); */
        color: hsla(0, 0%, 0%, 0.5);

        background-image:
			repeating-linear-gradient(
			-45deg,
			/* hsl(var(--paperBehindInk),0.4) 0px,
			hsl(var(--paperBehindInk),0.4) 3px,  */
			hsl(0, 0%, 100%, 0.4) 0px,
			hsl(0, 0%, 100%, 0.4) 3px, 
			/* rgba(0,0,0,.3) 0px,
			rgba(0,0,0,.3) 3px,  */
			transparent 3px,
			transparent 6px
            )
            /* , linear-gradient(hsl(var(--paperBehindInk), .4), hsl(var(--paperBehindInk), .4))
            , linear-gradient(var(--localColor), var(--localColor)) */
            , linear-gradient(hsl(0, 0%, 100%, .4), hsl(0, 0%, 100%, .4))
            , linear-gradient(var(--localColor), var(--localColor))
            !important;
            
        background-color:inherit

    }

    .scene.isEnlarged{

        transform-origin: center top;
        scale: 1.1 !important;

        transition: all 0.2s !important;

    }
    
</style>

